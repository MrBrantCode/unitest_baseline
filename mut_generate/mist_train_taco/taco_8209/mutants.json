{
  "task_id": "taco_8209",
  "entry_point": "calculate_expected_B_squared",
  "mutant_count": 269,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "EX2 += EX",
      "mutated_line": "EX2 -= EX",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 -= EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 - 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 - 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 * 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 * 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [0] * n",
      "mutated_line": "P = [0] / n",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] / n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [0] * n",
      "mutated_line": "P = [0] + n",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] + n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "P = [0] * n",
      "mutated_line": "P = [0] ** n",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] ** n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "pre = [0] * n",
      "mutated_line": "pre = [0] / n",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] / n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "pre = [0] * n",
      "mutated_line": "pre = [0] + n",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] + n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "pre = [0] * n",
      "mutated_line": "pre = [0] ** n",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] ** n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "EX = sum(P) % mod",
      "mutated_line": "EX = sum(P) * mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) * mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "EX = sum(P) % mod",
      "mutated_line": "EX = sum(P) + mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) + mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 2 * EX + 1) * mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) * mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = EX2 + 2 * EX + 1 + mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = EX2 + 2 * EX + 1 + mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 * 9 + 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 * 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 + 9 + 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 + 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 8",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 8\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 6",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 6\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 0",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 0\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + 1",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 1\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 9 + -7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + -7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res = 1",
      "mutated_line": "res = 2",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 2\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 0\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res = 1",
      "mutated_line": "res = 0",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 0\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "res = 1",
      "mutated_line": "res = -1",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = -1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "x = x % p",
      "mutated_line": "x = x * p",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x * p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "x = x % p",
      "mutated_line": "x = x + p",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x + p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if x == 0:",
      "mutated_line": "if x != 0:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x != 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while y > 0:",
      "mutated_line": "while y >= 0:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y >= 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while y > 0:",
      "mutated_line": "while y <= 0:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y <= 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while y > 0:",
      "mutated_line": "while y != 0:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y != 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if l_ > r_:",
      "mutated_line": "if l_ >= r_:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ >= r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if l_ > r_:",
      "mutated_line": "if l_ <= r_:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ <= r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if l_ > r_:",
      "mutated_line": "if l_ != r_:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ != r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "p = r_ - l_ + 1",
      "mutated_line": "p = r_ - l_ - 1",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ - 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "p = r_ - l_ + 1",
      "mutated_line": "p = (r_ - l_) * 1",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = (r_ - l_) * 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "p *= reverse(r - l + 1, mod)",
      "mutated_line": "p /= reverse(r - l + 1, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p /= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (1 - p) % mod",
      "mutated_line": "return (1 - p) * mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) * mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (1 - p) % mod",
      "mutated_line": "return 1 - p + mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return 1 - p + mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(EX, EX2) = (0, 0)",
      "mutated_line": "(EX, EX2) = (1, 0)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (1, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(EX, EX2) = (0, 0)",
      "mutated_line": "(EX, EX2) = (-1, 0)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (-1, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(EX, EX2) = (0, 0)",
      "mutated_line": "(EX, EX2) = (1, 0)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (1, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(EX, EX2) = (0, 0)",
      "mutated_line": "(EX, EX2) = (0, 1)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 1)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(EX, EX2) = (0, 0)",
      "mutated_line": "(EX, EX2) = (0, -1)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, -1)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(EX, EX2) = (0, 0)",
      "mutated_line": "(EX, EX2) = (0, 1)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 1)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(2, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(0, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(0, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(-1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "pre[i] = (pre[i - 1] + P[i]) % mod",
      "mutated_line": "pre[i] = (pre[i - 1] + P[i]) * mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) * mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "pre[i] = (pre[i - 1] + P[i]) % mod",
      "mutated_line": "pre[i] = pre[i - 1] + P[i] + mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = pre[i - 1] + P[i] + mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if i >= 2:",
      "mutated_line": "if i > 2:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i > 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if i >= 2:",
      "mutated_line": "if i < 2:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i < 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if i >= 2:",
      "mutated_line": "if i == 2:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i == 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 -= 2 * (P[i] * pre[i - 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 -= 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 2 * EX - 1) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX - 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 2 * EX) * 1 % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX) * 1 % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 11 ** 9 + 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 11 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 9 ** 9 + 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 9 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 0 ** 9 + 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 0 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 1 ** 9 + 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 1 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = -10 ** 9 + 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = -10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 10 + 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 10 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 8 + 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 8 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 0 + 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 0 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** 1 + 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 1 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "mod = 10 ** 9 + 7",
      "mutated_line": "mod = 10 ** -9 + 7",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** -9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if x == 0:",
      "mutated_line": "if x == 1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 1:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if x == 0:",
      "mutated_line": "if x == -1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == -1:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if x == 0:",
      "mutated_line": "if x == 1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 1:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 1\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return -1\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 1\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while y > 0:",
      "mutated_line": "while y > 1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 1:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while y > 0:",
      "mutated_line": "while y > -1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > -1:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while y > 0:",
      "mutated_line": "while y > 1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 1:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if y & 1 == 1:",
      "mutated_line": "if y & 1 != 1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 != 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = x * x % p",
      "mutated_line": "x = x * x * p",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x * p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = x * x % p",
      "mutated_line": "x = x * x + p",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x + p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return pow_(x, mod - 2, mod)",
      "mutated_line": "return pow_(x, mod + 2, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod + 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "return pow_(x, mod - 2, mod)",
      "mutated_line": "return pow_(x, mod * 2, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod * 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 2\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 0\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 0\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return -1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "p = r_ - l_ + 1",
      "mutated_line": "p = r_ + l_ + 1",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ + l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "p = r_ - l_ + 1",
      "mutated_line": "p = r_ * l_ + 1",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ * l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p = r_ - l_ + 1",
      "mutated_line": "p = r_ - l_ + 2",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 2\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p = r_ - l_ + 1",
      "mutated_line": "p = r_ - l_ + 0",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 0\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p = r_ - l_ + 1",
      "mutated_line": "p = r_ - l_ + 0",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 0\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "p = r_ - l_ + 1",
      "mutated_line": "p = r_ - l_ + -1",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + -1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (1 - p) % mod",
      "mutated_line": "return (1 + p) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 + p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return (1 - p) % mod",
      "mutated_line": "return 1 * p % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return 1 * p % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [0] * n",
      "mutated_line": "P = [1] * n",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [1] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [0] * n",
      "mutated_line": "P = [-1] * n",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [-1] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "P = [0] * n",
      "mutated_line": "P = [1] * n",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [1] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pre = [0] * n",
      "mutated_line": "pre = [1] * n",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [1] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pre = [0] * n",
      "mutated_line": "pre = [-1] * n",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [-1] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "pre = [0] * n",
      "mutated_line": "pre = [1] * n",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [1] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "pre[i] = (pre[i - 1] + P[i]) % mod",
      "mutated_line": "pre[i] = (pre[i - 1] - P[i]) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] - P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "pre[i] = (pre[i - 1] + P[i]) % mod",
      "mutated_line": "pre[i] = pre[i - 1] * P[i] % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = pre[i - 1] * P[i] % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if i >= 2:",
      "mutated_line": "if i >= 3:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 3:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if i >= 2:",
      "mutated_line": "if i >= 1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 1:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if i >= 2:",
      "mutated_line": "if i >= 0:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 0:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if i >= 2:",
      "mutated_line": "if i >= 1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 1:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if i >= 2:",
      "mutated_line": "if i >= -2:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= -2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "p_ = 1 - (pA + pB - pAB)",
      "mutated_line": "p_ = 1 + (pA + pB - pAB)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 + (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "p_ = 1 - (pA + pB - pAB)",
      "mutated_line": "p_ = 1 * (pA + pB - pAB)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 * (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) * mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) * mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) + mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) + mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 - 2 * EX + 1) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 - 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 * (2 * EX) + 1) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 * (2 * EX) + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 2 * EX + 2) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 2) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 2 * EX + 0) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 0) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 2 * EX + 0) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 0) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 2 * EX + -1) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + -1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if y & 1 == 1:",
      "mutated_line": "if y | 1 == 1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y | 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if y & 1 == 1:",
      "mutated_line": "if y & 1 == 2:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 2:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if y & 1 == 1:",
      "mutated_line": "if y & 1 == 0:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 0:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if y & 1 == 1:",
      "mutated_line": "if y & 1 == 0:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 0:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if y & 1 == 1:",
      "mutated_line": "if y & 1 == -1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == -1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = res * x % p",
      "mutated_line": "res = res * x * p",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x * p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = res * x % p",
      "mutated_line": "res = res * x + p",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x + p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "y = y >> 1",
      "mutated_line": "y = y >> 2",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 2\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "y = y >> 1",
      "mutated_line": "y = y >> 0",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 0\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "y = y >> 1",
      "mutated_line": "y = y >> 0",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 0\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "y = y >> 1",
      "mutated_line": "y = y >> -1",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> -1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = x * x % p",
      "mutated_line": "x = x / x % p",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x / x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = x * x % p",
      "mutated_line": "x = (x + x) % p",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = (x + x) % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x = x * x % p",
      "mutated_line": "x = x ** x % p",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x ** x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return pow_(x, mod - 2, mod)",
      "mutated_line": "return pow_(x, mod - 3, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 3, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return pow_(x, mod - 2, mod)",
      "mutated_line": "return pow_(x, mod - 1, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 1, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return pow_(x, mod - 2, mod)",
      "mutated_line": "return pow_(x, mod - 0, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 0, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return pow_(x, mod - 2, mod)",
      "mutated_line": "return pow_(x, mod - 1, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 1, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return pow_(x, mod - 2, mod)",
      "mutated_line": "return pow_(x, mod - -2, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - -2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p *= reverse(r - l + 1, mod)",
      "mutated_line": "p *= reverse(r - l - 1, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l - 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p *= reverse(r - l + 1, mod)",
      "mutated_line": "p *= reverse((r - l) * 1, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse((r - l) * 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (1 - p) % mod",
      "mutated_line": "return (2 - p) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (2 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (1 - p) % mod",
      "mutated_line": "return (0 - p) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (0 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (1 - p) % mod",
      "mutated_line": "return (0 - p) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (0 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return (1 - p) % mod",
      "mutated_line": "return (-1 - p) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (-1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 + P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 + P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 * P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 * P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 + P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 + P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 * P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 * P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 + prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 + prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 * prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 * prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "p_ = 1 - (pA + pB - pAB)",
      "mutated_line": "p_ = 2 - (pA + pB - pAB)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 2 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "p_ = 1 - (pA + pB - pAB)",
      "mutated_line": "p_ = 0 - (pA + pB - pAB)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 0 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "p_ = 1 - (pA + pB - pAB)",
      "mutated_line": "p_ = 0 - (pA + pB - pAB)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 0 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "p_ = 1 - (pA + pB - pAB)",
      "mutated_line": "p_ = -1 - (pA + pB - pAB)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = -1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "p_ = 1 - (pA + pB - pAB)",
      "mutated_line": "p_ = 1 - (pA + pB + pAB)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB + pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "p_ = 1 - (pA + pB - pAB)",
      "mutated_line": "p_ = 1 - (pA + pB) * pAB",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB) * pAB\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 / (P[i] * pre[i - 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 / (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += (2 + (P[i] * pre[i - 2] + p_)) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += (2 + (P[i] * pre[i - 2] + p_)) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 ** (P[i] * pre[i - 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 ** (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 2 / EX + 1) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 / EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + (2 + EX) + 1) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + (2 + EX) + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 2 ** EX + 1) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 ** EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if y & 1 == 1:",
      "mutated_line": "if y & 2 == 1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 2 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if y & 1 == 1:",
      "mutated_line": "if y & 0 == 1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 0 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if y & 1 == 1:",
      "mutated_line": "if y & 0 == 1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 0 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if y & 1 == 1:",
      "mutated_line": "if y & -1 == 1:",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & -1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = res * x % p",
      "mutated_line": "res = res / x % p",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res / x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = res * x % p",
      "mutated_line": "res = (res + x) % p",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = (res + x) % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = res * x % p",
      "mutated_line": "res = res ** x % p",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res ** x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p *= reverse(r - l + 1, mod)",
      "mutated_line": "p *= reverse(r + l + 1, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r + l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "p *= reverse(r - l + 1, mod)",
      "mutated_line": "p *= reverse(r * l + 1, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r * l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p *= reverse(r - l + 1, mod)",
      "mutated_line": "p *= reverse(r - l + 2, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 2, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p *= reverse(r - l + 1, mod)",
      "mutated_line": "p *= reverse(r - l + 0, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 0, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p *= reverse(r - l + 1, mod)",
      "mutated_line": "p *= reverse(r - l + 0, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 0, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "p *= reverse(r - l + 1, mod)",
      "mutated_line": "p *= reverse(r - l + -1, mod)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + -1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i + 1:i + 1], R[i - 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i + 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i * 1:i + 1], R[i - 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i * 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i - 1], R[i - 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i - 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i * 1], R[i - 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i * 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 1], R[i + 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i + 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 1], R[i * 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i * 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i - 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i - 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i * 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i * 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "pre[i] = (pre[i - 1] + P[i]) % mod",
      "mutated_line": "pre[i] = (pre[i + 1] + P[i]) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i + 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "pre[i] = (pre[i - 1] + P[i]) % mod",
      "mutated_line": "pre[i] = (pre[i * 1] + P[i]) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i * 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (2 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (2 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (0 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (0 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (0 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (0 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (-1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (-1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 2 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 2 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 0 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 0 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 0 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 0 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], -1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], -1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 2 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 2 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 0 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 0 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 0 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 0 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], -1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], -1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "p_ = 1 - (pA + pB - pAB)",
      "mutated_line": "p_ = 1 - (pA - pB - pAB)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA - pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "p_ = 1 - (pA + pB - pAB)",
      "mutated_line": "p_ = 1 - (pA * pB - pAB)",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA * pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 3 * (P[i] * pre[i - 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 3 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 1 * (P[i] * pre[i - 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 1 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 0 * (P[i] * pre[i - 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 0 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 1 * (P[i] * pre[i - 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 1 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += -2 * (P[i] * pre[i - 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += -2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] * pre[i - 2] - p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] - p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] * pre[i - 2] * p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] * p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 3 * EX + 1) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 3 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 1 * EX + 1) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 1 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 0 * EX + 1) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 0 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + 1 * EX + 1) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 1 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "ans = (EX2 + 2 * EX + 1) % mod",
      "mutated_line": "ans = (EX2 + -2 * EX + 1) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + -2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 2:i + 1], R[i - 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 2:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 0:i + 1], R[i - 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 0:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 0:i + 1], R[i - 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 0:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - -1:i + 1], R[i - 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - -1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 2], R[i - 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 2], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 0], R[i - 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 0], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 0], R[i - 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 0], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + -1], R[i - 1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + -1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 1], R[i - 2:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 2:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 1], R[i - 0:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 0:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 1], R[i - 0:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 0:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 1], R[i - -1:i + 1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - -1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 2])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 2])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 0])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 0])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 0])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 0])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])",
      "mutated_line": "P[i] = prob(L[i - 1:i + 1], R[i - 1:i + -1])",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + -1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pre[i] = (pre[i - 1] + P[i]) % mod",
      "mutated_line": "pre[i] = (pre[i - 2] + P[i]) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 2] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pre[i] = (pre[i - 1] + P[i]) % mod",
      "mutated_line": "pre[i] = (pre[i - 0] + P[i]) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 0] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pre[i] = (pre[i - 1] + P[i]) % mod",
      "mutated_line": "pre[i] = (pre[i - 0] + P[i]) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 0] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "pre[i] = (pre[i - 1] + P[i]) % mod",
      "mutated_line": "pre[i] = (pre[i - -1] + P[i]) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - -1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i + 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i + 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i * 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i * 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] / pre[i - 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] / pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] + pre[i - 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] + pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] ** pre[i - 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] ** pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 2], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 2], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 0], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 0], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 0], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 0], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - -1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - -1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i + 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i + 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i * 2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i * 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i - 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i - 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i * 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i * 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i + 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i + 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i * 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i * 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i - 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i - 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i * 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i * 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] * pre[i + 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i + 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] * pre[i * 2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i * 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 3:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 3:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 1:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 1:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 0:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 0:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 1:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 1:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - -2:i + 1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - -2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 2], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 2], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 0], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 0], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 0], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 0], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + -1], R[i - 2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + -1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 3:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 3:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 1:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 1:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 0:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 0:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 1:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 1:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - -2:i + 1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - -2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 2]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 2]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 0]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 0]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 0]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 0]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))",
      "mutated_line": "(pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + -1]))",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + -1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] * pre[i - 3] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 3] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] * pre[i - 1] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 1] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] * pre[i - 0] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 0] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] * pre[i - 1] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - 1] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "EX2 += 2 * (P[i] * pre[i - 2] + p_) % mod",
      "mutated_line": "EX2 += 2 * (P[i] * pre[i - -2] + p_) % mod",
      "code": "def calculate_expected_B_squared(n, L, R):\n    mod = 10 ** 9 + 7\n\n    def pow_(x, y, p):\n        res = 1\n        x = x % p\n        if x == 0:\n            return 0\n        while y > 0:\n            if y & 1 == 1:\n                res = res * x % p\n            y = y >> 1\n            x = x * x % p\n        return res\n\n    def reverse(x, mod):\n        return pow_(x, mod - 2, mod)\n\n    def prob(l_arr, r_arr):\n        (l_, r_) = (max(l_arr), min(r_arr))\n        if l_ > r_:\n            return 1\n        p = r_ - l_ + 1\n        for (l, r) in zip(l_arr, r_arr):\n            p *= reverse(r - l + 1, mod)\n        return (1 - p) % mod\n    (EX, EX2) = (0, 0)\n    P = [0] * n\n    pre = [0] * n\n    for i in range(1, n):\n        P[i] = prob(L[i - 1:i + 1], R[i - 1:i + 1])\n        pre[i] = (pre[i - 1] + P[i]) % mod\n        if i >= 2:\n            (pA, pB, pAB) = (1 - P[i - 1], 1 - P[i], 1 - prob(L[i - 2:i + 1], R[i - 2:i + 1]))\n            p_ = 1 - (pA + pB - pAB)\n            EX2 += 2 * (P[i] * pre[i - -2] + p_) % mod\n    EX = sum(P) % mod\n    EX2 += EX\n    ans = (EX2 + 2 * EX + 1) % mod\n    return ans"
    }
  ]
}