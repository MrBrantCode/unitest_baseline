{
  "task_id": "taco_10903",
  "entry_point": "count_heap_violations",
  "mutant_count": 182,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 1\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "j = 0",
      "mutated_line": "j = -1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = -1\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 1\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "aib = [0] * (n + 1)",
      "mutated_line": "aib = [0] / (n + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] / (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "aib = [0] * (n + 1)",
      "mutated_line": "aib = [0] + (n + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] + (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "aib = [0] * (n + 1)",
      "mutated_line": "aib = [0] ** (n + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] ** (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "r = [0] * (n + 1)",
      "mutated_line": "r = [0] / (n + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] / (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "r = [0] * (n + 1)",
      "mutated_line": "r = [0] + (n + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] + (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "r = [0] * (n + 1)",
      "mutated_line": "r = [0] ** (n + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] ** (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return -(x ^ -x) // 2",
      "mutated_line": "return -(x ^ -x) / 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) / 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return -(x ^ -x) // 2",
      "mutated_line": "return -(x ^ -x) * 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) * 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while p <= n:",
      "mutated_line": "while p < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p < n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while p <= n:",
      "mutated_line": "while p > n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p > n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while p <= n:",
      "mutated_line": "while p == n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p == n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "aib[p] += a",
      "mutated_line": "aib[p] -= a",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] -= a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "p += ultb(p)",
      "mutated_line": "p -= ultb(p)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p -= ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 1\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r = 0",
      "mutated_line": "r = -1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = -1\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "r = 0",
      "mutated_line": "r = 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 1\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while p > 0:",
      "mutated_line": "while p >= 0:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p >= 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while p > 0:",
      "mutated_line": "while p <= 0:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p <= 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "while p > 0:",
      "mutated_line": "while p != 0:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p != 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "r += aib[p]",
      "mutated_line": "r -= aib[p]",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r -= aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "p -= ultb(p)",
      "mutated_line": "p += ultb(p)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p += ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "aib = [0] * (n + 1)",
      "mutated_line": "aib = [0] * (n - 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n - 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "aib = [0] * (n + 1)",
      "mutated_line": "aib = [0] * (n * 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n * 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(0, n):",
      "mutated_line": "for i in range(1, n):",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(1, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(0, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(-1, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in range(0, n):",
      "mutated_line": "for i in range(1, n):",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(1, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "r = [0] * (n + 1)",
      "mutated_line": "r = [0] * (n - 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n - 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "r = [0] * (n + 1)",
      "mutated_line": "r = [0] * (n * 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n * 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(0, n):",
      "mutated_line": "for i in range(1, n):",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(1, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(0, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(-1, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(0, n):",
      "mutated_line": "for i in range(1, n):",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(1, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > 0 or a[i - 1] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 or a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "r[1] += 1",
      "mutated_line": "r[1] -= 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] -= 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "while j < n and a[p[j]] == a[p[i]]:",
      "mutated_line": "while j < n or a[p[j]] == a[p[i]]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n or a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j -= 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "k = 2",
      "mutated_line": "k = 3",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 3\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "k = 2",
      "mutated_line": "k = 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 1\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "k = 2",
      "mutated_line": "k = 0",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 0\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "k = 2",
      "mutated_line": "k = 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 1\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "k = 2",
      "mutated_line": "k = -2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = -2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "LCR",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n or p[i] * k + 1 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n or p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ASR",
      "lineno": 42,
      "original_line": "r[k] += suma(dr, aib) - suma(st - 1, aib)",
      "mutated_line": "r[k] -= suma(dr, aib) - suma(st - 1, aib)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] -= suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ASR",
      "lineno": 43,
      "original_line": "k += 1",
      "mutated_line": "k -= 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k -= 1\n    return r[1:n]"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "return -(x ^ -x) // 2",
      "mutated_line": "return +(x ^ -x) // 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return +(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return -(x ^ -x) // 2",
      "mutated_line": "return -(x ^ -x) // 3",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 3\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return -(x ^ -x) // 2",
      "mutated_line": "return -(x ^ -x) // 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 1\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return -(x ^ -x) // 2",
      "mutated_line": "return -(x ^ -x) // 0",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 0\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return -(x ^ -x) // 2",
      "mutated_line": "return -(x ^ -x) // 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 1\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return -(x ^ -x) // 2",
      "mutated_line": "return -(x ^ -x) // -2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // -2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while p > 0:",
      "mutated_line": "while p > 1:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 1:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while p > 0:",
      "mutated_line": "while p > -1:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > -1:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "while p > 0:",
      "mutated_line": "while p > 1:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 1:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "aib = [0] * (n + 1)",
      "mutated_line": "aib = [1] * (n + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [1] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "aib = [0] * (n + 1)",
      "mutated_line": "aib = [-1] * (n + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [-1] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "aib = [0] * (n + 1)",
      "mutated_line": "aib = [1] * (n + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [1] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "aib = [0] * (n + 1)",
      "mutated_line": "aib = [0] * (n + 2)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 2)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "aib = [0] * (n + 1)",
      "mutated_line": "aib = [0] * (n + 0)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 0)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "aib = [0] * (n + 1)",
      "mutated_line": "aib = [0] * (n + 0)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 0)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "aib = [0] * (n + 1)",
      "mutated_line": "aib = [0] * (n + -1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + -1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "add(i + 1, 1, aib, n)",
      "mutated_line": "add(i - 1, 1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i - 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "add(i + 1, 1, aib, n)",
      "mutated_line": "add(i * 1, 1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i * 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "add(i + 1, 1, aib, n)",
      "mutated_line": "add(i + 1, 2, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 2, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "add(i + 1, 1, aib, n)",
      "mutated_line": "add(i + 1, 0, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 0, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "add(i + 1, 1, aib, n)",
      "mutated_line": "add(i + 1, 0, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 0, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "add(i + 1, 1, aib, n)",
      "mutated_line": "add(i + 1, -1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, -1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = [0] * (n + 1)",
      "mutated_line": "r = [1] * (n + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [1] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = [0] * (n + 1)",
      "mutated_line": "r = [-1] * (n + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [-1] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = [0] * (n + 1)",
      "mutated_line": "r = [1] * (n + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [1] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = [0] * (n + 1)",
      "mutated_line": "r = [0] * (n + 2)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 2)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = [0] * (n + 1)",
      "mutated_line": "r = [0] * (n + 0)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 0)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = [0] * (n + 1)",
      "mutated_line": "r = [0] * (n + 0)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 0)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "r = [0] * (n + 1)",
      "mutated_line": "r = [0] * (n + -1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + -1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i >= 0 and a[i - 1] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i >= 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i <= 0 and a[i - 1] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i <= 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i != 0 and a[i - 1] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i != 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > 0 and a[i - 1] >= a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] >= a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > 0 and a[i - 1] <= a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] <= a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > 0 and a[i - 1] != a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] != a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "r[1] += 1",
      "mutated_line": "r[1] += 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 2\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "r[1] += 1",
      "mutated_line": "r[1] += 0",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 0\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "r[1] += 1",
      "mutated_line": "r[1] += 0",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 0\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "r[1] += 1",
      "mutated_line": "r[1] += -1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += -1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while j < n and a[p[j]] == a[p[i]]:",
      "mutated_line": "while j <= n and a[p[j]] == a[p[i]]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j <= n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while j < n and a[p[j]] == a[p[i]]:",
      "mutated_line": "while j >= n and a[p[j]] == a[p[i]]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j >= n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while j < n and a[p[j]] == a[p[i]]:",
      "mutated_line": "while j != n and a[p[j]] == a[p[i]]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j != n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "while j < n and a[p[j]] == a[p[i]]:",
      "mutated_line": "while j < n and a[p[j]] != a[p[i]]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] != a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 2\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 0\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 0\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += -1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k <= n and p[i] * k + 1 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k <= n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k >= n and p[i] * k + 1 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k >= n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k != n and p[i] * k + 1 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k != n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n and p[i] * k + 1 <= n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 <= n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n and p[i] * k + 1 >= n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 >= n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n and p[i] * k + 1 != n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 != n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "st = p[i] * k + 2",
      "mutated_line": "st = p[i] * k - 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k - 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "st = p[i] * k + 2",
      "mutated_line": "st = p[i] * k * 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k * 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r[k] += suma(dr, aib) - suma(st - 1, aib)",
      "mutated_line": "r[k] += suma(dr, aib) + suma(st - 1, aib)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) + suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r[k] += suma(dr, aib) - suma(st - 1, aib)",
      "mutated_line": "r[k] += suma(dr, aib) * suma(st - 1, aib)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) * suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "k += 1",
      "mutated_line": "k += 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 2\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 0\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "k += 1",
      "mutated_line": "k += 0",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 0\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "k += 1",
      "mutated_line": "k += -1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += -1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return r[1:n]",
      "mutated_line": "return r[2:n]",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[2:n]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return r[1:n]",
      "mutated_line": "return r[0:n]",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[0:n]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return r[1:n]",
      "mutated_line": "return r[0:n]",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[0:n]"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "return r[1:n]",
      "mutated_line": "return r[-1:n]",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[-1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = [pr[1] for pr in b]",
      "mutated_line": "r = [pr[2] for pr in b]",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[2] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = [pr[1] for pr in b]",
      "mutated_line": "r = [pr[0] for pr in b]",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[0] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = [pr[1] for pr in b]",
      "mutated_line": "r = [pr[0] for pr in b]",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[0] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "r = [pr[1] for pr in b]",
      "mutated_line": "r = [pr[-1] for pr in b]",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[-1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "return -(x ^ -x) // 2",
      "mutated_line": "return -(x | -x) // 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x | -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "add(i + 1, 1, aib, n)",
      "mutated_line": "add(i + 2, 1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 2, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "add(i + 1, 1, aib, n)",
      "mutated_line": "add(i + 0, 1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 0, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "add(i + 1, 1, aib, n)",
      "mutated_line": "add(i + 0, 1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 0, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "add(i + 1, 1, aib, n)",
      "mutated_line": "add(i + -1, 1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + -1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > 1 and a[i - 1] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 1 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > -1 and a[i - 1] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > -1 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > 1 and a[i - 1] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 1 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "r[1] += 1",
      "mutated_line": "r[2] += 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[2] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "r[1] += 1",
      "mutated_line": "r[0] += 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[0] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "r[1] += 1",
      "mutated_line": "r[0] += 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[0] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "r[1] += 1",
      "mutated_line": "r[-1] += 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[-1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "add(p[j] + 1, -1, aib, n)",
      "mutated_line": "add(p[j] - 1, -1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] - 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "add(p[j] + 1, -1, aib, n)",
      "mutated_line": "add(p[j] * 1, -1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] * 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "UOI",
      "lineno": 36,
      "original_line": "add(p[j] + 1, -1, aib, n)",
      "mutated_line": "add(p[j] + 1, +1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, +1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n and p[i] * k - 1 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k - 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n and p[i] * k * 1 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k * 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dr = min(n, p[i] * k + k + 1)",
      "mutated_line": "dr = min(n, p[i] * k + k - 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k - 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dr = min(n, p[i] * k + k + 1)",
      "mutated_line": "dr = min(n, (p[i] * k + k) * 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, (p[i] * k + k) * 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "st = p[i] * k + 2",
      "mutated_line": "st = p[i] / k + 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] / k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "st = p[i] * k + 2",
      "mutated_line": "st = p[i] + k + 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] + k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "st = p[i] * k + 2",
      "mutated_line": "st = p[i] ** k + 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] ** k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "st = p[i] * k + 2",
      "mutated_line": "st = p[i] * k + 3",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 3\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "st = p[i] * k + 2",
      "mutated_line": "st = p[i] * k + 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 1\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "st = p[i] * k + 2",
      "mutated_line": "st = p[i] * k + 0",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 0\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "st = p[i] * k + 2",
      "mutated_line": "st = p[i] * k + 1",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 1\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "st = p[i] * k + 2",
      "mutated_line": "st = p[i] * k + -2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + -2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = list(zip(a, range(0, len(a))))",
      "mutated_line": "b = list(zip(a, range(1, len(a))))",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(1, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = list(zip(a, range(0, len(a))))",
      "mutated_line": "b = list(zip(a, range(-1, len(a))))",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(-1, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "b = list(zip(a, range(0, len(a))))",
      "mutated_line": "b = list(zip(a, range(1, len(a))))",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(1, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "return -(x ^ -x) // 2",
      "mutated_line": "return -(x ^ +x) // 2",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ +x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > 0 and a[i + 1] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i + 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > 0 and a[i * 1] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i * 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "add(p[j] + 1, -1, aib, n)",
      "mutated_line": "add(p[j] + 2, -1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 2, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "add(p[j] + 1, -1, aib, n)",
      "mutated_line": "add(p[j] + 0, -1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 0, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "add(p[j] + 1, -1, aib, n)",
      "mutated_line": "add(p[j] + 0, -1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 0, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "add(p[j] + 1, -1, aib, n)",
      "mutated_line": "add(p[j] + -1, -1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + -1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "add(p[j] + 1, -1, aib, n)",
      "mutated_line": "add(p[j] + 1, -2, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -2, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "add(p[j] + 1, -1, aib, n)",
      "mutated_line": "add(p[j] + 1, -0, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -0, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "add(p[j] + 1, -1, aib, n)",
      "mutated_line": "add(p[j] + 1, -0, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -0, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "add(p[j] + 1, -1, aib, n)",
      "mutated_line": "add(p[j] + 1, --1, aib, n)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, --1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n and p[i] / k + 1 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] / k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n and p[i] + k + 1 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] + k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n and p[i] ** k + 1 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] ** k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n and p[i] * k + 2 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 2 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n and p[i] * k + 0 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 0 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n and p[i] * k + 0 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 0 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while k < n and p[i] * k + 1 < n:",
      "mutated_line": "while k < n and p[i] * k + -1 < n:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + -1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dr = min(n, p[i] * k + k + 1)",
      "mutated_line": "dr = min(n, p[i] * k - k + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k - k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dr = min(n, p[i] * k + k + 1)",
      "mutated_line": "dr = min(n, p[i] * k * k + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k * k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dr = min(n, p[i] * k + k + 1)",
      "mutated_line": "dr = min(n, p[i] * k + k + 2)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 2)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dr = min(n, p[i] * k + k + 1)",
      "mutated_line": "dr = min(n, p[i] * k + k + 0)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 0)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dr = min(n, p[i] * k + k + 1)",
      "mutated_line": "dr = min(n, p[i] * k + k + 0)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 0)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "dr = min(n, p[i] * k + k + 1)",
      "mutated_line": "dr = min(n, p[i] * k + k + -1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + -1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r[k] += suma(dr, aib) - suma(st - 1, aib)",
      "mutated_line": "r[k] += suma(dr, aib) - suma(st + 1, aib)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st + 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "r[k] += suma(dr, aib) - suma(st - 1, aib)",
      "mutated_line": "r[k] += suma(dr, aib) - suma(st * 1, aib)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st * 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > 0 and a[i - 2] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 2] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > 0 and a[i - 0] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 0] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > 0 and a[i - 0] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 0] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if i > 0 and a[i - 1] > a[i]:",
      "mutated_line": "if i > 0 and a[i - -1] > a[i]:",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - -1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dr = min(n, p[i] * k + k + 1)",
      "mutated_line": "dr = min(n, p[i] / k + k + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] / k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dr = min(n, p[i] * k + k + 1)",
      "mutated_line": "dr = min(n, p[i] + k + k + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] + k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "dr = min(n, p[i] * k + k + 1)",
      "mutated_line": "dr = min(n, p[i] ** k + k + 1)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] ** k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 1, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r[k] += suma(dr, aib) - suma(st - 1, aib)",
      "mutated_line": "r[k] += suma(dr, aib) - suma(st - 2, aib)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 2, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r[k] += suma(dr, aib) - suma(st - 1, aib)",
      "mutated_line": "r[k] += suma(dr, aib) - suma(st - 0, aib)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 0, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r[k] += suma(dr, aib) - suma(st - 1, aib)",
      "mutated_line": "r[k] += suma(dr, aib) - suma(st - 0, aib)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - 0, aib)\n            k += 1\n    return r[1:n]"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "r[k] += suma(dr, aib) - suma(st - 1, aib)",
      "mutated_line": "r[k] += suma(dr, aib) - suma(st - -1, aib)",
      "code": "def count_heap_violations(n, a):\n\n    def myargsort(a):\n        b = list(zip(a, range(0, len(a))))\n        b.sort()\n        r = [pr[1] for pr in b]\n        return r\n\n    def ultb(x):\n        return -(x ^ -x) // 2\n\n    def add(p, a, aib, n):\n        while p <= n:\n            aib[p] += a\n            p += ultb(p)\n\n    def suma(p, aib):\n        r = 0\n        while p > 0:\n            r += aib[p]\n            p -= ultb(p)\n        return r\n    p = myargsort(a)\n    p.reverse()\n    j = 0\n    aib = [0] * (n + 1)\n    for i in range(0, n):\n        add(i + 1, 1, aib, n)\n    r = [0] * (n + 1)\n    for i in range(0, n):\n        if i > 0 and a[i - 1] > a[i]:\n            r[1] += 1\n        while j < n and a[p[j]] == a[p[i]]:\n            add(p[j] + 1, -1, aib, n)\n            j += 1\n        k = 2\n        while k < n and p[i] * k + 1 < n:\n            dr = min(n, p[i] * k + k + 1)\n            st = p[i] * k + 2\n            r[k] += suma(dr, aib) - suma(st - -1, aib)\n            k += 1\n    return r[1:n]"
    }
  ]
}