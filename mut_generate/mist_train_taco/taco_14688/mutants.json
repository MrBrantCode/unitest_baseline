{
  "task_id": "taco_14688",
  "entry_point": "calculate_expected_inversions",
  "mutant_count": 162,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = -1\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (k * k - k) // 2",
      "mutated_line": "return (k * k - k) / 2",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) / 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (k * k - k) // 2",
      "mutated_line": "return (k * k - k) * 2",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) * 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "a = [[0] * n for _ in range(n)]",
      "mutated_line": "a = [[0] / n for _ in range(n)]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] / n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "a = [[0] * n for _ in range(n)]",
      "mutated_line": "a = [[0] + n for _ in range(n)]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] + n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "a = [[0] * n for _ in range(n)]",
      "mutated_line": "a = [[0] ** n for _ in range(n)]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] ** n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 41,
      "original_line": "s += a[i][j]",
      "mutated_line": "s -= a[i][j]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s -= a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (k * k - k) // 2",
      "mutated_line": "return (k * k + k) // 2",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k + k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (k * k - k) // 2",
      "mutated_line": "return k * k * k // 2",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return k * k * k // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (k * k - k) // 2",
      "mutated_line": "return (k * k - k) // 3",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 3\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (k * k - k) // 2",
      "mutated_line": "return (k * k - k) // 1",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 1\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (k * k - k) // 2",
      "mutated_line": "return (k * k - k) // 0",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 0\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (k * k - k) // 2",
      "mutated_line": "return (k * k - k) // 1",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 1\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (k * k - k) // 2",
      "mutated_line": "return (k * k - k) // -2",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // -2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i - 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i * 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if permutation[i] > permutation[j]:",
      "mutated_line": "if permutation[i] >= permutation[j]:",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] >= permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if permutation[i] > permutation[j]:",
      "mutated_line": "if permutation[i] <= permutation[j]:",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] <= permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if permutation[i] > permutation[j]:",
      "mutated_line": "if permutation[i] != permutation[j]:",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] != permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "b = [[0] * n for _ in range(n)]",
      "mutated_line": "b = [[0] / n for _ in range(n)]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] / n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "b = [[0] * n for _ in range(n)]",
      "mutated_line": "b = [[0] + n for _ in range(n)]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] + n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "b = [[0] * n for _ in range(n)]",
      "mutated_line": "b = [[0] ** n for _ in range(n)]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] ** n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i - 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i * 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (k * k - k) // 2",
      "mutated_line": "return (k / k - k) // 2",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k / k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (k * k - k) // 2",
      "mutated_line": "return (k + k - k) // 2",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k + k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (k * k - k) // 2",
      "mutated_line": "return (k ** k - k) // 2",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k ** k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "a = [[0] * n for _ in range(n)]",
      "mutated_line": "a = [[1] * n for _ in range(n)]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "a = [[0] * n for _ in range(n)]",
      "mutated_line": "a = [[-1] * n for _ in range(n)]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "a = [[0] * n for _ in range(n)]",
      "mutated_line": "a = [[1] * n for _ in range(n)]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 2, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 0, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 0, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + -1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "a[i][j] = 1",
      "mutated_line": "a[i][j] = 2",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 2\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "a[i][j] = 1",
      "mutated_line": "a[i][j] = 0",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 0\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "a[i][j] = 1",
      "mutated_line": "a[i][j] = 0",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 0\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "a[i][j] = 1",
      "mutated_line": "a[i][j] = -1",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = -1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[j][i] = 1",
      "mutated_line": "a[j][i] = 2",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 2\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[j][i] = 1",
      "mutated_line": "a[j][i] = 0",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 0\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[j][i] = 1",
      "mutated_line": "a[j][i] = 0",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 0\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[j][i] = 1",
      "mutated_line": "a[j][i] = -1",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = -1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i - 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i * 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p = q = 0",
      "mutated_line": "p = q = 1",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 1\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p = q = 0",
      "mutated_line": "p = q = -1",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = -1\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "p = q = 0",
      "mutated_line": "p = q = 1",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 1\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "p += d * a[x][j]",
      "mutated_line": "p -= d * a[x][j]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p -= d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "q += d",
      "mutated_line": "q -= d",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q -= d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "p += d * a[i][y]",
      "mutated_line": "p -= d * a[i][y]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p -= d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "q += d",
      "mutated_line": "q -= d",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q -= d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "p += d * a[x][y]",
      "mutated_line": "p -= d * a[x][y]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p -= d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "q += d",
      "mutated_line": "q -= d",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q -= d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j - i) + g(i + 1) - g(n - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) - g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = (g(j - i) + g(i + 1)) * g(n - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = (g(j - i) + g(i + 1)) * g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b[i][j] = (p + d * a[i][j]) / (d + q)",
      "mutated_line": "b[i][j] = (p + d * a[i][j]) * (d + q)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) * (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b[i][j] = (p + d * a[i][j]) / (d + q)",
      "mutated_line": "b[i][j] = (p + d * a[i][j]) // (d + q)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) // (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i - 1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i - 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i * 1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i * 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "a[j][i] = 1 - a[i][j]",
      "mutated_line": "a[j][i] = 1 + a[i][j]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 + a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "a[j][i] = 1 - a[i][j]",
      "mutated_line": "a[j][i] = 1 * a[i][j]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 * a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 2, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 0, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 0, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + -1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = [[0] * n for _ in range(n)]",
      "mutated_line": "b = [[1] * n for _ in range(n)]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[1] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = [[0] * n for _ in range(n)]",
      "mutated_line": "b = [[-1] * n for _ in range(n)]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[-1] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "b = [[0] * n for _ in range(n)]",
      "mutated_line": "b = [[1] * n for _ in range(n)]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[1] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 2, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 0, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 0, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + -1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "p += d * a[x][j]",
      "mutated_line": "p += d / a[x][j]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d / a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "p += d * a[x][j]",
      "mutated_line": "p += d + a[x][j]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d + a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "p += d * a[x][j]",
      "mutated_line": "p += d ** a[x][j]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d ** a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for y in range(i + 1, n):",
      "mutated_line": "for y in range(i - 1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i - 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "for y in range(i + 1, n):",
      "mutated_line": "for y in range(i * 1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i * 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "p += d * a[i][y]",
      "mutated_line": "p += d / a[i][y]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d / a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "p += d * a[i][y]",
      "mutated_line": "p += d + a[i][y]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d + a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "p += d * a[i][y]",
      "mutated_line": "p += d ** a[i][y]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d ** a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for s in range(j, i + n):",
      "mutated_line": "for s in range(j, i - n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i - n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for s in range(j, i + n):",
      "mutated_line": "for s in range(j, i * n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i * n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "p += d * a[x][y]",
      "mutated_line": "p += d / a[x][y]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d / a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "p += d * a[x][y]",
      "mutated_line": "p += d + a[x][y]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d + a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "p += d * a[x][y]",
      "mutated_line": "p += d ** a[x][y]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d ** a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j - i) - g(i + 1) + g(n - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) - g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j - i) * g(i + 1) + g(n - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) * g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b[i][j] = (p + d * a[i][j]) / (d + q)",
      "mutated_line": "b[i][j] = (p - d * a[i][j]) / (d + q)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p - d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b[i][j] = (p + d * a[i][j]) / (d + q)",
      "mutated_line": "b[i][j] = p * (d * a[i][j]) / (d + q)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = p * (d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b[i][j] = (p + d * a[i][j]) / (d + q)",
      "mutated_line": "b[i][j] = (p + d * a[i][j]) / (d - q)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d - q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b[i][j] = (p + d * a[i][j]) / (d + q)",
      "mutated_line": "b[i][j] = (p + d * a[i][j]) / (d * q)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d * q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 2, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 2, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 0, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + 0, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 0, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "for j in range(i + 1, n):",
      "mutated_line": "for j in range(i + -1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + -1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a[j][i] = 1 - a[i][j]",
      "mutated_line": "a[j][i] = 2 - a[i][j]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 2 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a[j][i] = 1 - a[i][j]",
      "mutated_line": "a[j][i] = 0 - a[i][j]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 0 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a[j][i] = 1 - a[i][j]",
      "mutated_line": "a[j][i] = 0 - a[i][j]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 0 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "a[j][i] = 1 - a[i][j]",
      "mutated_line": "a[j][i] = -1 - a[i][j]",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = -1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i - 1, j - x, x + 1, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i - 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i * 1, j - x, x + 1, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i * 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 1, j + x, x + 1, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j + x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 1, j * x, x + 1, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j * x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 1, j - x, x - 1, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x - 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 1, j - x, x * 1, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x * 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 1, j - x, x + 1, j + i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j + i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 1, j - x, x + 1, j * i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j * i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for y in range(i + 1, n):",
      "mutated_line": "for y in range(i + 2, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 2, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for y in range(i + 1, n):",
      "mutated_line": "for y in range(i + 0, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 0, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for y in range(i + 1, n):",
      "mutated_line": "for y in range(i + 0, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 0, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "for y in range(i + 1, n):",
      "mutated_line": "for y in range(i + -1, n):",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + -1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "d = min(n - j, y - i, n - y, j - i)",
      "mutated_line": "d = min(n + j, y - i, n - y, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n + j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "d = min(n - j, y - i, n - y, j - i)",
      "mutated_line": "d = min(n * j, y - i, n - y, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n * j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "d = min(n - j, y - i, n - y, j - i)",
      "mutated_line": "d = min(n - j, y + i, n - y, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y + i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "d = min(n - j, y - i, n - y, j - i)",
      "mutated_line": "d = min(n - j, y * i, n - y, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y * i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "d = min(n - j, y - i, n - y, j - i)",
      "mutated_line": "d = min(n - j, y - i, n + y, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n + y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "d = min(n - j, y - i, n - y, j - i)",
      "mutated_line": "d = min(n - j, y - i, n * y, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n * y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "d = min(n - j, y - i, n - y, j - i)",
      "mutated_line": "d = min(n - j, y - i, n - y, j + i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j + i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "d = min(n - j, y - i, n - y, j - i)",
      "mutated_line": "d = min(n - j, y - i, n - y, j * i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j * i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (s - i, s - j)",
      "mutated_line": "(x, y) = (s + i, s - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s + i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (s - i, s - j)",
      "mutated_line": "(x, y) = (s * i, s - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s * i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (s - i, s - j)",
      "mutated_line": "(x, y) = (s - i, s + j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s + j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "(x, y) = (s - i, s - j)",
      "mutated_line": "(x, y) = (s - i, s * j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s * j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i - 1, n - j, y + 1, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i - 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i * 1, n - j, y + 1, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i * 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 1, n + j, y + 1, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n + j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 1, n * j, y + 1, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n * j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 1, n - j, y - 1, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y - 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 1, n - j, y * 1, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y * 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 1, n - j, y + 1, n + x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n + x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 1, n - j, y + 1, n * x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n * x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j - i) + g(i + 1) + g(n + j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n + j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j - i) + g(i + 1) + g(n * j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n * j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b[i][j] = (p + d * a[i][j]) / (d + q)",
      "mutated_line": "b[i][j] = (p + d / a[i][j]) / (d + q)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d / a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b[i][j] = (p + d * a[i][j]) / (d + q)",
      "mutated_line": "b[i][j] = (p + (d + a[i][j])) / (d + q)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + (d + a[i][j])) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "b[i][j] = (p + d * a[i][j]) / (d + q)",
      "mutated_line": "b[i][j] = (p + d ** a[i][j]) / (d + q)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d ** a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 2, j - x, x + 1, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 2, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 0, j - x, x + 1, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 0, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 0, j - x, x + 1, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 0, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + -1, j - x, x + 1, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + -1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 1, j - x, x + 2, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 2, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 1, j - x, x + 0, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 0, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 1, j - x, x + 0, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 0, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "d = min(i + 1, j - x, x + 1, j - i)",
      "mutated_line": "d = min(i + 1, j - x, x + -1, j - i)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + -1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 2, n - j, y + 1, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 2, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 0, n - j, y + 1, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 0, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 0, n - j, y + 1, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 0, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + -1, n - j, y + 1, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + -1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 1, n - j, y + 2, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 2, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 1, n - j, y + 0, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 0, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 1, n - j, y + 0, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 0, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "d = min(i + 1, n - j, y + 1, n - x)",
      "mutated_line": "d = min(i + 1, n - j, y + -1, n - x)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + -1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j + i) + g(i + 1) + g(n - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j + i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j * i) + g(i + 1) + g(n - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j * i) + g(i + 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j - i) + g(i - 1) + g(n - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i - 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j - i) + g(i * 1) + g(n - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i * 1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j - i) + g(i + 2) + g(n - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 2) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j - i) + g(i + 0) + g(n - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 0) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j - i) + g(i + 0) + g(n - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + 0) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "d = g(j - i) + g(i + 1) + g(n - j)",
      "mutated_line": "d = g(j - i) + g(i + -1) + g(n - j)",
      "code": "def calculate_expected_inversions(n, k, permutation):\n\n    def g(k):\n        return (k * k - k) // 2\n    a = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if permutation[i] > permutation[j]:\n                a[i][j] = 1\n            else:\n                a[j][i] = 1\n    for _ in range(k):\n        b = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                p = q = 0\n                for x in range(j):\n                    d = min(i + 1, j - x, x + 1, j - i)\n                    p += d * a[x][j]\n                    q += d\n                for y in range(i + 1, n):\n                    d = min(n - j, y - i, n - y, j - i)\n                    p += d * a[i][y]\n                    q += d\n                for s in range(j, i + n):\n                    (x, y) = (s - i, s - j)\n                    d = min(i + 1, n - j, y + 1, n - x)\n                    p += d * a[x][y]\n                    q += d\n                d = g(j - i) + g(i + -1) + g(n - j)\n                b[i][j] = (p + d * a[i][j]) / (d + q)\n        a = b\n        for i in range(n):\n            for j in range(i + 1, n):\n                a[j][i] = 1 - a[i][j]\n    s = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            s += a[i][j]\n    return s"
    }
  ]
}