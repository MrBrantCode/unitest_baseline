{
  "task_id": "taco_4183",
  "entry_point": "solve_code_lock",
  "mutant_count": 94,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if scount != tcount:",
      "mutated_line": "if scount == tcount:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount == tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if k == 0:",
      "mutated_line": "if k != 0:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k != 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k - 1:-1] - cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] - cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k - 1:-1] * cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] * cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if k == n - 1:",
      "mutated_line": "if k != n - 1:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k != n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 1\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return -1\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 1\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return +1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 1:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if k == 0:",
      "mutated_line": "if k == -1:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == -1:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if k == 0:",
      "mutated_line": "if k == 1:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 1:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if k == n - 1:",
      "mutated_line": "if k == n + 1:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n + 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "if k == n - 1:",
      "mutated_line": "if k == n * 1:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n * 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "curst = curst[-1] + curst[:-1]",
      "mutated_line": "curst = curst[-1] - curst[:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] - curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "curst = curst[-1] + curst[:-1]",
      "mutated_line": "curst = curst[-1] * curst[:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] * curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] + curst[:k] - curst[-1:k:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] - curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = (curst[k] + curst[:k]) * curst[-1:k:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = (curst[k] + curst[:k]) * curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if cur_c == char:",
      "mutated_line": "if cur_c != char:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c != char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -2\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -0\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -0\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return --1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "for char in s[::-1]:",
      "mutated_line": "for char in s[::+1]:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::+1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if k == n - 1:",
      "mutated_line": "if k == n - 2:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 2:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if k == n - 1:",
      "mutated_line": "if k == n - 0:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 0:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if k == n - 1:",
      "mutated_line": "if k == n - 0:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 0:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "if k == n - 1:",
      "mutated_line": "if k == n - -1:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - -1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ops.append(1)",
      "mutated_line": "ops.append(2)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(2)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ops.append(1)",
      "mutated_line": "ops.append(0)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(0)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ops.append(1)",
      "mutated_line": "ops.append(0)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(0)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ops.append(1)",
      "mutated_line": "ops.append(-1)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(-1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ops.append(n - 1)",
      "mutated_line": "ops.append(n + 1)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n + 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "ops.append(n - 1)",
      "mutated_line": "ops.append(n * 1)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n * 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ops.append(1)",
      "mutated_line": "ops.append(2)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(2)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ops.append(1)",
      "mutated_line": "ops.append(0)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(0)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ops.append(1)",
      "mutated_line": "ops.append(0)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(0)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "ops.append(1)",
      "mutated_line": "ops.append(-1)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(-1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] - curst[:k] + curst[-1:k:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] - curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] * curst[:k] + curst[-1:k:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] * curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return n - m - 1",
      "mutated_line": "return n - m + 1",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m + 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return n - m - 1",
      "mutated_line": "return (n - m) * 1",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return (n - m) * 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for char in s[::-1]:",
      "mutated_line": "for char in s[::-2]:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-2]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for char in s[::-1]:",
      "mutated_line": "for char in s[::-0]:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-0]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for char in s[::-1]:",
      "mutated_line": "for char in s[::-0]:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-0]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for char in s[::-1]:",
      "mutated_line": "for char in s[::--1]:",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::--1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k + 1:-1] + cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k + 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k * 1:-1] + cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k * 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k - 1:+1] + cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:+1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k - 1:-1] + cur[:+k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:+k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "curst = curst[-1] + curst[:-1]",
      "mutated_line": "curst = curst[+1] + curst[:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[+1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ops.append(n - 1)",
      "mutated_line": "ops.append(n - 2)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 2)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ops.append(n - 1)",
      "mutated_line": "ops.append(n - 0)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 0)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ops.append(n - 1)",
      "mutated_line": "ops.append(n - 0)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 0)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "ops.append(n - 1)",
      "mutated_line": "ops.append(n - -1)",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - -1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "for (m, cur_c) in enumerate(t[::-1]):",
      "mutated_line": "for (m, cur_c) in enumerate(t[::+1]):",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::+1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return n - m - 1",
      "mutated_line": "return n + m - 1",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n + m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return n - m - 1",
      "mutated_line": "return n * m - 1",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n * m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return n - m - 1",
      "mutated_line": "return n - m - 2",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 2\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return n - m - 1",
      "mutated_line": "return n - m - 0",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 0\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return n - m - 1",
      "mutated_line": "return n - m - 0",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 0\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return n - m - 1",
      "mutated_line": "return n - m - -1",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - -1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:+k - 1:-1] + cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:+k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k - 2:-1] + cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 2:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k - 0:-1] + cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 0:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k - 0:-1] + cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 0:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k - -1:-1] + cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - -1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k - 1:-2] + cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-2] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k - 1:-0] + cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-0] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k - 1:-0] + cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-0] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return cur[:-k - 1:-1] + cur[:-k]",
      "mutated_line": "return cur[:-k - 1:--1] + cur[:-k]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:--1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "curst = curst[-1] + curst[:-1]",
      "mutated_line": "curst = curst[-2] + curst[:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-2] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "curst = curst[-1] + curst[:-1]",
      "mutated_line": "curst = curst[-0] + curst[:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-0] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "curst = curst[-1] + curst[:-1]",
      "mutated_line": "curst = curst[-0] + curst[:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-0] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "curst = curst[-1] + curst[:-1]",
      "mutated_line": "curst = curst[--1] + curst[:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[--1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "curst = curst[-1] + curst[:-1]",
      "mutated_line": "curst = curst[-1] + curst[:+1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:+1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] + curst[:k] + curst[+1:k:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[+1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] + curst[:k] + curst[-1:k:+1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:+1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (m, cur_c) in enumerate(t[::-1]):",
      "mutated_line": "for (m, cur_c) in enumerate(t[::-2]):",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-2]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (m, cur_c) in enumerate(t[::-1]):",
      "mutated_line": "for (m, cur_c) in enumerate(t[::-0]):",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-0]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (m, cur_c) in enumerate(t[::-1]):",
      "mutated_line": "for (m, cur_c) in enumerate(t[::-0]):",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-0]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for (m, cur_c) in enumerate(t[::-1]):",
      "mutated_line": "for (m, cur_c) in enumerate(t[::--1]):",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::--1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "curst = curst[-1] + curst[:-1]",
      "mutated_line": "curst = curst[-1] + curst[:-2]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-2]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "curst = curst[-1] + curst[:-1]",
      "mutated_line": "curst = curst[-1] + curst[:-0]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-0]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "curst = curst[-1] + curst[:-1]",
      "mutated_line": "curst = curst[-1] + curst[:-0]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-0]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "curst = curst[-1] + curst[:-1]",
      "mutated_line": "curst = curst[-1] + curst[:--1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:--1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] + curst[:k] + curst[-2:k:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-2:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] + curst[:k] + curst[-0:k:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-0:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] + curst[:k] + curst[-0:k:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-0:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] + curst[:k] + curst[--1:k:-1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[--1:k:-1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] + curst[:k] + curst[-1:k:-2]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-2]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] + curst[:k] + curst[-1:k:-0]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-0]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] + curst[:k] + curst[-1:k:-0]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:-0]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "curst = curst[k] + curst[:k] + curst[-1:k:-1]",
      "mutated_line": "curst = curst[k] + curst[:k] + curst[-1:k:--1]",
      "code": "def solve_code_lock(n, s, t):\n    ops = []\n\n    def shift(k, cur):\n        if k == 0:\n            return cur\n        return cur[:-k - 1:-1] + cur[:-k]\n\n    def move_to_front(k, curst):\n        if k == n - 1:\n            ops.append(1)\n            curst = curst[-1] + curst[:-1]\n        else:\n            ops.append(n - 1)\n            ops.append(k)\n            ops.append(1)\n            curst = curst[k] + curst[:k] + curst[-1:k:--1]\n        return curst\n\n    def find_char(char, t):\n        for (m, cur_c) in enumerate(t[::-1]):\n            if cur_c == char:\n                return n - m - 1\n        return 0\n    from collections import Counter\n    scount = Counter(s)\n    tcount = Counter(t)\n    ori_t = t\n    if scount != tcount:\n        return -1\n    for char in s[::-1]:\n        t = move_to_front(find_char(char, t), t)\n    return (len(ops), ops)"
    }
  ]
}