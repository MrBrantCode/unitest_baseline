{
  "task_id": "taco_4753",
  "entry_point": "min_flips_to_zero_matrix",
  "mutant_count": 96,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return +1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if current == 0:",
      "mutated_line": "if current != 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current != 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = len(mat[0])",
      "mutated_line": "n = len(mat[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[1])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = len(mat[0])",
      "mutated_line": "n = len(mat[-1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[-1])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "n = len(mat[0])",
      "mutated_line": "n = len(mat[1])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[1])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[1, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[1, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[-1, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[-1, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[1, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[1, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 1], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 1], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, -1], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, -1], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 1], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 1], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [1, 1], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [1, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [-1, 1], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [-1, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [1, 1], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [1, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 2], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 2], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 0], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 0], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 0], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 0], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, -1], [1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, -1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [2, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [2, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [0, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [0, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [0, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [0, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [-1, 0], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [-1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 1], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 1], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, -1], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, -1], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 1], [0, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 1], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [1, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [1, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [-1, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [-1, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [1, -1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [1, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, +1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, +1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [+1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [+1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 1]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 1]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, -1]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, -1]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 1]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 1]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if current == 0:",
      "mutated_line": "if current == 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 1:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if current == 0:",
      "mutated_line": "if current == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == -1:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if current == 0:",
      "mutated_line": "if current == 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 1:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))",
      "mutated_line": "start = sum((val << i * n - j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n - j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))",
      "mutated_line": "start = sum((val << i * n * j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n * j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "queue = deque([(start, 0)])",
      "mutated_line": "queue = deque([(start, 1)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 1)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "queue = deque([(start, 0)])",
      "mutated_line": "queue = deque([(start, -1)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, -1)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "queue = deque([(start, 0)])",
      "mutated_line": "queue = deque([(start, 1)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 1)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -2], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -2], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -0], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -0], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -0], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -0], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, --1], [-1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, --1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-2, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-2, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-0, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-0, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-0, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-0, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]",
      "mutated_line": "dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [--1, 0]]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [--1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if next_state not in seen:",
      "mutated_line": "if next_state in seen:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))",
      "mutated_line": "start = sum((val << i / n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i / n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))",
      "mutated_line": "start = sum((val << i + n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i + n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))",
      "mutated_line": "start = sum((val << i ** n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i ** n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "new_i = i + dir_[0]",
      "mutated_line": "new_i = i - dir_[0]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i - dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "new_i = i + dir_[0]",
      "mutated_line": "new_i = i * dir_[0]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i * dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "new_j = j + dir_[1]",
      "mutated_line": "new_j = j - dir_[1]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j - dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "new_j = j + dir_[1]",
      "mutated_line": "new_j = j * dir_[1]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j * dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if 0 <= new_i < m or 0 <= new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m or 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if 0 < new_i < m and 0 <= new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 < new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if 0 > new_i < m and 0 <= new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 > new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if 0 == new_i < m and 0 <= new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 == new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if 0 <= new_i < m and 0 < new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 < new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if 0 <= new_i < m and 0 > new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 > new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if 0 <= new_i < m and 0 == new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 == new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "new_i = i + dir_[0]",
      "mutated_line": "new_i = i + dir_[1]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[1]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "new_i = i + dir_[0]",
      "mutated_line": "new_i = i + dir_[-1]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[-1]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "new_i = i + dir_[0]",
      "mutated_line": "new_i = i + dir_[1]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[1]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "new_j = j + dir_[1]",
      "mutated_line": "new_j = j + dir_[2]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[2]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "new_j = j + dir_[1]",
      "mutated_line": "new_j = j + dir_[0]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[0]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "new_j = j + dir_[1]",
      "mutated_line": "new_j = j + dir_[0]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[0]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "new_j = j + dir_[1]",
      "mutated_line": "new_j = j + dir_[-1]",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[-1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if 1 <= new_i < m and 0 <= new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 1 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if -1 <= new_i < m and 0 <= new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if -1 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if 1 <= new_i < m and 0 <= new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 1 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if 0 <= new_i < m and 1 <= new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 1 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if 0 <= new_i < m and -1 <= new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and -1 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "if 0 <= new_i < m and 0 <= new_j < n:",
      "mutated_line": "if 0 <= new_i < m and 1 <= new_j < n:",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 1 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "next_state ^= 1 << new_i * n + new_j",
      "mutated_line": "next_state ^= 2 << new_i * n + new_j",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 2 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "next_state ^= 1 << new_i * n + new_j",
      "mutated_line": "next_state ^= 0 << new_i * n + new_j",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 0 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "next_state ^= 1 << new_i * n + new_j",
      "mutated_line": "next_state ^= 0 << new_i * n + new_j",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 0 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "next_state ^= 1 << new_i * n + new_j",
      "mutated_line": "next_state ^= -1 << new_i * n + new_j",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= -1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "next_state ^= 1 << new_i * n + new_j",
      "mutated_line": "next_state ^= 1 << new_i * n - new_j",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n - new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "next_state ^= 1 << new_i * n + new_j",
      "mutated_line": "next_state ^= 1 << new_i * n * new_j",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n * new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "queue.append((next_state, d + 1))",
      "mutated_line": "queue.append((next_state, d - 1))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d - 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "queue.append((next_state, d + 1))",
      "mutated_line": "queue.append((next_state, d * 1))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d * 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "next_state ^= 1 << new_i * n + new_j",
      "mutated_line": "next_state ^= 1 << new_i / n + new_j",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i / n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "next_state ^= 1 << new_i * n + new_j",
      "mutated_line": "next_state ^= 1 << new_i + n + new_j",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i + n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "next_state ^= 1 << new_i * n + new_j",
      "mutated_line": "next_state ^= 1 << new_i ** n + new_j",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i ** n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 1))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue.append((next_state, d + 1))",
      "mutated_line": "queue.append((next_state, d + 2))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 2))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue.append((next_state, d + 1))",
      "mutated_line": "queue.append((next_state, d + 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 0))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue.append((next_state, d + 1))",
      "mutated_line": "queue.append((next_state, d + 0))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + 0))\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "queue.append((next_state, d + 1))",
      "mutated_line": "queue.append((next_state, d + -1))",
      "code": "from collections import deque\nfrom typing import List\n\ndef min_flips_to_zero_matrix(mat: List[List[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    start = sum((val << i * n + j for (i, row) in enumerate(mat) for (j, val) in enumerate(row)))\n    queue = deque([(start, 0)])\n    seen = {start}\n    dirs = [[0, 0], [0, 1], [1, 0], [0, -1], [-1, 0]]\n    while queue:\n        (current, d) = queue.popleft()\n        if current == 0:\n            return d\n        for i in range(m):\n            for j in range(n):\n                next_state = current\n                for dir_ in dirs:\n                    new_i = i + dir_[0]\n                    new_j = j + dir_[1]\n                    if 0 <= new_i < m and 0 <= new_j < n:\n                        next_state ^= 1 << new_i * n + new_j\n                if next_state not in seen:\n                    seen.add(next_state)\n                    queue.append((next_state, d + -1))\n    return -1"
    }
  ]
}