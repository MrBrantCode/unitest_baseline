{
  "task_id": "taco_15901",
  "entry_point": "check_queries_on_tree",
  "mutant_count": 87,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "parent = [0] * n",
      "mutated_line": "parent = [0] / n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] / n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "parent = [0] * n",
      "mutated_line": "parent = [0] + n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] + n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "parent = [0] * n",
      "mutated_line": "parent = [0] ** n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] ** n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tin = [0] * n",
      "mutated_line": "tin = [0] / n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] / n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tin = [0] * n",
      "mutated_line": "tin = [0] + n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] + n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "tin = [0] * n",
      "mutated_line": "tin = [0] ** n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] ** n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "tout = [0] * n",
      "mutated_line": "tout = [0] / n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] / n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "tout = [0] * n",
      "mutated_line": "tout = [0] + n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] + n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "tout = [0] * n",
      "mutated_line": "tout = [0] ** n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] ** n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "time = 0",
      "mutated_line": "time = 1",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 1\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "time = 0",
      "mutated_line": "time = -1",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = -1\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "time = 0",
      "mutated_line": "time = 1",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 1\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if visit == 0:",
      "mutated_line": "if visit != 0:",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit != 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "time += 1",
      "mutated_line": "time -= 1",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time -= 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cin = 1",
      "mutated_line": "cin = 2",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 2\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cin = 1",
      "mutated_line": "cin = 0",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 0\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cin = 1",
      "mutated_line": "cin = 0",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 0\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "cin = 1",
      "mutated_line": "cin = -1",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = -1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if cin > cout:",
      "mutated_line": "if cin >= cout:",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin >= cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if cin > cout:",
      "mutated_line": "if cin <= cout:",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin <= cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if cin > cout:",
      "mutated_line": "if cin != cout:",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin != cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 1].append(v + 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v + 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 1].append(v * 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v * 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 1].append(u + 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u + 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 1].append(u * 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u * 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "parent = [0] * n",
      "mutated_line": "parent = [1] * n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [1] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "parent = [0] * n",
      "mutated_line": "parent = [-1] * n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [-1] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "parent = [0] * n",
      "mutated_line": "parent = [1] * n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [1] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tin = [0] * n",
      "mutated_line": "tin = [1] * n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [1] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tin = [0] * n",
      "mutated_line": "tin = [-1] * n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [-1] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "tin = [0] * n",
      "mutated_line": "tin = [1] * n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [1] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tout = [0] * n",
      "mutated_line": "tout = [1] * n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [1] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tout = [0] * n",
      "mutated_line": "tout = [-1] * n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [-1] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "tout = [0] * n",
      "mutated_line": "tout = [1] * n",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [1] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(1, 0)]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(1, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(-1, 0)]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(-1, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(1, 0)]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(1, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(0, 1)]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 1)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(0, -1)]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, -1)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue = [(0, 0)]",
      "mutated_line": "queue = [(0, 1)]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 1)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if visit == 0:",
      "mutated_line": "if visit == 1:",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 1:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if visit == 0:",
      "mutated_line": "if visit == -1:",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == -1:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if visit == 0:",
      "mutated_line": "if visit == 1:",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 1:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "time += 1",
      "mutated_line": "time += 2",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 2\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "time += 1",
      "mutated_line": "time += 0",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 0\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "time += 1",
      "mutated_line": "time += 0",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 0\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "time += 1",
      "mutated_line": "time += -1",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += -1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "q = [vertex - 1 for vertex in query[1:]]",
      "mutated_line": "q = [vertex + 1 for vertex in query[1:]]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex + 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "q = [vertex - 1 for vertex in query[1:]]",
      "mutated_line": "q = [vertex * 1 for vertex in query[1:]]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex * 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 1].append(v - 2)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 2)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 1].append(v - 0)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 0)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 1].append(v - 0)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 0)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 1].append(v - -1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - -1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 1].append(u - 2)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 2)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 1].append(u - 0)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 0)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 1].append(u - 0)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 0)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 1].append(u - -1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - -1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if child != parent[current]:",
      "mutated_line": "if child == parent[current]:",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child == parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q = [vertex - 1 for vertex in query[1:]]",
      "mutated_line": "q = [vertex - 2 for vertex in query[1:]]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 2 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q = [vertex - 1 for vertex in query[1:]]",
      "mutated_line": "q = [vertex - 0 for vertex in query[1:]]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 0 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q = [vertex - 1 for vertex in query[1:]]",
      "mutated_line": "q = [vertex - 0 for vertex in query[1:]]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 0 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q = [vertex - 1 for vertex in query[1:]]",
      "mutated_line": "q = [vertex - -1 for vertex in query[1:]]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - -1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "results.append(\"NO\")",
      "mutated_line": "results.append('')",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(\"YES\")",
      "mutated_line": "results.append('')",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u + 1].append(v - 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u + 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u * 1].append(v - 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u * 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v + 1].append(u - 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v + 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v * 1].append(u - 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v * 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append((current, 1))",
      "mutated_line": "queue.append((current, 2))",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 2))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append((current, 1))",
      "mutated_line": "queue.append((current, 0))",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 0))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append((current, 1))",
      "mutated_line": "queue.append((current, 0))",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 0))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append((current, 1))",
      "mutated_line": "queue.append((current, -1))",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, -1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 2].append(v - 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 2].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 0].append(v - 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 0].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - 0].append(v - 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 0].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "graph[u - 1].append(v - 1)",
      "mutated_line": "graph[u - -1].append(v - 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - -1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 2].append(u - 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 2].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 0].append(u - 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 0].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - 0].append(u - 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 0].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "graph[v - 1].append(u - 1)",
      "mutated_line": "graph[v - -1].append(u - 1)",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - -1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q = [vertex - 1 for vertex in query[1:]]",
      "mutated_line": "q = [vertex - 1 for vertex in query[2:]]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[2:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q = [vertex - 1 for vertex in query[1:]]",
      "mutated_line": "q = [vertex - 1 for vertex in query[0:]]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[0:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q = [vertex - 1 for vertex in query[1:]]",
      "mutated_line": "q = [vertex - 1 for vertex in query[0:]]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[0:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "q = [vertex - 1 for vertex in query[1:]]",
      "mutated_line": "q = [vertex - 1 for vertex in query[-1:]]",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 0))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[-1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "queue.append((child, 0))",
      "mutated_line": "queue.append((child, 1))",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 1))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "queue.append((child, 0))",
      "mutated_line": "queue.append((child, -1))",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, -1))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "queue.append((child, 0))",
      "mutated_line": "queue.append((child, 1))",
      "code": "def check_queries_on_tree(n, m, edges, queries):\n    graph = [[] for _ in range(n)]\n    for (u, v) in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    parent = [0] * n\n    tin = [0] * n\n    tout = [0] * n\n    time = 0\n    queue = [(0, 0)]\n    while queue:\n        (current, visit) = queue.pop()\n        if visit == 0:\n            queue.append((current, 1))\n            time += 1\n            tin[current] = time\n            for child in graph[current]:\n                if child != parent[current]:\n                    parent[child] = current\n                    queue.append((child, 1))\n        else:\n            tout[current] = time\n    results = []\n    for query in queries:\n        q = [vertex - 1 for vertex in query[1:]]\n        cin = 1\n        cout = n\n        for i in q:\n            cin = max(cin, tin[parent[i]])\n            cout = min(cout, tout[parent[i]])\n        if cin > cout:\n            results.append('NO')\n        else:\n            results.append('YES')\n    return results"
    }
  ]
}