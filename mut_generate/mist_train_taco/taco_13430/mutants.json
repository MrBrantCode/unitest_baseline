{
  "task_id": "taco_13430",
  "entry_point": "find_optimal_schedule",
  "mutant_count": 94,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [-1] / (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] / (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [-1] + (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] + (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [-1] ** (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] ** (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "s[n] = 1",
      "mutated_line": "s[n] = 2",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 2\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "s[n] = 1",
      "mutated_line": "s[n] = 0",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 0\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "s[n] = 1",
      "mutated_line": "s[n] = 0",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 0\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "s[n] = 1",
      "mutated_line": "s[n] = -1",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = -1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] / (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] / (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] + (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] + (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] ** (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] ** (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if n != 1:",
      "mutated_line": "if n == 1:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n == 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [-1] * (n - 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n - 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [-1] * (n * 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n * 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n - 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n - 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n * 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n * 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "R = dist[1]",
      "mutated_line": "R = dist[2]",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[2]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "R = dist[1]",
      "mutated_line": "R = dist[0]",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[0]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "R = dist[1]",
      "mutated_line": "R = dist[0]",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[0]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "R = dist[1]",
      "mutated_line": "R = dist[-1]",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[-1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n != 1:",
      "mutated_line": "if n != 2:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 2:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n != 1:",
      "mutated_line": "if n != 0:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 0:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n != 1:",
      "mutated_line": "if n != 0:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 0:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "if n != 1:",
      "mutated_line": "if n != -1:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != -1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "path_length = 0",
      "mutated_line": "path_length = 1",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 1\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "path_length = 0",
      "mutated_line": "path_length = -1",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = -1\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "path_length = 0",
      "mutated_line": "path_length = 1",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 1\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "schedule = '1'",
      "mutated_line": "schedule = ''",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = ''\n    return (path_length, schedule)"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [+1] * (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [+1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [-1] * (n + 2)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 2)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [-1] * (n + 0)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 0)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [-1] * (n + 0)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 0)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [-1] * (n + -1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + -1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [1] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [-1] * (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [-1] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [1] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 2)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 2)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 0)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 0)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + -1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + -1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if u in vs:",
      "mutated_line": "if u not in vs:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u not in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if s[u] == -1:",
      "mutated_line": "if s[u] != -1:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] != -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if s[u] != t:",
      "mutated_line": "if s[u] == t:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] == t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist[u] = dist[v] + 1",
      "mutated_line": "dist[u] = dist[v] - 1",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] - 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "dist[u] = dist[v] + 1",
      "mutated_line": "dist[u] = dist[v] * 1",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] * 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "UOI",
      "lineno": 32,
      "original_line": "path_length = R if R else -1",
      "mutated_line": "path_length = R if R else +1",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else +1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n - 1):",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n - 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n * 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if s[i] == -1:",
      "mutated_line": "if s[i] != -1:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] != -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "d = [set() for _ in range(n + 1)]",
      "mutated_line": "d = [set() for _ in range(n - 1)]",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n - 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "d = [set() for _ in range(n + 1)]",
      "mutated_line": "d = [set() for _ in range(n * 1)]",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n * 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [-2] * (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-2] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [-0] * (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-0] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [-0] * (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-0] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "s = [-1] * (n + 1)",
      "mutated_line": "s = [--1] * (n + 1)",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [--1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "UOI",
      "lineno": 21,
      "original_line": "if s[u] == -1:",
      "mutated_line": "if s[u] == +1:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == +1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s[u] = 1 - t",
      "mutated_line": "s[u] = 1 + t",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 + t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "s[u] = 1 - t",
      "mutated_line": "s[u] = 1 * t",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 * t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[u] = dist[v] + 1",
      "mutated_line": "dist[u] = dist[v] + 2",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 2\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[u] = dist[v] + 1",
      "mutated_line": "dist[u] = dist[v] + 0",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 0\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[u] = dist[v] + 1",
      "mutated_line": "dist[u] = dist[v] + 0",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 0\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "dist[u] = dist[v] + 1",
      "mutated_line": "dist[u] = dist[v] + -1",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + -1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path_length = R if R else -1",
      "mutated_line": "path_length = R if R else -2",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -2\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path_length = R if R else -1",
      "mutated_line": "path_length = R if R else -0",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -0\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path_length = R if R else -1",
      "mutated_line": "path_length = R if R else -0",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -0\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path_length = R if R else -1",
      "mutated_line": "path_length = R if R else --1",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else --1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 2):",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 2):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 0):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 0):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + -1):",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + -1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "if s[i] == -1:",
      "mutated_line": "if s[i] == +1:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == +1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s[i] = 0",
      "mutated_line": "s[i] = 1",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 1\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s[i] = 0",
      "mutated_line": "s[i] = -1",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = -1\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "s[i] = 0",
      "mutated_line": "s[i] = 1",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 1\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "schedule = ''.join((str(c) for c in s[1:]))",
      "mutated_line": "schedule = 'MUTATED'.join((str(c) for c in s[1:]))",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = 'MUTATED'.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [set() for _ in range(n + 1)]",
      "mutated_line": "d = [set() for _ in range(n + 2)]",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 2)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [set() for _ in range(n + 1)]",
      "mutated_line": "d = [set() for _ in range(n + 0)]",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 0)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [set() for _ in range(n + 1)]",
      "mutated_line": "d = [set() for _ in range(n + 0)]",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 0)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "d = [set() for _ in range(n + 1)]",
      "mutated_line": "d = [set() for _ in range(n + -1)]",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + -1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if s[u] == -1:",
      "mutated_line": "if s[u] == -2:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -2:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if s[u] == -1:",
      "mutated_line": "if s[u] == -0:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -0:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if s[u] == -1:",
      "mutated_line": "if s[u] == -0:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -0:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if s[u] == -1:",
      "mutated_line": "if s[u] == --1:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == --1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s[u] = 1 - t",
      "mutated_line": "s[u] = 2 - t",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 2 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s[u] = 1 - t",
      "mutated_line": "s[u] = 0 - t",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 0 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s[u] = 1 - t",
      "mutated_line": "s[u] = 0 - t",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 0 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "s[u] = 1 - t",
      "mutated_line": "s[u] = -1 - t",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = -1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if s[i] == -1:",
      "mutated_line": "if s[i] == -2:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -2:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if s[i] == -1:",
      "mutated_line": "if s[i] == -0:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -0:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if s[i] == -1:",
      "mutated_line": "if s[i] == -0:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -0:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if s[i] == -1:",
      "mutated_line": "if s[i] == --1:",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == --1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "schedule = ''.join((str(c) for c in s[1:]))",
      "mutated_line": "schedule = ''.join((str(c) for c in s[2:]))",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[2:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "schedule = ''.join((str(c) for c in s[1:]))",
      "mutated_line": "schedule = ''.join((str(c) for c in s[0:]))",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[0:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "schedule = ''.join((str(c) for c in s[1:]))",
      "mutated_line": "schedule = ''.join((str(c) for c in s[0:]))",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[0:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "schedule = ''.join((str(c) for c in s[1:]))",
      "mutated_line": "schedule = ''.join((str(c) for c in s[-1:]))",
      "code": "from collections import deque\n\ndef find_optimal_schedule(n, m, roads):\n    d = [set() for _ in range(n + 1)]\n    for (u, v, t) in roads:\n        d[v].add((u, t))\n    s = [-1] * (n + 1)\n    s[n] = 1\n    queue = deque([n])\n    vs = set([n])\n    dist = [0] * (n + 1)\n    while queue:\n        v = queue.popleft()\n        for (u, t) in d[v]:\n            if u in vs:\n                continue\n            if s[u] == -1:\n                s[u] = 1 - t\n                continue\n            if s[u] != t:\n                continue\n            vs.add(u)\n            queue.append(u)\n            dist[u] = dist[v] + 1\n    R = dist[1]\n    if n != 1:\n        path_length = R if R else -1\n        for i in range(n + 1):\n            if s[i] == -1:\n                s[i] = 0\n        schedule = ''.join((str(c) for c in s[-1:]))\n    else:\n        path_length = 0\n        schedule = '1'\n    return (path_length, schedule)"
    }
  ]
}