{
  "task_id": "taco_2469",
  "entry_point": "generate_string_mutations",
  "mutant_count": 14,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\"\"\"\n    return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) - '\\n'",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) - '\\n'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) * '\\n'",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) * '\\n'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + ''",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + ''"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return '\\n'.join([stringOne] - [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return '\\n'.join([stringOne] - [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return '\\n'.join([stringOne] * [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return '\\n'.join([stringOne] * [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return ''.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return ''.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return '\\n'.join([stringOne] + [stringTwo[:i] - stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return '\\n'.join([stringOne] + [stringTwo[:i] - stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return '\\n'.join([stringOne] + [stringTwo[:i] * stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return '\\n'.join([stringOne] + [stringTwo[:i] * stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a == b]) + '\\n'",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a == b]) + '\\n'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 2) if a != b]) + '\\n'",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 2) if a != b]) + '\\n'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 0) if a != b]) + '\\n'",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 0) if a != b]) + '\\n'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 0) if a != b]) + '\\n'",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 0) if a != b]) + '\\n'"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), 1) if a != b]) + '\\n'",
      "mutated_line": "return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), -1) if a != b]) + '\\n'",
      "code": "def generate_string_mutations(stringOne, stringTwo):\n    \"\"\"\n    Generates a sequence of string mutations transforming stringOne into stringTwo one letter at a time.\n\n    Parameters:\n    stringOne (str): The initial string.\n    stringTwo (str): The target string.\n\n    Returns:\n    str: A string containing all intermediate transformations, each on a new line.\n    \"\"\"\n    return '\\n'.join([stringOne] + [stringTwo[:i] + stringOne[i:] for (i, (a, b)) in enumerate(zip(stringOne, stringTwo), -1) if a != b]) + '\\n'"
    }
  ]
}