{
  "task_id": "taco_14086",
  "entry_point": "calculate_min_typing_time",
  "mutant_count": 56,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ROOT = 0",
      "mutated_line": "ROOT = 1",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 1\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ROOT = 0",
      "mutated_line": "ROOT = -1",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = -1\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "ROOT = 0",
      "mutated_line": "ROOT = 1",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 1\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "offset = 0",
      "mutated_line": "offset = 1",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 1\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "offset = 0",
      "mutated_line": "offset = -1",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = -1\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "offset = 0",
      "mutated_line": "offset = 1",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 1\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i, (p, c) in enumerate(pc, 1):",
      "mutated_line": "for (i, (p, c)) in enumerate(pc, 2):",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 2):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i, (p, c) in enumerate(pc, 1):",
      "mutated_line": "for (i, (p, c)) in enumerate(pc, 0):",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 0):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i, (p, c) in enumerate(pc, 1):",
      "mutated_line": "for (i, (p, c)) in enumerate(pc, 0):",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 0):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i, (p, c) in enumerate(pc, 1):",
      "mutated_line": "for (i, (p, c)) in enumerate(pc, -1):",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, -1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "assert i not in trie",
      "mutated_line": "assert i in trie",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if nodeId != 0:",
      "mutated_line": "if nodeId == 0:",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId == 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if nodeId != 0:",
      "mutated_line": "if nodeId != 1:",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 1:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if nodeId != 0:",
      "mutated_line": "if nodeId != -1:",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != -1:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if nodeId != 0:",
      "mutated_line": "if nodeId != 1:",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 1:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "assert nodeId in parent",
      "mutated_line": "assert nodeId not in parent",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId not in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "best = 1 + dist[parent[nodeId]]",
      "mutated_line": "best = 1 - dist[parent[nodeId]]",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 - dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "best = 1 + dist[parent[nodeId]]",
      "mutated_line": "best = 1 * dist[parent[nodeId]]",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 * dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if nodeId in terminal:",
      "mutated_line": "if nodeId not in terminal:",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId not in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if nodeId in terminal:",
      "mutated_line": "if nodeId not in terminal:",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId not in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "offset += 1",
      "mutated_line": "offset -= 1",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset -= 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "best = 0",
      "mutated_line": "best = 1",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 1\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "best = 0",
      "mutated_line": "best = -1",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = -1\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "best = 0",
      "mutated_line": "best = 1",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 1\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if nodeId not in seen:",
      "mutated_line": "if nodeId in seen:",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "best = 1 + dist[parent[nodeId]]",
      "mutated_line": "best = 2 + dist[parent[nodeId]]",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 2 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "best = 1 + dist[parent[nodeId]]",
      "mutated_line": "best = 0 + dist[parent[nodeId]]",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 0 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "best = 1 + dist[parent[nodeId]]",
      "mutated_line": "best = 0 + dist[parent[nodeId]]",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 0 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "best = 1 + dist[parent[nodeId]]",
      "mutated_line": "best = -1 + dist[parent[nodeId]]",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = -1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "offset += 1",
      "mutated_line": "offset += 2",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 2\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "offset += 1",
      "mutated_line": "offset += 0",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 0\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "offset += 1",
      "mutated_line": "offset += 0",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 0\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "offset += 1",
      "mutated_line": "offset += -1",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += -1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ancestor.append(0)",
      "mutated_line": "ancestor.append(1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(1)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ancestor.append(0)",
      "mutated_line": "ancestor.append(-1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(-1)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "ancestor.append(0)",
      "mutated_line": "ancestor.append(1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(1)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, ancestor[-1] + offset - 1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset - 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, (ancestor[-1] + offset) * 1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, (ancestor[-1] + offset) * 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ancestor.append(min(ancestor[-1], best - offset))",
      "mutated_line": "ancestor.append(min(ancestor[-1], best + offset))",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best + offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "ancestor.append(min(ancestor[-1], best - offset))",
      "mutated_line": "ancestor.append(min(ancestor[-1], best * offset))",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best * offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, ancestor[-1] - offset + 1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] - offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, ancestor[-1] * offset + 1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] * offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, ancestor[-1] + offset + 2)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 2)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, ancestor[-1] + offset + 0)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 0)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, ancestor[-1] + offset + 0)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 0)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, ancestor[-1] + offset + -1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + -1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "ancestor.append(min(ancestor[-1], best - offset))",
      "mutated_line": "ancestor.append(min(ancestor[+1], best - offset))",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[+1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ancestor.append(min(ancestor[-1], best - offset))",
      "mutated_line": "ancestor.append(min(ancestor[-2], best - offset))",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-2], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ancestor.append(min(ancestor[-1], best - offset))",
      "mutated_line": "ancestor.append(min(ancestor[-0], best - offset))",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-0], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ancestor.append(min(ancestor[-1], best - offset))",
      "mutated_line": "ancestor.append(min(ancestor[-0], best - offset))",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[-0], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "ancestor.append(min(ancestor[-1], best - offset))",
      "mutated_line": "ancestor.append(min(ancestor[--1], best - offset))",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-1] + offset + 1)\n            ancestor.append(min(ancestor[--1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, ancestor[+1] + offset + 1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[+1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, ancestor[-2] + offset + 1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-2] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, ancestor[-0] + offset + 1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-0] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, ancestor[-0] + offset + 1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[-0] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "best = min(best, ancestor[-1] + offset + 1)",
      "mutated_line": "best = min(best, ancestor[--1] + offset + 1)",
      "code": "def calculate_min_typing_time(n, pc, k, a):\n    ROOT = 0\n    trie = {ROOT: []}\n    parent = {}\n    for (i, (p, c)) in enumerate(pc, 1):\n        trie[p].append((c, i))\n        assert i not in trie\n        trie[i] = []\n        parent[i] = p\n    terminal = set(a)\n    for children in trie.values():\n        children.sort()\n    offset = 0\n    ancestor = []\n    dist = {}\n\n    def getDistPre(nodeId):\n        nonlocal offset\n        best = None\n        if nodeId != 0:\n            assert nodeId in parent\n            best = 1 + dist[parent[nodeId]]\n            if nodeId in terminal:\n                best = min(best, ancestor[--1] + offset + 1)\n            ancestor.append(min(ancestor[-1], best - offset))\n            if nodeId in terminal:\n                offset += 1\n        else:\n            best = 0\n            ancestor.append(0)\n        dist[nodeId] = best\n\n    def getDistPost(nodeId):\n        ancestor.pop()\n\n    def dfs(trie, root, preorder=None, postorder=None):\n        stack = [root]\n        seen = set()\n        while stack:\n            nodeId = stack.pop()\n            if nodeId not in seen:\n                if preorder:\n                    preorder(nodeId)\n                stack.append(nodeId)\n                seen.add(nodeId)\n                for (c, childId) in reversed(trie[nodeId]):\n                    stack.append(childId)\n            elif postorder:\n                postorder(nodeId)\n    dfs(trie, ROOT, preorder=getDistPre, postorder=getDistPost)\n    return [dist[nodeId] for nodeId in a]"
    }
  ]
}