{
  "task_id": "taco_1725",
  "entry_point": "calculate_game_moves",
  "mutant_count": 144,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] / (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] / (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] + (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] + (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] ** (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] ** (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] / (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] / (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] + (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] + (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] ** (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] ** (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] / (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] / (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] + (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] + (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] ** (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] ** (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist2 = [0] * (n + 1)",
      "mutated_line": "dist2 = [0] / (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] / (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist2 = [0] * (n + 1)",
      "mutated_line": "dist2 = [0] + (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] + (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist2 = [0] * (n + 1)",
      "mutated_line": "dist2 = [0] ** (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] ** (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "visited2 = [0] * (n + 1)",
      "mutated_line": "visited2 = [0] / (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] / (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "visited2 = [0] * (n + 1)",
      "mutated_line": "visited2 = [0] + (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] + (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "visited2 = [0] * (n + 1)",
      "mutated_line": "visited2 = [0] ** (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] ** (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "moved_up = 0",
      "mutated_line": "moved_up = 1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 1\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "moved_up = 0",
      "mutated_line": "moved_up = -1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = -1\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "moved_up = 0",
      "mutated_line": "moved_up = 1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 1\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while moved_up + 1 < dist[parent[curr]]:",
      "mutated_line": "while moved_up + 1 <= dist[parent[curr]]:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 <= dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while moved_up + 1 < dist[parent[curr]]:",
      "mutated_line": "while moved_up + 1 >= dist[parent[curr]]:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 >= dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while moved_up + 1 < dist[parent[curr]]:",
      "mutated_line": "while moved_up + 1 != dist[parent[curr]]:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 != dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "moved_up += 1",
      "mutated_line": "moved_up -= 1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up -= 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "best_loc = 0",
      "mutated_line": "best_loc = 1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 1\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "best_loc = 0",
      "mutated_line": "best_loc = -1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = -1\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "best_loc = 0",
      "mutated_line": "best_loc = 1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 1\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "UOI",
      "lineno": 53,
      "original_line": "best_dist = -1",
      "mutated_line": "best_dist = +1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = +1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 60,
      "original_line": "return 2 * dist[best_loc]",
      "mutated_line": "return 2 / dist[best_loc]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 / dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 60,
      "original_line": "return 2 * dist[best_loc]",
      "mutated_line": "return 2 + dist[best_loc]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 + dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 60,
      "original_line": "return 2 * dist[best_loc]",
      "mutated_line": "return 2 ** dist[best_loc]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 ** dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n - 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n - 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n * 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n * 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] * (n - 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n - 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] * (n * 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n * 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n - 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n - 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n * 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n * 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist2 = [0] * (n + 1)",
      "mutated_line": "dist2 = [0] * (n - 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n - 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "dist2 = [0] * (n + 1)",
      "mutated_line": "dist2 = [0] * (n * 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n * 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "visited2 = [0] * (n + 1)",
      "mutated_line": "visited2 = [0] * (n - 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n - 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "visited2 = [0] * (n + 1)",
      "mutated_line": "visited2 = [0] * (n * 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n * 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "while moved_up + 1 < dist[parent[curr]]:",
      "mutated_line": "while moved_up - 1 < dist[parent[curr]]:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up - 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "while moved_up + 1 < dist[parent[curr]]:",
      "mutated_line": "while moved_up * 1 < dist[parent[curr]]:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up * 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "moved_up += 1",
      "mutated_line": "moved_up += 2",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 2\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "moved_up += 1",
      "mutated_line": "moved_up += 0",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 0\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "moved_up += 1",
      "mutated_line": "moved_up += 0",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 0\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "moved_up += 1",
      "mutated_line": "moved_up += -1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += -1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "best_dist = -1",
      "mutated_line": "best_dist = -2",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -2\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "best_dist = -1",
      "mutated_line": "best_dist = -0",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -0\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "best_dist = -1",
      "mutated_line": "best_dist = -0",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -0\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "best_dist = -1",
      "mutated_line": "best_dist = --1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = --1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n - 1):",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n - 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 54,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n * 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "LCR",
      "lineno": 55,
      "original_line": "if visited2[i] and dist2[i] > best_dist:",
      "mutated_line": "if visited2[i] or dist2[i] > best_dist:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] or dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "return 2 * dist[best_loc]",
      "mutated_line": "return 3 * dist[best_loc]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 3 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "return 2 * dist[best_loc]",
      "mutated_line": "return 1 * dist[best_loc]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 1 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "return 2 * dist[best_loc]",
      "mutated_line": "return 0 * dist[best_loc]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 0 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "return 2 * dist[best_loc]",
      "mutated_line": "return 1 * dist[best_loc]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 1 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 60,
      "original_line": "return 2 * dist[best_loc]",
      "mutated_line": "return -2 * dist[best_loc]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return -2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [1] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [-1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [-1] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [1] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 2)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 2)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 0)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 0)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + -1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + -1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [1] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [-1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [-1] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [1] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] * (n + 2)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 2)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 0)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 0)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "parent = [0] * (n + 1)",
      "mutated_line": "parent = [0] * (n + -1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + -1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [1] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [-1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [-1] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [1] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n + 2)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 2)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 0)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 0)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n + -1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + -1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist2 = [0] * (n + 1)",
      "mutated_line": "dist2 = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [1] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist2 = [0] * (n + 1)",
      "mutated_line": "dist2 = [-1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [-1] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist2 = [0] * (n + 1)",
      "mutated_line": "dist2 = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [1] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist2 = [0] * (n + 1)",
      "mutated_line": "dist2 = [0] * (n + 2)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 2)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist2 = [0] * (n + 1)",
      "mutated_line": "dist2 = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 0)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist2 = [0] * (n + 1)",
      "mutated_line": "dist2 = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 0)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "dist2 = [0] * (n + 1)",
      "mutated_line": "dist2 = [0] * (n + -1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + -1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited2 = [0] * (n + 1)",
      "mutated_line": "visited2 = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [1] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited2 = [0] * (n + 1)",
      "mutated_line": "visited2 = [-1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [-1] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited2 = [0] * (n + 1)",
      "mutated_line": "visited2 = [1] * (n + 1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [1] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited2 = [0] * (n + 1)",
      "mutated_line": "visited2 = [0] * (n + 2)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 2)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited2 = [0] * (n + 1)",
      "mutated_line": "visited2 = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 0)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited2 = [0] * (n + 1)",
      "mutated_line": "visited2 = [0] * (n + 0)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 0)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "visited2 = [0] * (n + 1)",
      "mutated_line": "visited2 = [0] * (n + -1)",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + -1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = deque([1])",
      "mutated_line": "s = deque([2])",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([2])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = deque([1])",
      "mutated_line": "s = deque([0])",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([0])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = deque([1])",
      "mutated_line": "s = deque([0])",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([0])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "s = deque([1])",
      "mutated_line": "s = deque([-1])",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([-1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "curr = s[-1]",
      "mutated_line": "curr = s[+1]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[+1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "visited[curr] = 1",
      "mutated_line": "visited[curr] = 2",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 2\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "visited[curr] = 1",
      "mutated_line": "visited[curr] = 0",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 0\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "visited[curr] = 1",
      "mutated_line": "visited[curr] = 0",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 0\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "visited[curr] = 1",
      "mutated_line": "visited[curr] = -1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = -1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while moved_up + 1 < dist[parent[curr]]:",
      "mutated_line": "while moved_up + 2 < dist[parent[curr]]:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 2 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while moved_up + 1 < dist[parent[curr]]:",
      "mutated_line": "while moved_up + 0 < dist[parent[curr]]:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 0 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while moved_up + 1 < dist[parent[curr]]:",
      "mutated_line": "while moved_up + 0 < dist[parent[curr]]:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 0 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while moved_up + 1 < dist[parent[curr]]:",
      "mutated_line": "while moved_up + -1 < dist[parent[curr]]:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + -1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "UOI",
      "lineno": 41,
      "original_line": "curr = s[-1]",
      "mutated_line": "curr = s[+1]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[+1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "visited2[curr] = 1",
      "mutated_line": "visited2[curr] = 2",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 2\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "visited2[curr] = 1",
      "mutated_line": "visited2[curr] = 0",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 0\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "visited2[curr] = 1",
      "mutated_line": "visited2[curr] = 0",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 0\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "visited2[curr] = 1",
      "mutated_line": "visited2[curr] = -1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = -1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 2):",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 2):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 0):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + 0):",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 0):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "for i in range(n + 1):",
      "mutated_line": "for i in range(n + -1):",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + -1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if visited2[i] and dist2[i] > best_dist:",
      "mutated_line": "if visited2[i] and dist2[i] >= best_dist:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] >= best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if visited2[i] and dist2[i] > best_dist:",
      "mutated_line": "if visited2[i] and dist2[i] <= best_dist:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] <= best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if visited2[i] and dist2[i] > best_dist:",
      "mutated_line": "if visited2[i] and dist2[i] != best_dist:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] != best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n - 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n * 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr = s[-1]",
      "mutated_line": "curr = s[-2]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-2]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr = s[-1]",
      "mutated_line": "curr = s[-0]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-0]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr = s[-1]",
      "mutated_line": "curr = s[-0]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-0]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr = s[-1]",
      "mutated_line": "curr = s[--1]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[--1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "curr = s[-1]",
      "mutated_line": "curr = s[-2]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-2]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "curr = s[-1]",
      "mutated_line": "curr = s[-0]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-0]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "curr = s[-1]",
      "mutated_line": "curr = s[-0]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-0]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "curr = s[-1]",
      "mutated_line": "curr = s[--1]",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[--1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if parent[curr] != neighbor:",
      "mutated_line": "if parent[curr] == neighbor:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] == neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 2)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 0)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "adj = [[] for _ in range(n + 1)]",
      "mutated_line": "for (u, v) in edges:",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + -1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dist[neighbor] = dist[curr] + 1",
      "mutated_line": "dist[neighbor] = dist[curr] - 1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] - 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "dist[neighbor] = dist[curr] + 1",
      "mutated_line": "dist[neighbor] = dist[curr] * 1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] * 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "dist2[neighbor] = dist2[curr] + 1",
      "mutated_line": "dist2[neighbor] = dist2[curr] - 1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] - 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "dist2[neighbor] = dist2[curr] + 1",
      "mutated_line": "dist2[neighbor] = dist2[curr] * 1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] * 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dist[neighbor] = dist[curr] + 1",
      "mutated_line": "dist[neighbor] = dist[curr] + 2",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 2\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dist[neighbor] = dist[curr] + 1",
      "mutated_line": "dist[neighbor] = dist[curr] + 0",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 0\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dist[neighbor] = dist[curr] + 1",
      "mutated_line": "dist[neighbor] = dist[curr] + 0",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 0\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "dist[neighbor] = dist[curr] + 1",
      "mutated_line": "dist[neighbor] = dist[curr] + -1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + -1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dist2[neighbor] = dist2[curr] + 1",
      "mutated_line": "dist2[neighbor] = dist2[curr] + 2",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 2\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dist2[neighbor] = dist2[curr] + 1",
      "mutated_line": "dist2[neighbor] = dist2[curr] + 0",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 0\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dist2[neighbor] = dist2[curr] + 1",
      "mutated_line": "dist2[neighbor] = dist2[curr] + 0",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + 0\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "dist2[neighbor] = dist2[curr] + 1",
      "mutated_line": "dist2[neighbor] = dist2[curr] + -1",
      "code": "from collections import deque\n\ndef calculate_game_moves(n, x, edges):\n    adj = [[] for _ in range(n + 1)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    dist = [0] * (n + 1)\n    parent = [0] * (n + 1)\n    visited = [0] * (n + 1)\n    dist2 = [0] * (n + 1)\n    visited2 = [0] * (n + 1)\n    s = deque([1])\n    while s:\n        curr = s[-1]\n        if not visited[curr]:\n            visited[curr] = 1\n            for neighbor in adj[curr]:\n                if not visited[neighbor]:\n                    parent[neighbor] = curr\n                    s.append(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n        else:\n            s.pop()\n    curr = x\n    moved_up = 0\n    while moved_up + 1 < dist[parent[curr]]:\n        curr = parent[curr]\n        moved_up += 1\n    s = deque([curr])\n    while s:\n        curr = s[-1]\n        if not visited2[curr]:\n            visited2[curr] = 1\n            for neighbor in adj[curr]:\n                if parent[curr] != neighbor:\n                    s.append(neighbor)\n                    dist2[neighbor] = dist2[curr] + -1\n        else:\n            s.pop()\n    best_loc = 0\n    best_dist = -1\n    for i in range(n + 1):\n        if visited2[i] and dist2[i] > best_dist:\n            best_dist = dist2[i]\n            best_loc = i\n    return 2 * dist[best_loc]"
    }
  ]
}