{
  "task_id": "taco_7548",
  "entry_point": "min_operations_to_make_tree_good",
  "mutant_count": 74,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [0] / n",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] / n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [0] + n",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] + n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [0] ** n",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] ** n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = [0]",
      "mutated_line": "res = [1]",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [1]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = [0]",
      "mutated_line": "res = [-1]",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [-1]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = [0]",
      "mutated_line": "res = [1]",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [1]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if p != -1:",
      "mutated_line": "if p == -1:",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p == -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "zero = False",
      "mutated_line": "zero = True",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = True\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "ASR",
      "lineno": 35,
      "original_line": "res[0] += 1",
      "mutated_line": "res[0] -= 1",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] -= 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "fill_dfs(0, -1)",
      "mutated_line": "fill_dfs(1, -1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(1, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "fill_dfs(0, -1)",
      "mutated_line": "fill_dfs(-1, -1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(-1, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "fill_dfs(0, -1)",
      "mutated_line": "fill_dfs(1, -1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(1, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "fill_dfs(0, -1)",
      "mutated_line": "fill_dfs(0, +1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, +1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "calc_dfs(0, -1)",
      "mutated_line": "calc_dfs(1, -1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(1, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "calc_dfs(0, -1)",
      "mutated_line": "calc_dfs(-1, -1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(-1, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "calc_dfs(0, -1)",
      "mutated_line": "calc_dfs(1, -1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(1, -1)\n    return res[0]"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "calc_dfs(0, -1)",
      "mutated_line": "calc_dfs(0, +1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, +1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return res[0]",
      "mutated_line": "return res[1]",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return res[0]",
      "mutated_line": "return res[-1]",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[-1]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return res[0]",
      "mutated_line": "return res[1]",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[1]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 1].append(y + 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y + 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 1].append(y * 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y * 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 1].append(x + 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x + 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 1].append(x * 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x * 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [1] * n",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [1] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [-1] * n",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [-1] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "B = [0] * n",
      "mutated_line": "B = [1] * n",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [1] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "if p != -1:",
      "mutated_line": "if p != +1:",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != +1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if u != p:",
      "mutated_line": "if u == p:",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u == p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if u != p:",
      "mutated_line": "if u == p:",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u == p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res[0] += 1",
      "mutated_line": "res[0] += 2",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 2\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res[0] += 1",
      "mutated_line": "res[0] += 0",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 0\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res[0] += 1",
      "mutated_line": "res[0] += 0",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 0\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res[0] += 1",
      "mutated_line": "res[0] += -1",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += -1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "fill_dfs(0, -1)",
      "mutated_line": "fill_dfs(0, -2)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -2)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "fill_dfs(0, -1)",
      "mutated_line": "fill_dfs(0, -0)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -0)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "fill_dfs(0, -1)",
      "mutated_line": "fill_dfs(0, -0)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -0)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "fill_dfs(0, -1)",
      "mutated_line": "fill_dfs(0, --1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, --1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "calc_dfs(0, -1)",
      "mutated_line": "calc_dfs(0, -2)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -2)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "calc_dfs(0, -1)",
      "mutated_line": "calc_dfs(0, -0)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -0)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "calc_dfs(0, -1)",
      "mutated_line": "calc_dfs(0, -0)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -0)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "calc_dfs(0, -1)",
      "mutated_line": "calc_dfs(0, --1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, --1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 1].append(y - 2)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 2)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 1].append(y - 0)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 0)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 1].append(y - 0)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 0)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 1].append(y - -1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - -1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 1].append(x - 2)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 2)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 1].append(x - 0)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 0)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 1].append(x - 0)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 0)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 1].append(x - -1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - -1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if p != -1:",
      "mutated_line": "if p != -2:",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -2:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if p != -1:",
      "mutated_line": "if p != -0:",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -0:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if p != -1:",
      "mutated_line": "if p != -0:",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -0:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if p != -1:",
      "mutated_line": "if p != --1:",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != --1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if len(vals[v]) < len(vals[u]):",
      "mutated_line": "if len(vals[v]) <= len(vals[u]):",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) <= len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if len(vals[v]) < len(vals[u]):",
      "mutated_line": "if len(vals[v]) >= len(vals[u]):",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) >= len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if len(vals[v]) < len(vals[u]):",
      "mutated_line": "if len(vals[v]) != len(vals[u]):",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) != len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res[0] += 1",
      "mutated_line": "res[1] += 1",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[1] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res[0] += 1",
      "mutated_line": "res[-1] += 1",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[-1] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "res[0] += 1",
      "mutated_line": "res[1] += 1",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[1] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x + 1].append(y - 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x + 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x * 1].append(y - 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x * 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y + 1].append(x - 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y + 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y * 1].append(x - 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y * 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "zero |= x ^ a[v] in vals[v]",
      "mutated_line": "zero |= x ^ a[v] not in vals[v]",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] not in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 2].append(y - 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 2].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 0].append(y - 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 0].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - 0].append(y - 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 0].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[x - 1].append(y - 1)",
      "mutated_line": "G[x - -1].append(y - 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - -1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 2].append(x - 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 2].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 0].append(x - 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 0].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - 0].append(x - 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 0].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "G[y - 1].append(x - 1)",
      "mutated_line": "G[y - -1].append(x - 1)",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - -1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x ^ a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "zero |= x ^ a[v] in vals[v]",
      "mutated_line": "zero |= x | a[v] in vals[v]",
      "code": "from collections import defaultdict\n\ndef min_operations_to_make_tree_good(n, a, edges):\n    G = [[] for _ in range(n)]\n    for (x, y) in edges:\n        G[x - 1].append(y - 1)\n        G[y - 1].append(x - 1)\n    B = [0] * n\n    vals = defaultdict(set)\n    res = [0]\n\n    def fill_dfs(v, p):\n        B[v] = a[v]\n        if p != -1:\n            B[v] ^= B[p]\n        for u in G[v]:\n            if u != p:\n                fill_dfs(u, v)\n\n    def calc_dfs(v, p):\n        zero = False\n        vals[v].add(B[v])\n        for u in G[v]:\n            if u != p:\n                calc_dfs(u, v)\n                if len(vals[v]) < len(vals[u]):\n                    (vals[v], vals[u]) = (vals[u], vals[v])\n                for x in vals[u]:\n                    zero |= x | a[v] in vals[v]\n                for x in vals[u]:\n                    vals[v].add(x)\n                vals[u].clear()\n        if zero:\n            res[0] += 1\n            vals[v].clear()\n    fill_dfs(0, -1)\n    calc_dfs(0, -1)\n    return res[0]"
    }
  ]
}