{
  "task_id": "taco_15162",
  "entry_point": "calculate_minimum_distance",
  "mutant_count": 116,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "f[l] += 1",
      "mutated_line": "f[l] -= 1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] -= 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "f[r + 0.1] -= 1",
      "mutated_line": "f[r + 0.1] += 1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] += 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "f[l[i + 1]] += f[l[i]]",
      "mutated_line": "f[l[i + 1]] -= f[l[i]]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] -= f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] * 2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] * 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] + 2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] + 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "f[l] += 1",
      "mutated_line": "f[l] += 2",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 2\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "f[l] += 1",
      "mutated_line": "f[l] += 0",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 0\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "f[l] += 1",
      "mutated_line": "f[l] += 0",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 0\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "f[l] += 1",
      "mutated_line": "f[l] += -1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += -1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[r + 0.1] -= 1",
      "mutated_line": "f[r + 0.1] -= 2",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 2\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[r + 0.1] -= 1",
      "mutated_line": "f[r + 0.1] -= 0",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 0\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[r + 0.1] -= 1",
      "mutated_line": "f[r + 0.1] -= 0",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 0\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[r + 0.1] -= 1",
      "mutated_line": "f[r + 0.1] -= -1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= -1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(k - 1):",
      "mutated_line": "for i in range(k + 1):",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k + 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for i in range(k - 1):",
      "mutated_line": "for i in range(k * 1):",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k * 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "s = [0, 0]",
      "mutated_line": "s = [1, 0]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [1, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "s = [0, 0]",
      "mutated_line": "s = [-1, 0]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [-1, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "s = [0, 0]",
      "mutated_line": "s = [1, 0]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [1, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "s = [0, 0]",
      "mutated_line": "s = [0, 1]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 1]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "s = [0, 0]",
      "mutated_line": "s = [0, -1]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, -1]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "s = [0, 0]",
      "mutated_line": "s = [0, 1]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 1]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if s[1] < j:",
      "mutated_line": "if s[1] <= j:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] <= j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if s[1] < j:",
      "mutated_line": "if s[1] >= j:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] >= j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if s[1] < j:",
      "mutated_line": "if s[1] != j:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] != j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] % 3:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 3:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] % 1:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 1:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] % 0:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 0:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] % 1:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 1:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] % -2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % -2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) * 2 * M - round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M - round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) * 2 * M * round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M * round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return s[1] * M - round(s[0])",
      "mutated_line": "return s[1] * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M + round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return s[1] * M - round(s[0])",
      "mutated_line": "return s[1] * M * round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M * round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "f = defaultdict(lambda: 0)",
      "mutated_line": "f = defaultdict(lambda : 1)",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 1)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "f = defaultdict(lambda: 0)",
      "mutated_line": "f = defaultdict(lambda : -1)",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : -1)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "f = defaultdict(lambda: 0)",
      "mutated_line": "f = defaultdict(lambda : 1)",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 1)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "f[r + 0.1] -= 1",
      "mutated_line": "f[r - 0.1] -= 1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r - 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "f[r + 0.1] -= 1",
      "mutated_line": "f[r * 0.1] -= 1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r * 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "lis.add(r + 0.1)",
      "mutated_line": "lis.add(r - 0.1)",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r - 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "lis.add(r + 0.1)",
      "mutated_line": "lis.add(r * 0.1)",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r * 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(k - 1):",
      "mutated_line": "for i in range(k - 2):",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 2):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(k - 1):",
      "mutated_line": "for i in range(k - 0):",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 0):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(k - 1):",
      "mutated_line": "for i in range(k - 0):",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 0):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for i in range(k - 1):",
      "mutated_line": "for i in range(k - -1):",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - -1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "elif s[1] == j:",
      "mutated_line": "elif s[1] != j:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] != j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[2] % 2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[2] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[0] % 2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[0] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[0] % 2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[0] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[-1] % 2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[-1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) * 2 / M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 / M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) * 2 + M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 + M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return ((s[1] >> 1) * 2) ** M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return ((s[1] >> 1) * 2) ** M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return s[1] * M - round(s[0])",
      "mutated_line": "return s[1] / M - round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] / M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return s[1] * M - round(s[0])",
      "mutated_line": "return s[1] + M - round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] + M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "return s[1] * M - round(s[0])",
      "mutated_line": "return s[1] ** M - round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] ** M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[r + 0.1] -= 1",
      "mutated_line": "f[r + 1.1] -= 1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 1.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[r + 0.1] -= 1",
      "mutated_line": "f[r + -0.9] -= 1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + -0.9] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[r + 0.1] -= 1",
      "mutated_line": "f[r + 0] -= 1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[r + 0.1] -= 1",
      "mutated_line": "f[r + 1] -= 1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "f[r + 0.1] -= 1",
      "mutated_line": "f[r + -0.1] -= 1",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + -0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lis.add(r + 0.1)",
      "mutated_line": "lis.add(r + 1.1)",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 1.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lis.add(r + 0.1)",
      "mutated_line": "lis.add(r + -0.9)",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + -0.9)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lis.add(r + 0.1)",
      "mutated_line": "lis.add(r + 0)",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lis.add(r + 0.1)",
      "mutated_line": "lis.add(r + 1)",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "lis.add(r + 0.1)",
      "mutated_line": "lis.add(r + -0.1)",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + -0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "f[l[i + 1]] += f[l[i]]",
      "mutated_line": "f[l[i - 1]] += f[l[i]]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i - 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "f[l[i + 1]] += f[l[i]]",
      "mutated_line": "f[l[i * 1]] += f[l[i]]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i * 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if s[1] < j:",
      "mutated_line": "if s[2] < j:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[2] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if s[1] < j:",
      "mutated_line": "if s[0] < j:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[0] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if s[1] < j:",
      "mutated_line": "if s[0] < j:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[0] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if s[1] < j:",
      "mutated_line": "if s[-1] < j:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[-1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] * 2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] * 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] + 2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] + 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) / 2 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) / 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return ((s[1] >> 1) + 2) * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return ((s[1] >> 1) + 2) * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) ** 2 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) ** 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "f[l[i + 1]] += f[l[i]]",
      "mutated_line": "f[l[i + 2]] += f[l[i]]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 2]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "f[l[i + 1]] += f[l[i]]",
      "mutated_line": "f[l[i + 0]] += f[l[i]]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 0]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "f[l[i + 1]] += f[l[i]]",
      "mutated_line": "f[l[i + 0]] += f[l[i]]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 0]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "f[l[i + 1]] += f[l[i]]",
      "mutated_line": "f[l[i + -1]] += f[l[i]]",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + -1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif s[1] == j:",
      "mutated_line": "elif s[2] == j:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[2] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif s[1] == j:",
      "mutated_line": "elif s[0] == j:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[0] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif s[1] == j:",
      "mutated_line": "elif s[0] == j:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[0] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "elif s[1] == j:",
      "mutated_line": "elif s[-1] == j:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[-1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] % 3:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 3:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] % 1:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 1:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] % 0:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 0:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] % 1:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 1:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[1] % -2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % -2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) * 3 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 3 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) * 1 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 1 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) * 0 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 0 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) * 1 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 1 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) * -2 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * -2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) * 2 * M + round(s[1])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[1])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) * 2 * M + round(s[-1])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[-1])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 1) * 2 * M + round(s[1])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[1])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return s[1] * M - round(s[0])",
      "mutated_line": "return s[2] * M - round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[2] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return s[1] * M - round(s[0])",
      "mutated_line": "return s[0] * M - round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[0] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return s[1] * M - round(s[0])",
      "mutated_line": "return s[0] * M - round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[0] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return s[1] * M - round(s[0])",
      "mutated_line": "return s[-1] * M - round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[-1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return s[1] * M - round(s[0])",
      "mutated_line": "return s[1] * M - round(s[1])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return s[1] * M - round(s[0])",
      "mutated_line": "return s[1] * M - round(s[-1])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[-1])"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "return s[1] * M - round(s[0])",
      "mutated_line": "return s[1] * M - round(s[1])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[1])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[2] % 2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[2] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[0] % 2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[0] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[0] % 2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[0] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if s[1] % 2:",
      "mutated_line": "if s[-1] % 2:",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[-1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 2) * 2 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 2) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 0) * 2 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 0) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> 0) * 2 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> 0) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[1] >> -1) * 2 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[1] >> -1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[2] >> 1) * 2 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[2] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[0] >> 1) * 2 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[0] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[0] >> 1) * 2 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[0] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return (s[1] >> 1) * 2 * M + round(s[0])",
      "mutated_line": "return (s[-1] >> 1) * 2 * M + round(s[0])",
      "code": "from collections import defaultdict\n\ndef calculate_minimum_distance(N, M, yokans):\n    lis = set()\n    f = defaultdict(lambda : 0)\n    for (l, r) in yokans:\n        f[l] += 1\n        f[r + 0.1] -= 1\n        lis.add(l)\n        lis.add(r)\n        lis.add(r + 0.1)\n    l = list(lis)\n    l.sort()\n    k = len(l)\n    for i in range(k - 1):\n        f[l[i + 1]] += f[l[i]]\n    s = [0, 0]\n    for i in l:\n        j = f[i]\n        if s[1] < j:\n            s = [i, j]\n        elif s[1] == j:\n            if s[1] % 2:\n                s = [i, j]\n    if s[1] % 2:\n        return (s[-1] >> 1) * 2 * M + round(s[0])\n    else:\n        return s[1] * M - round(s[0])"
    }
  ]
}