{
  "task_id": "taco_7297",
  "entry_point": "minimize_partition_difference",
  "mutant_count": 39,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "half = sum(x) // 2",
      "mutated_line": "half = sum(x) / 2",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) / 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "half = sum(x) // 2",
      "mutated_line": "half = sum(x) * 2",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) * 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "half = sum(x) // 2",
      "mutated_line": "half = sum(x) // 3",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 3\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "half = sum(x) // 2",
      "mutated_line": "half = sum(x) // 1",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 1\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "half = sum(x) // 2",
      "mutated_line": "half = sum(x) // 0",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 0\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "half = sum(x) // 2",
      "mutated_line": "half = sum(x) // 1",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 1\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "half = sum(x) // 2",
      "mutated_line": "half = sum(x) // -2",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // -2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "mutated_line": "sums = sums - [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums - [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "mutated_line": "sums = sums * [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums * [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if max((s[0] for s in sums)) == half:",
      "mutated_line": "if max((s[0] for s in sums)) != half:",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) != half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "indices = sums[0][1]",
      "mutated_line": "indices = sums[0][2]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][2]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "indices = sums[0][1]",
      "mutated_line": "indices = sums[0][0]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][0]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "indices = sums[0][1]",
      "mutated_line": "indices = sums[0][0]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][0]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "indices = sums[0][1]",
      "mutated_line": "indices = sums[0][-1]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][-1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sums = [(0, [])]",
      "mutated_line": "sums = [(1, [])]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(1, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sums = [(0, [])]",
      "mutated_line": "sums = [(-1, [])]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(-1, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "sums = [(0, [])]",
      "mutated_line": "sums = [(1, [])]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(1, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "indices = sums[0][1]",
      "mutated_line": "indices = sums[1][1]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[1][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "indices = sums[0][1]",
      "mutated_line": "indices = sums[-1][1]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[-1][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "indices = sums[0][1]",
      "mutated_line": "indices = sums[1][1]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[1][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "a = [n for (i, n) in enumerate(x) if i in indices]",
      "mutated_line": "a = [n for (i, n) in enumerate(x) if i not in indices]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i not in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "b = [n for (i, n) in enumerate(x) if i not in indices]",
      "mutated_line": "b = [n for (i, n) in enumerate(x) if i in indices]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i in indices]\n    return (a, b)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "mutated_line": "sums = sums + [(m - n, a + [i]) for (m, a) in sums if m + n <= half]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m - n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "mutated_line": "sums = sums + [(m * n, a + [i]) for (m, a) in sums if m + n <= half]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m * n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "mutated_line": "sums = sums + [(m + n, a - [i]) for (m, a) in sums if m + n <= half]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a - [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "mutated_line": "sums = sums + [(m + n, a * [i]) for (m, a) in sums if m + n <= half]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a * [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "mutated_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n < half]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n < half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "mutated_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n > half]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n > half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "mutated_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n == half]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n == half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "sums.sort(key=lambda v: abs(v[0] - half))",
      "mutated_line": "sums.sort(key=lambda v: abs(v[0] + half))",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] + half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "sums.sort(key=lambda v: abs(v[0] - half))",
      "mutated_line": "sums.sort(key=lambda v: abs(v[0] * half))",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] * half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "mutated_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m - n <= half]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m - n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]",
      "mutated_line": "sums = sums + [(m + n, a + [i]) for (m, a) in sums if m * n <= half]",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m * n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if max((s[0] for s in sums)) == half:",
      "mutated_line": "if max((s[1] for s in sums)) == half:",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[1] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if max((s[0] for s in sums)) == half:",
      "mutated_line": "if max((s[-1] for s in sums)) == half:",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[-1] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if max((s[0] for s in sums)) == half:",
      "mutated_line": "if max((s[1] for s in sums)) == half:",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[1] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[0] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "sums.sort(key=lambda v: abs(v[0] - half))",
      "mutated_line": "sums.sort(key=lambda v: abs(v[1] - half))",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[1] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "sums.sort(key=lambda v: abs(v[0] - half))",
      "mutated_line": "sums.sort(key=lambda v: abs(v[-1] - half))",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[-1] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "sums.sort(key=lambda v: abs(v[0] - half))",
      "mutated_line": "sums.sort(key=lambda v: abs(v[1] - half))",
      "code": "def minimize_partition_difference(x):\n    half = sum(x) // 2\n    sums = [(0, [])]\n    for (i, n) in enumerate(x):\n        sums = sums + [(m + n, a + [i]) for (m, a) in sums if m + n <= half]\n        if max((s[0] for s in sums)) == half:\n            break\n    sums.sort(key=lambda v: abs(v[1] - half))\n    indices = sums[0][1]\n    a = [n for (i, n) in enumerate(x) if i in indices]\n    b = [n for (i, n) in enumerate(x) if i not in indices]\n    return (a, b)"
    }
  ]
}