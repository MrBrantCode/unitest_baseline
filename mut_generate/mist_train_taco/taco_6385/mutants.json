{
  "task_id": "taco_6385",
  "entry_point": "max_pleasantness_sum",
  "mutant_count": 118,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "oo = 10 ** 20",
      "mutated_line": "oo = 10 * 20",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 * 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "oo = 10 ** 20",
      "mutated_line": "oo = 10 + 20",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 + 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "sm = [0] * n",
      "mutated_line": "sm = [0] / n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] / n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "sm = [0] * n",
      "mutated_line": "sm = [0] + n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] + n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "sm = [0] * n",
      "mutated_line": "sm = [0] ** n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] ** n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mx = [-oo] * n",
      "mutated_line": "mx = [-oo] / n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] / n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mx = [-oo] * n",
      "mutated_line": "mx = [-oo] + n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] + n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "mx = [-oo] * n",
      "mutated_line": "mx = [-oo] ** n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] ** n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "best = [-oo] * n",
      "mutated_line": "best = [-oo] / n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] / n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "best = [-oo] * n",
      "mutated_line": "best = [-oo] + n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] + n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "best = [-oo] * n",
      "mutated_line": "best = [-oo] ** n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] ** n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "visit = [False] * n",
      "mutated_line": "visit = [False] / n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] / n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "visit = [False] * n",
      "mutated_line": "visit = [False] + n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] + n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "visit = [False] * n",
      "mutated_line": "visit = [False] ** n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] ** n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if ans <= -oo:",
      "mutated_line": "if ans < -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans < -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if ans <= -oo:",
      "mutated_line": "if ans > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans > -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if ans <= -oo:",
      "mutated_line": "if ans == -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans == -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "oo = 10 ** 20",
      "mutated_line": "oo = 11 ** 20",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 11 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "oo = 10 ** 20",
      "mutated_line": "oo = 9 ** 20",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 9 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "oo = 10 ** 20",
      "mutated_line": "oo = 0 ** 20",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 0 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "oo = 10 ** 20",
      "mutated_line": "oo = 1 ** 20",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 1 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "oo = 10 ** 20",
      "mutated_line": "oo = -10 ** 20",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = -10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "oo = 10 ** 20",
      "mutated_line": "oo = 10 ** 21",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 21\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "oo = 10 ** 20",
      "mutated_line": "oo = 10 ** 19",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 19\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "oo = 10 ** 20",
      "mutated_line": "oo = 10 ** 0",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 0\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "oo = 10 ** 20",
      "mutated_line": "oo = 10 ** 1",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 1\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "oo = 10 ** 20",
      "mutated_line": "oo = 10 ** -20",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** -20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "sm[u] += pleasantness[u]",
      "mutated_line": "sm[u] -= pleasantness[u]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] -= pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "if ans <= -oo:",
      "mutated_line": "if ans <= +oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= +oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "return 'Impossible'",
      "mutated_line": "return ''",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return ''\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v + 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v + 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v * 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v * 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 1].append(u + 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u + 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 1].append(u * 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u * 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sm = [0] * n",
      "mutated_line": "sm = [1] * n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [1] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sm = [0] * n",
      "mutated_line": "sm = [-1] * n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [-1] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "sm = [0] * n",
      "mutated_line": "sm = [1] * n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [1] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "mx = [-oo] * n",
      "mutated_line": "mx = [+oo] * n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [+oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "best = [-oo] * n",
      "mutated_line": "best = [+oo] * n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [+oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(0, -1)]",
      "mutated_line": "stack = [(1, -1)]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(1, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(0, -1)]",
      "mutated_line": "stack = [(-1, -1)]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(-1, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(0, -1)]",
      "mutated_line": "stack = [(1, -1)]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(1, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "stack = [(0, -1)]",
      "mutated_line": "stack = [(0, +1)]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, +1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "visit = [False] * n",
      "mutated_line": "visit = [True] * n",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [True] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "u, p = stack[-1]",
      "mutated_line": "(u, p) = stack[+1]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[+1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "visit[u] = True",
      "mutated_line": "visit[u] = False",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = False\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "x = [-oo] * 3",
      "mutated_line": "x = [-oo] / 3",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] / 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "x = [-oo] * 3",
      "mutated_line": "x = [-oo] + 3",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] + 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "x = [-oo] * 3",
      "mutated_line": "x = [-oo] ** 3",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] ** 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] > -oo or x[2] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo or x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v - 2)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 2)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v - 0)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 0)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v - 0)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 0)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 1].append(v - -1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - -1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 1].append(u - 2)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 2)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 1].append(u - 0)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 0)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 1].append(u - 0)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 0)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 1].append(u - -1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - -1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(0, -1)]",
      "mutated_line": "stack = [(0, -2)]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -2)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(0, -1)]",
      "mutated_line": "stack = [(0, -0)]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -0)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(0, -1)]",
      "mutated_line": "stack = [(0, -0)]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -0)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "stack = [(0, -1)]",
      "mutated_line": "stack = [(0, --1)]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, --1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "u, p = stack[-1]",
      "mutated_line": "(u, p) = stack[-2]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-2]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "u, p = stack[-1]",
      "mutated_line": "(u, p) = stack[-0]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-0]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "u, p = stack[-1]",
      "mutated_line": "(u, p) = stack[-0]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-0]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "u, p = stack[-1]",
      "mutated_line": "(u, p) = stack[--1]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[--1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if v != p:",
      "mutated_line": "if v == p:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v == p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "x = [-oo] * 3",
      "mutated_line": "x = [-oo] * 4",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 4\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "x = [-oo] * 3",
      "mutated_line": "x = [-oo] * 2",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 2\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "x = [-oo] * 3",
      "mutated_line": "x = [-oo] * 0",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 0\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "x = [-oo] * 3",
      "mutated_line": "x = [-oo] * 1",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 1\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "x = [-oo] * 3",
      "mutated_line": "x = [-oo] * -3",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * -3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if v != p:",
      "mutated_line": "if v == p:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v == p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "sm[u] += sm[v]",
      "mutated_line": "sm[u] -= sm[v]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] -= sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] >= -oo and x[2] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] >= -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] <= -oo and x[2] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] <= -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] != -oo and x[2] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] != -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] > -oo and x[2] >= -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] >= -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] > -oo and x[2] <= -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] <= -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] > -oo and x[2] != -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] != -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "cur = x[1] + x[2]",
      "mutated_line": "cur = x[1] - x[2]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] - x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "cur = x[1] + x[2]",
      "mutated_line": "cur = x[1] * x[2]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] * x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u + 1].append(v - 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u + 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u * 1].append(v - 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u * 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v + 1].append(u - 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v + 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v * 1].append(u - 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v * 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "x = [-oo] * 3",
      "mutated_line": "x = [+oo] * 3",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [+oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] > +oo and x[2] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > +oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] > -oo and x[2] > +oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > +oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 2].append(v - 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 2].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 0].append(v - 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 0].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - 0].append(v - 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 0].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[u - 1].append(v - 1)",
      "mutated_line": "adj[u - -1].append(v - 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - -1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 2].append(u - 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 2].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 0].append(u - 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 0].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - 0].append(u - 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 0].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "adj[v - 1].append(u - 1)",
      "mutated_line": "adj[v - -1].append(u - 1)",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - -1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "x[0] = mx[v]",
      "mutated_line": "x[1] = mx[v]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[1] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "x[0] = mx[v]",
      "mutated_line": "x[-1] = mx[v]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[-1] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "x[0] = mx[v]",
      "mutated_line": "x[1] = mx[v]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[1] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[2] > -oo and x[2] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[2] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[0] > -oo and x[2] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[0] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[0] > -oo and x[2] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[0] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[-1] > -oo and x[2] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[-1] > -oo and x[2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] > -oo and x[3] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[3] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] > -oo and x[1] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[1] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] > -oo and x[0] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[0] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] > -oo and x[1] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[1] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if x[1] > -oo and x[2] > -oo:",
      "mutated_line": "if x[1] > -oo and x[-2] > -oo:",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[-2] > -oo:\n                cur = x[1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur = x[1] + x[2]",
      "mutated_line": "cur = x[2] + x[2]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[2] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur = x[1] + x[2]",
      "mutated_line": "cur = x[0] + x[2]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[0] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur = x[1] + x[2]",
      "mutated_line": "cur = x[0] + x[2]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[0] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur = x[1] + x[2]",
      "mutated_line": "cur = x[-1] + x[2]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[-1] + x[2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur = x[1] + x[2]",
      "mutated_line": "cur = x[1] + x[3]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[3]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur = x[1] + x[2]",
      "mutated_line": "cur = x[1] + x[1]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[1]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur = x[1] + x[2]",
      "mutated_line": "cur = x[1] + x[0]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[0]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur = x[1] + x[2]",
      "mutated_line": "cur = x[1] + x[1]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[1]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cur = x[1] + x[2]",
      "mutated_line": "cur = x[1] + x[-2]",
      "code": "def max_pleasantness_sum(n, pleasantness, edges):\n    oo = 10 ** 20\n    adj = [[] for _ in range(n)]\n    for (u, v) in edges:\n        adj[u - 1].append(v - 1)\n        adj[v - 1].append(u - 1)\n    sm = [0] * n\n    mx = [-oo] * n\n    best = [-oo] * n\n    stack = [(0, -1)]\n    visit = [False] * n\n    while stack:\n        (u, p) = stack[-1]\n        if not visit[u]:\n            for v in adj[u]:\n                if v != p:\n                    stack.append((v, u))\n            visit[u] = True\n        else:\n            x = [-oo] * 3\n            for v in adj[u]:\n                if v != p:\n                    sm[u] += sm[v]\n                    mx[u] = max(mx[u], mx[v])\n                    best[u] = max(best[u], best[v])\n                    x[0] = mx[v]\n                    x.sort()\n            sm[u] += pleasantness[u]\n            mx[u] = max(mx[u], sm[u])\n            if x[1] > -oo and x[2] > -oo:\n                cur = x[1] + x[-2]\n                best[u] = max(best[u], cur)\n            stack.pop()\n    ans = max(best)\n    if ans <= -oo:\n        return 'Impossible'\n    else:\n        return ans"
    }
  ]
}