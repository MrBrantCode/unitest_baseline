{
  "task_id": "taco_9732",
  "entry_point": "generate_zozonacci",
  "mutant_count": 221,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], '': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], '': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], '': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], '': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], '': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], '': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], '': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], '': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], '': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], '': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], '': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], '': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], '': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], '': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], '': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if not pattern or not n:",
      "mutated_line": "if not pattern and (not n):",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern and (not n):\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [1, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [-1, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [1, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 1, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, -1, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 1, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 1, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, -1, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 1, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 2], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 0], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 0], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "'fib': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, -1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [1, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [-1, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [1, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 1, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, -1, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 1, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 1, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, -1, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 1, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 2], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 0], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 0], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "'jac': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, -1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [1, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [-1, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [1, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 2, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 0, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 0, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, -1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 1, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, -1, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 1, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 1], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, -1], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "'pad': [0, 1, 0, 0],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 1], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [1, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [-1, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [1, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 1, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, -1, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 1, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 1, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, -1, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 1, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 2], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 0], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 0], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "'pel': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, -1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [1, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [-1, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [1, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 1, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, -1, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 1, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 1, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, -1, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 1, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 2], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 0], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 0], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "'tet': [0, 0, 0, 1],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, -1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [1, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [-1, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [1, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 1, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, -1, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 1, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 1, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, -1, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 1, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 2]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 0]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 0]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "'tri': [0, 0, 0, 1]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, -1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] - a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] - a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] * a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] * a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] - 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] - 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] * (2 * a[-2]), 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] * (2 * a[-2]), 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] - a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] - a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] * a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] * a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] - a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] - a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] * a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] * a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] - a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] - a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: (a[-1] + a[-2] + a[-3]) * a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: (a[-1] + a[-2] + a[-3]) * a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] - a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] - a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: (a[-1] + a[-2]) * a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: (a[-1] + a[-2]) * a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 / a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 / a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + (2 + a[-2]), 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + (2 + a[-2]), 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 ** a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 ** a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 / a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 / a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 + a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 + a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 ** a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 ** a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] - a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] - a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: (a[-1] + a[-2]) * a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: (a[-1] + a[-2]) * a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] - a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] - a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] * a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] * a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for (f, _) in zip(cycl, range(n - 4)):",
      "mutated_line": "for (f, _) in zip(cycl, range(n + 4)):",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n + 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "for (f, _) in zip(cycl, range(n - 4)):",
      "mutated_line": "for (f, _) in zip(cycl, range(n * 4)):",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n * 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[+1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[+1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[+2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[+2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[+1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[+1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 3 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 3 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 1 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 1 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 0 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 0 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 1 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 1 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + -2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + -2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[+2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[+2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[+3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[+3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 3 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 3 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 1 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 1 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 0 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 0 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 1 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 1 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: -2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: -2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[+2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[+2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] - a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] - a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] * a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] * a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[+4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[+4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[+3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[+3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "lst = ROOT[pattern[0]][:]",
      "mutated_line": "lst = ROOT[pattern[1]][:]",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[1]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "lst = ROOT[pattern[0]][:]",
      "mutated_line": "lst = ROOT[pattern[-1]][:]",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[-1]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "lst = ROOT[pattern[0]][:]",
      "mutated_line": "lst = ROOT[pattern[1]][:]",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[1]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for (f, _) in zip(cycl, range(n - 4)):",
      "mutated_line": "for (f, _) in zip(cycl, range(n - 5)):",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 5)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for (f, _) in zip(cycl, range(n - 4)):",
      "mutated_line": "for (f, _) in zip(cycl, range(n - 3)):",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 3)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for (f, _) in zip(cycl, range(n - 4)):",
      "mutated_line": "for (f, _) in zip(cycl, range(n - 0)):",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 0)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for (f, _) in zip(cycl, range(n - 4)):",
      "mutated_line": "for (f, _) in zip(cycl, range(n - 1)):",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 1)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "for (f, _) in zip(cycl, range(n - 4)):",
      "mutated_line": "for (f, _) in zip(cycl, range(n - -4)):",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - -4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-2] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-2] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-0] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-0] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-0] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-0] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[--1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[--1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-3], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-3], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-1], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-1], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-0], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-0], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-1], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-1], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "'fib': lambda a: a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[--2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[--2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-2] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-2] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-0] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-0] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-0] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-0] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[--1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[--1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[+2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[+2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-3] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-3] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-1] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-1] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-0] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-0] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-1] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-1] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[--2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[--2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-4], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-4], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-2], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-2], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-0], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-0], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-1], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-1], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "'pad': lambda a: a[-2] + a[-3],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[--3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[--3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[+1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[+1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-3], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-3], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-1], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-1], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-0], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-0], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-1], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-1], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[--2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[--2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[+3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[+3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-5], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-5], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-3], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-3], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-0], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-0], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-1], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-1], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[--4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[--4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[+1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[+1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[+2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[+2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-4]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-4]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-2]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-2]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-0]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-0]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-1]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-1]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[--3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[--3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-3], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-3], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-1], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-1], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-0], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-0], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-1], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-1], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "'jac': lambda a: a[-1] + 2 * a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[--2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[--2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-2] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-2] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-0] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-0] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-0] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-0] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "'pel': lambda a: 2 * a[-1] + a[-2],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[--1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[--1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[+1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[+1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[+2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[+2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-4] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-4] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-2] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-2] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-0] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-0] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-1] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-1] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[--3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[--3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-2] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-2] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-0] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-0] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-0] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-0] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[--1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[--1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-3] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-3] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-1] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-1] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-0] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-0] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-1] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-1] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "'tri': lambda a: a[-1] + a[-2] + a[-3]",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[--2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[--2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-2] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-2] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-0] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-0] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-0] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-0] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[--1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[--1] + a[-2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-3] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-3] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-1] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-1] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-0] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-0] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-1] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[-1] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "'tet': lambda a: a[-1] + a[-2] + a[-3] + a[-4],",
      "mutated_line": "GEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[--2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}",
      "code": "from itertools import cycle\nROOT = {'fib': [0, 0, 0, 1], 'jac': [0, 0, 0, 1], 'pad': [0, 1, 0, 0], 'pel': [0, 0, 0, 1], 'tet': [0, 0, 0, 1], 'tri': [0, 0, 0, 1]}\nGEN = {'fib': lambda a: a[-1] + a[-2], 'jac': lambda a: a[-1] + 2 * a[-2], 'pad': lambda a: a[-2] + a[-3], 'pel': lambda a: 2 * a[-1] + a[-2], 'tet': lambda a: a[-1] + a[--2] + a[-3] + a[-4], 'tri': lambda a: a[-1] + a[-2] + a[-3]}\n\ndef generate_zozonacci(pattern, n):\n    \"\"\"\n    Generate the first `n` elements of the Zozonacci sequence based on the given `pattern`.\n\n    :param pattern: List of abbreviations representing the sequence types.\n    :param n: Number of elements to generate.\n    :return: List of integers representing the Zozonacci sequence.\n    \"\"\"\n    if not pattern or not n:\n        return []\n    lst = ROOT[pattern[0]][:]\n    cycl = cycle(map(GEN.get, pattern))\n    for (f, _) in zip(cycl, range(n - 4)):\n        lst.append(f(lst))\n    return lst[:n]"
    }
  ]
}