{
  "task_id": "taco_13966",
  "entry_point": "minimal_replacements_after_queries",
  "mutant_count": 231,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "\"\"\"",
      "mutated_line": "\"\"\"\"\"\"",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 1\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = -1\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 1\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "pos -= 1  # Convert to 0-based index",
      "mutated_line": "pos += 1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos += 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 < n or s[i:i + 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n or s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt -= 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pos -= 1  # Convert to 0-based index",
      "mutated_line": "pos -= 2",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 2\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pos -= 1  # Convert to 0-based index",
      "mutated_line": "pos -= 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 0\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pos -= 1  # Convert to 0-based index",
      "mutated_line": "pos -= 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 0\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "pos -= 1  # Convert to 0-based index",
      "mutated_line": "pos -= -1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= -1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if s[pos] != char:",
      "mutated_line": "if s[pos] == char:",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] == char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 <= n and s[i:i + 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 <= n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 >= n and s[i:i + 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 >= n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 != n and s[i:i + 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 != n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 < n and s[i:i + 3] != 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] != 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 2\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 0\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 0\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += -1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' or pos + 2 < n or s[pos:pos + 3] == ['a', 'b', 'c']:",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' or pos + 2 < n or s[pos:pos + 3] == ['a', 'b', 'c']:\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt += 1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' or pos + 2 < n or s[pos:pos + 3] == ['a', 'b', 'c']:",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' or pos + 2 < n or s[pos:pos + 3] == ['a', 'b', 'c']:\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 34,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i - 2 < n and s[i:i + 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i - 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i * 2 < n and s[i:i + 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i * 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 < n and s[i:i + 3] == '':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == '':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] != 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] != 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 <= n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 <= n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 >= n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 >= n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 != n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 != n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] != ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] != ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 2",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 2\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 0\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 0\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= -1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= -1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' or 0 < pos < n - 1 or s[pos - 1:pos + 2] == ['a', 'b', 'c']:",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' or 0 < pos < n - 1 or s[pos - 1:pos + 2] == ['a', 'b', 'c']:\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 29,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt += 1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] != 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] != 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 <= n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 <= n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 >= n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 >= n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 != n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 != n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] != ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] != ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 2\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 0\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 0\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += -1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' or 0 < pos < n - 1 or s[pos - 1:pos + 2] == ['a', 'b', 'c']:",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' or 0 < pos < n - 1 or s[pos - 1:pos + 2] == ['a', 'b', 'c']:\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 3 < n and s[i:i + 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 3 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 1 < n and s[i:i + 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 1 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 0 < n and s[i:i + 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 0 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 1 < n and s[i:i + 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 1 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + -2 < n and s[i:i + 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + -2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == '' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == '' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos - 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos - 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos * 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos * 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] != 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] != 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 <= pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 <= pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 >= pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 >= pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 != pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 != pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] != ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] != ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 2",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 2\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 0\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 0\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= -1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= -1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' or pos > 1 or s[pos - 2:pos + 1] == ['a', 'b', 'c']:",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' or pos > 1 or s[pos - 2:pos + 1] == ['a', 'b', 'c']:\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt += 1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == '' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == '' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos - 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos - 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos * 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos * 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] != 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] != 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 <= pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 <= pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 >= pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 >= pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 != pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 != pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] != ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] != ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 2\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 0\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 0\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += -1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' or pos > 1 or s[pos - 2:pos + 1] == ['a', 'b', 'c']:",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' or pos > 1 or s[pos - 2:pos + 1] == ['a', 'b', 'c']:\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 < n and s[i:i - 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i - 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 < n and s[i:i * 3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i * 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 3 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 3 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 1 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 1 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 0 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 0 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 1 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 1 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + -2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + -2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', '', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', '', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', '']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', '']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == '' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == '' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 1 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 1 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and -1 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and -1 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 1 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 1 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n + 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n + 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n * 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n * 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] != 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] != 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos >= 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos >= 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos <= 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos <= 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos != 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos != 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] != ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] != ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 2",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 2\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 0\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 0\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "cnt -= 1",
      "mutated_line": "cnt -= -1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= -1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 3 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 3 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 1 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 1 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 0 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 0 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 1 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 1 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + -2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + -2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', '', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', '', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', '']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', '']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == '' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == '' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 1 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 1 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and -1 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and -1 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 1 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 1 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n + 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n + 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n * 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n * 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] != 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] != 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos >= 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos >= 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos <= 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos <= 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos != 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos != 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] != ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] != ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 2\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 0\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 0\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += -1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 < n and s[i:i + 4] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 4] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 < n and s[i:i + 2] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 2] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 < n and s[i:i + 0] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 0] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 < n and s[i:i + 1] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 1] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if i + 2 < n and s[i:i + 3] == 'abc':",
      "mutated_line": "if i + 2 < n and s[i:i + -3] == 'abc':",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + -3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos - 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos - 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos * 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos * 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 2 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 2 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 0 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 0 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 0 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 0 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - -1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - -1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', '', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', '', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', '']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', '']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == '' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == '' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 2 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 2 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 0 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 0 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 0 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 0 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > -1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > -1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos - 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos - 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos * 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos * 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 2 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 2 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 0 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 0 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 0 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 0 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - -1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - -1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', '', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', '', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', '']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', '']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == '' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == '' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 2 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 2 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 0 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 0 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 0 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 0 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > -1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > -1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 4] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 4] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 0] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 0] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + -3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + -3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos + 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos + 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos * 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos * 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos - 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos - 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos * 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos * 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', '', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', '', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', '']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', '']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 4] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 4] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 0] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 0] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):",
      "mutated_line": "if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + -3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + -3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos + 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos + 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos * 1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos * 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos - 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos - 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos * 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos * 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', '', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', '', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', '']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', '']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 2:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 2:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 0:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 0:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 0:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 0:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - -1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - -1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 0] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 0] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + -2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + -2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos + 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos + 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos * 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos * 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos - 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos - 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos * 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos * 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 2:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 2:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 0:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 0:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 0:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 0:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - -1:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - -1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 3] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 0] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 0] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + -2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + -2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos + 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos + 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos * 2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos * 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos - 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos - 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos * 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos * 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 3:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 3:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 0:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 0:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - -2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - -2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 0] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 0] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 0] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 0] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + -1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + -1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 3:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 3:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 0:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 0:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 1:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - -2:pos + 1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - -2:pos + 1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 2] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 0] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 0] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 0] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 0] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):",
      "mutated_line": "elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + -1] == ['a', 'b', 'c']):",
      "code": "def minimal_replacements_after_queries(s: str, q: int, queries: list) -> list:\n    \"\"\"\n    Given a string `s` of length `n` consisting of characters \"a\", \"b\", and \"c\", and a list of `q` queries,\n    each query being a tuple `(pos, char)`, this function returns the minimal number of characters\n    that need to be replaced so that the string doesn't contain \"abc\" as a substring after each query.\n\n    Parameters:\n    - s (str): The initial string of length `n`.\n    - q (int): The number of queries.\n    - queries (list): A list of tuples where each tuple is `(pos, char)`.\n\n    Returns:\n    - list: A list of integers where each integer represents the minimal number of characters\n            that need to be replaced after each query.\n    \"\"\"\n    n = len(s)\n    cnt = 0\n    for i in range(n):\n        if i + 2 < n and s[i:i + 3] == 'abc':\n            cnt += 1\n    s = list(s)\n    results = []\n    for (pos, char) in queries:\n        pos -= 1\n        if s[pos] != char:\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt -= 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + 1] == ['a', 'b', 'c']):\n                cnt -= 1\n            s[pos] = char\n            if s[pos] == 'a' and pos + 2 < n and (s[pos:pos + 3] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'b' and 0 < pos < n - 1 and (s[pos - 1:pos + 2] == ['a', 'b', 'c']):\n                cnt += 1\n            elif s[pos] == 'c' and pos > 1 and (s[pos - 2:pos + -1] == ['a', 'b', 'c']):\n                cnt += 1\n        results.append(cnt)\n    return results"
    }
  ]
}