{
  "task_id": "taco_11350",
  "entry_point": "count_ways_to_solve_crime",
  "mutant_count": 80,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] / n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] / n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] + n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] + n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [False] ** n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] ** n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "acc = [0] * n",
      "mutated_line": "acc = [0] / n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] / n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "acc = [0] * n",
      "mutated_line": "acc = [0] + n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] + n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "acc = [0] * n",
      "mutated_line": "acc = [0] ** n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] ** n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cc = 0",
      "mutated_line": "cc = 1",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 1\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cc = 0",
      "mutated_line": "cc = -1",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = -1\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "cc = 0",
      "mutated_line": "cc = 1",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 1\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if cc == 1:",
      "mutated_line": "if cc != 1:",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc != 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 1",
      "mutated_line": "ans = 2",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 2\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 0\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 0\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "ans = 1",
      "mutated_line": "ans = -1",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = -1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "acc[cc] += 1",
      "mutated_line": "acc[cc] -= 1",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] -= 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "cc += 1",
      "mutated_line": "cc -= 1",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc -= 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if cc == 1:",
      "mutated_line": "if cc == 2:",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 2:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if cc == 1:",
      "mutated_line": "if cc == 0:",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 0:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if cc == 1:",
      "mutated_line": "if cc == 0:",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 0:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if cc == 1:",
      "mutated_line": "if cc == -1:",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == -1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return 1 % k",
      "mutated_line": "return 1 * k",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 * k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return 1 % k",
      "mutated_line": "return 1 + k",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 + k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for i in range(cc - 2):",
      "mutated_line": "for i in range(cc + 2):",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc + 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for i in range(cc - 2):",
      "mutated_line": "for i in range(cc * 2):",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc * 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = ans * n",
      "mutated_line": "ans = ans / n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans / n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = ans * n",
      "mutated_line": "ans = ans + n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans + n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "ans = ans * n",
      "mutated_line": "ans = ans ** n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans ** n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans % k",
      "mutated_line": "ans = ans * k",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans * k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = ans % k",
      "mutated_line": "ans = ans + k",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans + k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * acc[i]",
      "mutated_line": "ans = ans / acc[i]",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans / acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * acc[i]",
      "mutated_line": "ans = ans + acc[i]",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans + acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "ans = ans * acc[i]",
      "mutated_line": "ans = ans ** acc[i]",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans ** acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = ans % k",
      "mutated_line": "ans = ans * k",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans * k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans = ans % k",
      "mutated_line": "ans = ans + k",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans + k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "vis = [False] * n",
      "mutated_line": "vis = [True] * n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [True] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "acc = [0] * n",
      "mutated_line": "acc = [1] * n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [1] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "acc = [0] * n",
      "mutated_line": "acc = [-1] * n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [-1] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "acc = [0] * n",
      "mutated_line": "acc = [1] * n",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [1] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adj[v - 1].append(w - 1)",
      "mutated_line": "adj[v - 1].append(w + 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w + 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adj[v - 1].append(w - 1)",
      "mutated_line": "adj[v - 1].append(w * 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w * 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "adj[w - 1].append(v - 1)",
      "mutated_line": "adj[w - 1].append(v + 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v + 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "adj[w - 1].append(v - 1)",
      "mutated_line": "adj[w - 1].append(v * 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v * 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[node] = True",
      "mutated_line": "vis[node] = False",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = False\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "acc[cc] += 1",
      "mutated_line": "acc[cc] += 2",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 2\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "acc[cc] += 1",
      "mutated_line": "acc[cc] += 0",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 0\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "acc[cc] += 1",
      "mutated_line": "acc[cc] += 0",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 0\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "acc[cc] += 1",
      "mutated_line": "acc[cc] += -1",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += -1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cc += 1",
      "mutated_line": "cc += 2",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 2\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cc += 1",
      "mutated_line": "cc += 0",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 0\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cc += 1",
      "mutated_line": "cc += 0",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 0\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "cc += 1",
      "mutated_line": "cc += -1",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += -1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 % k",
      "mutated_line": "return 2 % k",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 2 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 % k",
      "mutated_line": "return 0 % k",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 0 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 % k",
      "mutated_line": "return 0 % k",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 0 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return 1 % k",
      "mutated_line": "return -1 % k",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return -1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(cc - 2):",
      "mutated_line": "for i in range(cc - 3):",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 3):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(cc - 2):",
      "mutated_line": "for i in range(cc - 1):",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 1):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(cc - 2):",
      "mutated_line": "for i in range(cc - 0):",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 0):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(cc - 2):",
      "mutated_line": "for i in range(cc - 1):",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 1):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(cc - 2):",
      "mutated_line": "for i in range(cc - -2):",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - -2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[v - 1].append(w - 1)",
      "mutated_line": "adj[v - 1].append(w - 2)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 2)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[v - 1].append(w - 1)",
      "mutated_line": "adj[v - 1].append(w - 0)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 0)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[v - 1].append(w - 1)",
      "mutated_line": "adj[v - 1].append(w - 0)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 0)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[v - 1].append(w - 1)",
      "mutated_line": "adj[v - 1].append(w - -1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - -1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "adj[w - 1].append(v - 1)",
      "mutated_line": "adj[w - 1].append(v - 2)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 2)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "adj[w - 1].append(v - 1)",
      "mutated_line": "adj[w - 1].append(v - 0)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 0)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "adj[w - 1].append(v - 1)",
      "mutated_line": "adj[w - 1].append(v - 0)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - 0)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "adj[w - 1].append(v - 1)",
      "mutated_line": "adj[w - 1].append(v - -1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 1].append(v - -1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adj[v - 1].append(w - 1)",
      "mutated_line": "adj[v + 1].append(w - 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v + 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "adj[v - 1].append(w - 1)",
      "mutated_line": "adj[v * 1].append(w - 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v * 1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "adj[w - 1].append(v - 1)",
      "mutated_line": "adj[w + 1].append(v - 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w + 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "adj[w - 1].append(v - 1)",
      "mutated_line": "adj[w * 1].append(v - 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w * 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[v - 1].append(w - 1)",
      "mutated_line": "adj[v - 2].append(w - 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 2].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[v - 1].append(w - 1)",
      "mutated_line": "adj[v - 0].append(w - 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 0].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[v - 1].append(w - 1)",
      "mutated_line": "adj[v - 0].append(w - 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 0].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "adj[v - 1].append(w - 1)",
      "mutated_line": "adj[v - -1].append(w - 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - -1].append(w - 1)\n        adj[w - 1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "adj[w - 1].append(v - 1)",
      "mutated_line": "adj[w - 2].append(v - 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 2].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "adj[w - 1].append(v - 1)",
      "mutated_line": "adj[w - 0].append(v - 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 0].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "adj[w - 1].append(v - 1)",
      "mutated_line": "adj[w - 0].append(v - 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - 0].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "adj[w - 1].append(v - 1)",
      "mutated_line": "adj[w - -1].append(v - 1)",
      "code": "def count_ways_to_solve_crime(n, m, k, links):\n    adj = [[] for _ in range(n)]\n    vis = [False] * n\n    acc = [0] * n\n    cc = 0\n    for (v, w) in links:\n        adj[v - 1].append(w - 1)\n        adj[w - -1].append(v - 1)\n\n    def ittDfs(node):\n        queue = [node]\n        while queue:\n            node = queue.pop()\n            if vis[node]:\n                continue\n            vis[node] = True\n            acc[cc] += 1\n            for i in adj[node]:\n                if not vis[i]:\n                    queue.append(i)\n    for i in range(n):\n        if not vis[i]:\n            ittDfs(i)\n            cc += 1\n    if cc == 1:\n        return 1 % k\n    ans = 1\n    for i in range(cc - 2):\n        ans = ans * n\n        ans = ans % k\n    for i in range(cc):\n        ans = ans * acc[i]\n        ans = ans % k\n    return ans"
    }
  ]
}