{
  "task_id": "taco_4721",
  "entry_point": "calculate_min_project_completion_time",
  "mutant_count": 62,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "degree = [0] * N",
      "mutated_line": "degree = [0] / N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] / N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "degree = [0] * N",
      "mutated_line": "degree = [0] + N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] + N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "degree = [0] * N",
      "mutated_line": "degree = [0] ** N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] ** N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "ASR",
      "lineno": 7,
      "original_line": "degree[edge[1]] += 1",
      "mutated_line": "degree[edge[1]] -= 1",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] -= 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [-1] / N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] / N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [-1] + N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] + N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [-1] ** N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] ** N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while len(pq) > 0:",
      "mutated_line": "while len(pq) >= 0:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) >= 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while len(pq) > 0:",
      "mutated_line": "while len(pq) <= 0:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) <= 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while len(pq) > 0:",
      "mutated_line": "while len(pq) != 0:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) != 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if -1 in dist:",
      "mutated_line": "if -1 not in dist:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 not in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "degree[edge[1]] += 1",
      "mutated_line": "degree[edge[1]] += 2",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 2\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "degree[edge[1]] += 1",
      "mutated_line": "degree[edge[1]] += 0",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 0\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "degree[edge[1]] += 1",
      "mutated_line": "degree[edge[1]] += 0",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 0\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "degree[edge[1]] += 1",
      "mutated_line": "degree[edge[1]] += -1",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += -1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if degree[i] == 0:",
      "mutated_line": "if degree[i] != 0:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] != 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(pq) > 0:",
      "mutated_line": "while len(pq) > 1:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 1:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(pq) > 0:",
      "mutated_line": "while len(pq) > -1:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > -1:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(pq) > 0:",
      "mutated_line": "while len(pq) > 1:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 1:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "degree[w] -= 1",
      "mutated_line": "degree[w] += 1",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] += 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "UOI",
      "lineno": 25,
      "original_line": "if -1 in dist:",
      "mutated_line": "if +1 in dist:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if +1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return +1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "degree = [0] * N",
      "mutated_line": "degree = [1] * N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [1] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "degree = [0] * N",
      "mutated_line": "degree = [-1] * N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [-1] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "degree = [0] * N",
      "mutated_line": "degree = [1] * N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [1] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [+1] * N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [+1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if degree[i] == 0:",
      "mutated_line": "if degree[i] == 1:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 1:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if degree[i] == 0:",
      "mutated_line": "if degree[i] == -1:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == -1:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "if degree[i] == 0:",
      "mutated_line": "if degree[i] == 1:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 1:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "degree[w] -= 1",
      "mutated_line": "degree[w] -= 2",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 2\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "degree[w] -= 1",
      "mutated_line": "degree[w] -= 0",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 0\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "degree[w] -= 1",
      "mutated_line": "degree[w] -= 0",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 0\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "degree[w] -= 1",
      "mutated_line": "degree[w] -= -1",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= -1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if degree[w] == 0:",
      "mutated_line": "if degree[w] != 0:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] != 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if -1 in dist:",
      "mutated_line": "if -2 in dist:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -2 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if -1 in dist:",
      "mutated_line": "if -0 in dist:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -0 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if -1 in dist:",
      "mutated_line": "if -0 in dist:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -0 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if -1 in dist:",
      "mutated_line": "if --1 in dist:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if --1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -2\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -0\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -0\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return --1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[edge[0]].append(edge[1])",
      "mutated_line": "adj[edge[0]].append(edge[2])",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[2])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[edge[0]].append(edge[1])",
      "mutated_line": "adj[edge[0]].append(edge[0])",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[0])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[edge[0]].append(edge[1])",
      "mutated_line": "adj[edge[0]].append(edge[0])",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[0])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[edge[0]].append(edge[1])",
      "mutated_line": "adj[edge[0]].append(edge[-1])",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[-1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "degree[edge[1]] += 1",
      "mutated_line": "degree[edge[2]] += 1",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[2]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "degree[edge[1]] += 1",
      "mutated_line": "degree[edge[0]] += 1",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[0]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "degree[edge[1]] += 1",
      "mutated_line": "degree[edge[0]] += 1",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[0]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "degree[edge[1]] += 1",
      "mutated_line": "degree[edge[-1]] += 1",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[-1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [-2] * N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-2] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [-0] * N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-0] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [-0] * N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-0] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "dist = [-1] * N",
      "mutated_line": "dist = [--1] * N",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [--1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if degree[w] == 0:",
      "mutated_line": "if degree[w] == 1:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 1:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if degree[w] == 0:",
      "mutated_line": "if degree[w] == -1:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == -1:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if degree[w] == 0:",
      "mutated_line": "if degree[w] == 1:",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 1:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist[w] = d + duration[w]",
      "mutated_line": "dist[w] = d - duration[w]",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d - duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "dist[w] = d + duration[w]",
      "mutated_line": "dist[w] = d * duration[w]",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[0]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d * duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[edge[0]].append(edge[1])",
      "mutated_line": "adj[edge[1]].append(edge[1])",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[1]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[edge[0]].append(edge[1])",
      "mutated_line": "adj[edge[-1]].append(edge[1])",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[-1]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "adj[edge[0]].append(edge[1])",
      "mutated_line": "adj[edge[1]].append(edge[1])",
      "code": "def calculate_min_project_completion_time(N, M, duration, dependencies):\n    degree = [0] * N\n    adj = [[] for _ in range(N)]\n    for edge in dependencies:\n        adj[edge[1]].append(edge[1])\n        degree[edge[1]] += 1\n    dist = [-1] * N\n    pq = []\n    for i in range(N):\n        if degree[i] == 0:\n            dist[i] = duration[i]\n            heapq.heappush(pq, (dist[i], i))\n    while len(pq) > 0:\n        (d, v) = heapq.heappop(pq)\n        for w in adj[v]:\n            degree[w] -= 1\n            if degree[w] == 0:\n                dist[w] = d + duration[w]\n                heapq.heappush(pq, (dist[w], w))\n    if -1 in dist:\n        return -1\n    return max(dist)"
    }
  ]
}