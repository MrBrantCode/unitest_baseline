{
  "task_id": "taco_8376",
  "entry_point": "count_good_divisions",
  "mutant_count": 205,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244354",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244354\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 998244352",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244352\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 0",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 0\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = 1",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 1\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "mod = 998244353",
      "mutated_line": "mod = -998244353",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = -998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if a == 0:",
      "mutated_line": "if a != 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a != 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if n == 1:",
      "mutated_line": "if n != 1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n != 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lcm = 1",
      "mutated_line": "lcm = 2",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 2\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lcm = 1",
      "mutated_line": "lcm = 0",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 0\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lcm = 1",
      "mutated_line": "lcm = 0",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 0\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "lcm = 1",
      "mutated_line": "lcm = -1",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = -1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "suffixgcd = [0] * n",
      "mutated_line": "suffixgcd = [0] / n",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] / n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "suffixgcd = [0] * n",
      "mutated_line": "suffixgcd = [0] + n",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] + n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "suffixgcd = [0] * n",
      "mutated_line": "suffixgcd = [0] ** n",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] ** n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g = 0",
      "mutated_line": "g = 1",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 1\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g = 0",
      "mutated_line": "g = -1",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = -1\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "g = 0",
      "mutated_line": "g = 1",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 1\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 1\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = -1\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 1\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "b = 0",
      "mutated_line": "b = 1",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 1\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "b = 0",
      "mutated_line": "b = -1",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = -1\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "b = 0",
      "mutated_line": "b = 1",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 1\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b or suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b or suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a == 0:",
      "mutated_line": "if a == 1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 1:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a == 0:",
      "mutated_line": "if a == -1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == -1:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "if a == 0:",
      "mutated_line": "if a == 1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 1:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return gcd(b % a, a)",
      "mutated_line": "return gcd(b * a, a)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b * a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return gcd(b % a, a)",
      "mutated_line": "return gcd(b + a, a)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b + a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 2:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 2:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 0:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n == 1:",
      "mutated_line": "if n == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 0:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if n == 1:",
      "mutated_line": "if n == -1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == -1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][0])",
      "mutated_line": "lcm = lcm * a[i][0] / gcd(lcm, a[i][0])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] / gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][0])",
      "mutated_line": "lcm = lcm * a[i][0] * gcd(lcm, a[i][0])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] * gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n + 1, -1, -1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n + 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n * 1, -1, -1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n * 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, +1, -1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, +1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, +1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, +1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n + 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n * 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if prefixlcm[i] > 1000000000.0:",
      "mutated_line": "if prefixlcm[i] >= 1000000000.0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] >= 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if prefixlcm[i] > 1000000000.0:",
      "mutated_line": "if prefixlcm[i] <= 1000000000.0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] <= 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if prefixlcm[i] > 1000000000.0:",
      "mutated_line": "if prefixlcm[i] != 1000000000.0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] != 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if suffixgcd[i] % prefixlcm[i] == 0:",
      "mutated_line": "if suffixgcd[i] % prefixlcm[i] != 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] != 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n or suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n or suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] != 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] != 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) * mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) * mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = res + pow(2, a[n - 1][1], mod) - 2 + mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = res + pow(2, a[n - 1][1], mod) - 2 + mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[0][1], mod) - 2) * mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) * mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append(pow(2, a[0][1], mod) - 2 + mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append(pow(2, a[0][1], mod) - 2 + mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][0])",
      "mutated_line": "lcm = lcm / a[i][0] // gcd(lcm, a[i][0])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm / a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][0])",
      "mutated_line": "lcm = (lcm + a[i][0]) // gcd(lcm, a[i][0])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = (lcm + a[i][0]) // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][0])",
      "mutated_line": "lcm = lcm ** a[i][0] // gcd(lcm, a[i][0])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm ** a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "suffixgcd = [0] * n",
      "mutated_line": "suffixgcd = [1] * n",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [1] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "suffixgcd = [0] * n",
      "mutated_line": "suffixgcd = [-1] * n",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [-1] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "suffixgcd = [0] * n",
      "mutated_line": "suffixgcd = [1] * n",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [1] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 2, -1, -1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 2, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 0, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 0, -1, -1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 0, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - -1, -1, -1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - -1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -2, -1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -2, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -0, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -0, -1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -0, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, --1, -1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, --1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -2):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -2):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -0):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, -0):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -0):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(n - 1, -1, -1):",
      "mutated_line": "for i in range(n - 1, -1, --1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, --1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 2):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 0):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 0):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - -1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if prefixlcm[i] > 1000000000.0:",
      "mutated_line": "if prefixlcm[i] > 1000000001.0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000001.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if prefixlcm[i] > 1000000000.0:",
      "mutated_line": "if prefixlcm[i] > 999999999.0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 999999999.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if prefixlcm[i] > 1000000000.0:",
      "mutated_line": "if prefixlcm[i] > 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if prefixlcm[i] > 1000000000.0:",
      "mutated_line": "if prefixlcm[i] > 1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if prefixlcm[i] > 1000000000.0:",
      "mutated_line": "if prefixlcm[i] > -1000000000.0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > -1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "b = 1",
      "mutated_line": "b = 2",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 2\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "b = 1",
      "mutated_line": "b = 0",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 0\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "b = 1",
      "mutated_line": "b = 0",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 0\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "b = 1",
      "mutated_line": "b = -1",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = -1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if suffixgcd[i] % prefixlcm[i] == 0:",
      "mutated_line": "if suffixgcd[i] * prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] * prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "if suffixgcd[i] % prefixlcm[i] == 0:",
      "mutated_line": "if suffixgcd[i] + prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] + prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if suffixgcd[i] % prefixlcm[i] == 0:",
      "mutated_line": "if suffixgcd[i] % prefixlcm[i] == 1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 1:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if suffixgcd[i] % prefixlcm[i] == 0:",
      "mutated_line": "if suffixgcd[i] % prefixlcm[i] == -1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == -1:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "if suffixgcd[i] % prefixlcm[i] == 0:",
      "mutated_line": "if suffixgcd[i] % prefixlcm[i] == 1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 1:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[i][1], mod) - 2) * mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) * mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = res + pow(2, a[i][1], mod) - 2 + mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = res + pow(2, a[i][1], mod) - 2 + mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 <= n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 <= n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 >= n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 >= n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 != n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 != n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] != 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] != 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res = (res + 1) % mod",
      "mutated_line": "res = (res + 1) * mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) * mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res = (res + 1) % mod",
      "mutated_line": "res = res + 1 + mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = res + 1 + mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 1] * prefixlcm[n - 1] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] * prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 1] + prefixlcm[n - 1] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] + prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 1:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == -1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == -1:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 1:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 1][1], mod) + 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) + 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 1][1], mod)) * 2 % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod)) * 2 % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[0][1], mod) + 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) + 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append(pow(2, a[0][1], mod) * 2 % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append(pow(2, a[0][1], mod) * 2 % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "g = gcd(g, a[i][0])",
      "mutated_line": "g = gcd(g, a[i][1])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][1])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "g = gcd(g, a[i][0])",
      "mutated_line": "g = gcd(g, a[i][-1])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][-1])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "g = gcd(g, a[i][0])",
      "mutated_line": "g = gcd(g, a[i][1])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][1])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[i][1], mod) + 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) + 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[i][1], mod)) * 2 % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod)) * 2 % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i - 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i - 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i * 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i * 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n and suffixgcd[i + 1] * prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] * prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n and suffixgcd[i + 1] + prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] + prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 1:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == -1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == -1:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 1:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 1:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res = (res + 1) % mod",
      "mutated_line": "res = (res - 1) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res - 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "res = (res + 1) % mod",
      "mutated_line": "res = res * 1 % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = res * 1 % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res - pow(2, a[n - 1][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res - pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res * pow(2, a[n - 1][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res * pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 1][1], mod) - 3) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 3) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 1][1], mod) - 1) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 1) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 1][1], mod) - 0) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 0) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 1][1], mod) - 1) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 1) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 1][1], mod) - -2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - -2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[0][1], mod) - 3) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 3) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[0][1], mod) - 1) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 1) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[0][1], mod) - 0) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 0) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[0][1], mod) - 1) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 1) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[0][1], mod) - -2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - -2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][0])",
      "mutated_line": "lcm = lcm * a[i][1] // gcd(lcm, a[i][0])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][1] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][0])",
      "mutated_line": "lcm = lcm * a[i][-1] // gcd(lcm, a[i][0])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][-1] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][0])",
      "mutated_line": "lcm = lcm * a[i][1] // gcd(lcm, a[i][0])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][1] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][0])",
      "mutated_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][1])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][1])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][0])",
      "mutated_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][-1])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][-1])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][0])",
      "mutated_line": "lcm = lcm * a[i][0] // gcd(lcm, a[i][1])",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][1])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res - pow(2, a[i][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res - pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res * pow(2, a[i][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res * pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[i][1], mod) - 3) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 3) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[i][1], mod) - 1) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 1) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[i][1], mod) - 0) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 0) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[i][1], mod) - 1) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 1) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[i][1], mod) - -2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - -2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 2 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 2 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 0 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 0 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 0 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 0 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + -1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + -1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res = (res + 1) % mod",
      "mutated_line": "res = (res + 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 2) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res = (res + 1) % mod",
      "mutated_line": "res = (res + 0) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 0) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res = (res + 1) % mod",
      "mutated_line": "res = (res + 0) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 0) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "res = (res + 1) % mod",
      "mutated_line": "res = (res + -1) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + -1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n + 1] % prefixlcm[n - 1] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n + 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n * 1] % prefixlcm[n - 1] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n * 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 1] % prefixlcm[n + 1] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n + 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 1] % prefixlcm[n * 1] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n * 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(3, a[0][1], mod) - 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(3, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(1, a[0][1], mod) - 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(1, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(0, a[0][1], mod) - 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(0, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(1, a[0][1], mod) - 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(1, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(-2, a[0][1], mod) - 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(-2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n and suffixgcd[i - 1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i - 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n and suffixgcd[i * 1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i * 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 2] % prefixlcm[n - 1] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 2] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 0] % prefixlcm[n - 1] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 0] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 0] % prefixlcm[n - 1] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 0] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - -1] % prefixlcm[n - 1] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - -1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 2] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 2] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 0] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 0] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 0] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 0] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:",
      "mutated_line": "if not b and suffixgcd[n - 1] % prefixlcm[n - -1] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - -1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(3, a[n - 1][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(3, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(1, a[n - 1][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(1, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(0, a[n - 1][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(0, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(1, a[n - 1][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(1, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(-2, a[n - 1][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(-2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[0][2], mod) - 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][2], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[0][0], mod) - 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][0], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[0][0], mod) - 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][0], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[0][-1], mod) - 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][-1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(3, a[i][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(3, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(1, a[i][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(1, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(0, a[i][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(0, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(1, a[i][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(1, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(-2, a[i][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(-2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n and suffixgcd[i + 2] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 2] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n and suffixgcd[i + 0] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 0] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n and suffixgcd[i + 0] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 0] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:",
      "mutated_line": "if i + 1 < n and suffixgcd[i + -1] % prefixlcm[i] == 0:",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + -1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 1][2], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][2], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 1][0], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][0], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 1][0], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][0], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 1][-1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][-1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[1][1], mod) - 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[1][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[-1][1], mod) - 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[-1][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "results.append((pow(2, a[0][1], mod) - 2) % mod)",
      "mutated_line": "results.append((pow(2, a[1][1], mod) - 2) % mod)",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[1][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[i][2], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][2], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[i][0], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][0], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[i][0], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][0], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "res = (res + pow(2, a[i][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[i][-1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][-1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n + 1][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n + 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n * 1][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n * 1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 2][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 2][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 0][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 0][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - 0][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - 0][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "res = (res + pow(2, a[n - 1][1], mod) - 2) % mod",
      "mutated_line": "res = (res + pow(2, a[n - -1][1], mod) - 2) % mod",
      "code": "def count_good_divisions(test_cases):\n\n    def gcd(a, b):\n        if a == 0:\n            return b\n        return gcd(b % a, a)\n    mod = 998244353\n    results = []\n    for a in test_cases:\n        n = len(a)\n        a.sort()\n        if n == 1:\n            results.append((pow(2, a[0][1], mod) - 2) % mod)\n            continue\n        prefixlcm = []\n        lcm = 1\n        for i in range(n):\n            lcm = lcm * a[i][0] // gcd(lcm, a[i][0])\n            prefixlcm.append(lcm)\n        suffixgcd = [0] * n\n        g = 0\n        for i in range(n - 1, -1, -1):\n            g = gcd(g, a[i][0])\n            suffixgcd[i] = g\n        res = 0\n        b = 0\n        for i in range(n - 1):\n            if prefixlcm[i] > 1000000000.0:\n                b = 1\n                break\n            if suffixgcd[i] % prefixlcm[i] == 0:\n                res = (res + pow(2, a[i][1], mod) - 2) % mod\n            if i + 1 < n and suffixgcd[i + 1] % prefixlcm[i] == 0:\n                res = (res + 1) % mod\n        if not b and suffixgcd[n - 1] % prefixlcm[n - 1] == 0:\n            res = (res + pow(2, a[n - -1][1], mod) - 2) % mod\n        results.append(res)\n    return results"
    }
  ]
}