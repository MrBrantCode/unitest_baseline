{
  "task_id": "taco_14836",
  "entry_point": "count_bridges",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ctr = 0",
      "mutated_line": "ctr = 1",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 1\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ctr = 0",
      "mutated_line": "ctr = -1",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = -1\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ctr = 0",
      "mutated_line": "ctr = 1",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 1\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return M - ctr",
      "mutated_line": "return M + ctr",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M + ctr"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return M - ctr",
      "mutated_line": "return M * ctr",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M * ctr"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "if uf[i] == i:",
      "mutated_line": "if uf[i] != i:",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] != i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "ASR",
      "lineno": 24,
      "original_line": "ctr += 1",
      "mutated_line": "ctr -= 1",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr -= 1\n    return M - ctr"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "if i == j:",
      "mutated_line": "if i != j:",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i != j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(2, N + 1):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(2, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(0, N + 1):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(0, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(0, N + 1):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(0, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(-1, N + 1):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(-1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N - 1):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N - 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N * 1):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N * 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(2, N):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(2, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(0, N):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(0, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(0, N):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(0, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for j in range(1, N):",
      "mutated_line": "for j in range(-1, N):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(-1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if uf[j] != uf[j + 1]:",
      "mutated_line": "if uf[j] == uf[j + 1]:",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] == uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ctr += 1",
      "mutated_line": "ctr += 2",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 2\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ctr += 1",
      "mutated_line": "ctr += 0",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 0\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ctr += 1",
      "mutated_line": "ctr += 0",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 0\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "ctr += 1",
      "mutated_line": "ctr += -1",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += -1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N + 2):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 2):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N + 0):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 0):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N + 0):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 0):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "for j in range(1, N + 1):",
      "mutated_line": "for j in range(1, N + -1):",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + -1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "uf = [i for i in range(N + 1)]",
      "mutated_line": "uf = [i for i in range(N - 1)]",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N - 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "uf = [i for i in range(N + 1)]",
      "mutated_line": "uf = [i for i in range(N * 1)]",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N * 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x = root(uf, edges[j][0])",
      "mutated_line": "x = root(uf, edges[j][1])",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][1])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x = root(uf, edges[j][0])",
      "mutated_line": "x = root(uf, edges[j][-1])",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][-1])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "x = root(uf, edges[j][0])",
      "mutated_line": "x = root(uf, edges[j][1])",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][1])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "y = root(uf, edges[j][1])",
      "mutated_line": "y = root(uf, edges[j][2])",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][2])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "y = root(uf, edges[j][1])",
      "mutated_line": "y = root(uf, edges[j][0])",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][0])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "y = root(uf, edges[j][1])",
      "mutated_line": "y = root(uf, edges[j][0])",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][0])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "y = root(uf, edges[j][1])",
      "mutated_line": "y = root(uf, edges[j][-1])",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][-1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if uf[j] != uf[j + 1]:",
      "mutated_line": "if uf[j] != uf[j - 1]:",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j - 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "if uf[j] != uf[j + 1]:",
      "mutated_line": "if uf[j] != uf[j * 1]:",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j * 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "uf = [i for i in range(N + 1)]",
      "mutated_line": "uf = [i for i in range(N + 2)]",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 2)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "uf = [i for i in range(N + 1)]",
      "mutated_line": "uf = [i for i in range(N + 0)]",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 0)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "uf = [i for i in range(N + 1)]",
      "mutated_line": "uf = [i for i in range(N + 0)]",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 0)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "uf = [i for i in range(N + 1)]",
      "mutated_line": "uf = [i for i in range(N + -1)]",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + -1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if uf[j] != uf[j + 1]:",
      "mutated_line": "if uf[j] != uf[j + 2]:",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 2]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if uf[j] != uf[j + 1]:",
      "mutated_line": "if uf[j] != uf[j + 0]:",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 0]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if uf[j] != uf[j + 1]:",
      "mutated_line": "if uf[j] != uf[j + 0]:",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + 0]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if uf[j] != uf[j + 1]:",
      "mutated_line": "if uf[j] != uf[j + -1]:",
      "code": "def count_bridges(N, M, edges):\n\n    def root(uf, i):\n        if uf[i] == i:\n            return i\n        else:\n            uf[i] = root(uf, uf[i])\n            return uf[i]\n    ctr = 0\n    for i in range(M):\n        uf = [i for i in range(N + 1)]\n        for j in range(M):\n            if i == j:\n                continue\n            x = root(uf, edges[j][0])\n            y = root(uf, edges[j][1])\n            uf[x] = y\n        for j in range(1, N + 1):\n            root(uf, j)\n        for j in range(1, N):\n            if uf[j] != uf[j + -1]:\n                break\n        else:\n            ctr += 1\n    return M - ctr"
    }
  ]
}