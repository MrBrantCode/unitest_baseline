{
  "task_id": "taco_5390",
  "entry_point": "simulate_chip_colors",
  "mutant_count": 77,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "all_empty = False",
      "mutated_line": "all_empty = True",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = True\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 1\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i = 0",
      "mutated_line": "i = -1",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = -1\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "i = 0",
      "mutated_line": "i = 1",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 1\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while res[i] == ' ':",
      "mutated_line": "while res[i] != ' ':",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] != ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i -= 1",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i -= 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (n + i - 1) % n",
      "mutated_line": "return (n + i - 1) * n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) * n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (n + i - 1) % n",
      "mutated_line": "return n + i - 1 + n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return n + i - 1 + n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (i + 1) % n",
      "mutated_line": "return (i + 1) * n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) * n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (i + 1) % n",
      "mutated_line": "return i + 1 + n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return i + 1 + n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = [' ' for _ in range(n)]",
      "mutated_line": "res = ['' for _ in range(n)]",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = ['' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if cr == pr or cr == nx:",
      "mutated_line": "if cr == pr and cr == nx:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr and cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "while res[i] == ' ':",
      "mutated_line": "while res[i] == '':",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == '':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += 2",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 2\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 0\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += 0",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 0\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "i += 1",
      "mutated_line": "i += -1",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += -1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i >= n:",
      "mutated_line": "if i > n:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i > n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i >= n:",
      "mutated_line": "if i < n:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i < n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if i >= n:",
      "mutated_line": "if i == n:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i == n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while i != krug:",
      "mutated_line": "while i == krug:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i == krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (n + i - 1) % n",
      "mutated_line": "return (n + i + 1) % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i + 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (n + i - 1) % n",
      "mutated_line": "return (n + i) * 1 % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i) * 1 % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (i + 1) % n",
      "mutated_line": "return (i - 1) % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i - 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return (i + 1) % n",
      "mutated_line": "return i * 1 % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return i * 1 % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return 'B' if c == 'W' else 'W'",
      "mutated_line": "return 'B' if c != 'W' else 'W'",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c != 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 'B' if c == 'W' else 'W'",
      "mutated_line": "return '' if c == 'W' else 'W'",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return '' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 'B' if c == 'W' else 'W'",
      "mutated_line": "return 'B' if c == 'W' else ''",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else ''\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if cr == pr or cr == nx:",
      "mutated_line": "if cr != pr or cr == nx:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr != pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if cr == pr or cr == nx:",
      "mutated_line": "if cr == pr or cr != nx:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr != nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "all_empty = True",
      "mutated_line": "all_empty = False",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = False\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "while res[i] != ' ' and i != krug:",
      "mutated_line": "while res[i] != ' ' or i != krug:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' or i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if i == krug:",
      "mutated_line": "if i != krug:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i != krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "while res[i] == ' ':",
      "mutated_line": "while res[i] != ' ':",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] != ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if res[k] == ' ':",
      "mutated_line": "if res[k] != ' ':",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] != ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return ''.join(res)",
      "mutated_line": "return 'MUTATED'.join(res)",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return 'MUTATED'.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (n + i - 1) % n",
      "mutated_line": "return (n - i - 1) % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n - i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "return (n + i - 1) % n",
      "mutated_line": "return (n * i - 1) % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n * i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (n + i - 1) % n",
      "mutated_line": "return (n + i - 2) % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 2) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (n + i - 1) % n",
      "mutated_line": "return (n + i - 0) % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 0) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (n + i - 1) % n",
      "mutated_line": "return (n + i - 0) % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 0) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return (n + i - 1) % n",
      "mutated_line": "return (n + i - -1) % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - -1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return (i + 1) % n",
      "mutated_line": "return (i + 2) % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 2) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return (i + 1) % n",
      "mutated_line": "return (i + 0) % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 0) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return (i + 1) % n",
      "mutated_line": "return (i + 0) % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 0) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return (i + 1) % n",
      "mutated_line": "return (i + -1) % n",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + -1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 'B' if c == 'W' else 'W'",
      "mutated_line": "return 'B' if c == '' else 'W'",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == '' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 2 != 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 != 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while res[i] != ' ' and i != krug:",
      "mutated_line": "while res[i] == ' ' and i != krug:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] == ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "while res[i] != ' ' and i != krug:",
      "mutated_line": "while res[i] != ' ' and i == krug:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i == krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "while res[i] == ' ':",
      "mutated_line": "while res[i] == '':",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == '':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "LCR",
      "lineno": 48,
      "original_line": "if righti(l) == r or l == r:",
      "mutated_line": "if righti(l) == r and l == r:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r and l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if res[k] == ' ':",
      "mutated_line": "if res[k] == '':",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == '':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k * 2 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k * 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k + 2 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k + 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 2 == 1 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 1 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 2 == -1 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == -1 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 2 == 1 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 1 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "while res[i] != ' ' and i != krug:",
      "mutated_line": "while res[i] != '' and i != krug:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != '' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if righti(l) == r or l == r:",
      "mutated_line": "if righti(l) != r or l == r:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) != r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 48,
      "original_line": "if righti(l) == r or l == r:",
      "mutated_line": "if righti(l) == r or l != r:",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l != r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "ROR",
      "lineno": 52,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 2 != 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 != 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 3 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 3 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 1 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 1 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 0 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 0 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 1 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 1 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % -2 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % -2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k * 2 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k * 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k + 2 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k + 2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 2 == 1 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 1 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 2 == -1 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == -1 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 2 == 1 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 2 == 1 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 3 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 3 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 1 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 1 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 0 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 0 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % 1 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % 1 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])",
      "mutated_line": "res[k] = initial_colors[k] if k % -2 == 0 else inverse(initial_colors[k])",
      "code": "def simulate_chip_colors(n, k, initial_colors):\n\n    def lefti(i):\n        return (n + i - 1) % n\n\n    def righti(i):\n        return (i + 1) % n\n\n    def inverse(c):\n        return 'B' if c == 'W' else 'W'\n    res = [' ' for _ in range(n)]\n    for i in range(n):\n        cr = initial_colors[i]\n        pr = initial_colors[lefti(i)]\n        nx = initial_colors[righti(i)]\n        if cr == pr or cr == nx:\n            res[i] = cr\n    all_empty = False\n    i = 0\n    while res[i] == ' ':\n        i += 1\n        if i >= n:\n            all_empty = True\n            break\n    if all_empty:\n        for k in range(n):\n            res[k] = initial_colors[k] if k % 2 == 0 else inverse(initial_colors[k])\n    else:\n        krug = i\n        i = righti(i)\n        while i != krug:\n            while res[i] != ' ' and i != krug:\n                i = righti(i)\n            if i == krug:\n                break\n            l = lefti(i)\n            while res[i] == ' ':\n                i = righti(i)\n            r = i\n            real_l = l\n            for j in range(k):\n                res[righti(l)] = res[l]\n                res[lefti(r)] = res[r]\n                l = righti(l)\n                r = lefti(r)\n                if righti(l) == r or l == r:\n                    break\n        for k in range(n):\n            if res[k] == ' ':\n                res[k] = initial_colors[k] if k % -2 == 0 else inverse(initial_colors[k])\n    return ''.join(res)"
    }
  ]
}