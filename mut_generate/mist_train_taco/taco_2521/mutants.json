{
  "task_id": "taco_2521",
  "entry_point": "calculate_max_money_ways",
  "mutant_count": 44,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 18,
      "original_line": "lost += C[a]",
      "mutated_line": "lost -= C[a]",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost -= C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "losta += lostMoney",
      "mutated_line": "losta -= lostMoney",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta -= lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if key in minLost:",
      "mutated_line": "if key not in minLost:",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key not in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if losta < lost:",
      "mutated_line": "if losta <= lost:",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta <= lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if losta < lost:",
      "mutated_line": "if losta >= lost:",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta >= lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if losta < lost:",
      "mutated_line": "if losta != lost:",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta != lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (sum(C) - amount, number)",
      "mutated_line": "return (sum(C) + amount, number)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) + amount, number)"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "return (sum(C) - amount, number)",
      "mutated_line": "return (sum(C) * amount, number)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) * amount, number)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 1].add(b + 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b + 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 1].add(b * 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b * 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 1].add(a + 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a + 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 1].add(a * 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a * 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(losta, nba) = getMinLost(housesToVisit - lostHouses)",
      "mutated_line": "(losta, nba) = getMinLost(housesToVisit + lostHouses)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit + lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(losta, nba) = getMinLost(housesToVisit - lostHouses)",
      "mutated_line": "(losta, nba) = getMinLost(housesToVisit * lostHouses)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit * lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "elif losta == lost:",
      "mutated_line": "elif losta != lost:",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta != lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "nb += nba",
      "mutated_line": "nb -= nba",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb -= nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 1].add(b - 2)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 2)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 1].add(b - 0)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 0)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 1].add(b - 0)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 0)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 1].add(b - -1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - -1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 1].add(a - 2)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 2)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 1].add(a - 0)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 0)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 1].add(a - 0)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 0)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 1].add(a - -1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - -1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (0, 1)",
      "mutated_line": "return (1, 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (1, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (0, 1)",
      "mutated_line": "return (-1, 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (-1, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (0, 1)",
      "mutated_line": "return (1, 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (1, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (0, 1)",
      "mutated_line": "return (0, 2)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 2)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (0, 1)",
      "mutated_line": "return (0, 0)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 0)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (0, 1)",
      "mutated_line": "return (0, 0)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 0)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "return (0, 1)",
      "mutated_line": "return (0, -1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, -1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a + 1].add(b - 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a + 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a * 1].add(b - 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a * 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b + 1].add(a - 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b + 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b * 1].add(a - 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b * 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "lostHouses = set((b for b in G[a] if b in housesToVisit))",
      "mutated_line": "lostHouses = set((b for b in G[a] if b not in housesToVisit))",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b not in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 2].add(b - 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 2].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 0].add(b - 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 0].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - 0].add(b - 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 0].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "G[a - 1].add(b - 1)",
      "mutated_line": "G[a - -1].add(b - 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - -1].add(b - 1)\n        G[b - 1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 2].add(a - 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 2].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 0].add(a - 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 0].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - 0].add(a - 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - 0].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "G[b - 1].add(a - 1)",
      "mutated_line": "G[b - -1].add(a - 1)",
      "code": "def calculate_max_money_ways(N, M, C, roads):\n    G = {a: set() for a in range(N)}\n    for (a, b) in roads:\n        G[a - 1].add(b - 1)\n        G[b - -1].add(a - 1)\n    minLost = {}\n\n    def getMinLost(housesToVisit):\n        if not housesToVisit:\n            return (0, 1)\n        key = frozenset(housesToVisit)\n        if key in minLost:\n            return minLost[key]\n        a = housesToVisit.pop()\n        (lost, nb) = getMinLost(housesToVisit)\n        lost += C[a]\n        lostHouses = set((b for b in G[a] if b in housesToVisit))\n        lostMoney = sum((C[b] for b in lostHouses))\n        (losta, nba) = getMinLost(housesToVisit - lostHouses)\n        losta += lostMoney\n        housesToVisit.add(a)\n        if losta < lost:\n            (lost, nb) = (losta, nba)\n        elif losta == lost:\n            nb += nba\n        minLost[key] = (lost, nb)\n        return minLost[key]\n    (amount, number) = getMinLost(set(range(N)))\n    return (sum(C) - amount, number)"
    }
  ]
}