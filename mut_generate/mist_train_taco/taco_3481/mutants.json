{
  "task_id": "taco_3481",
  "entry_point": "minimize_inversions",
  "mutant_count": 143,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if K >= len(zr) or K >= len(ol):",
      "mutated_line": "if K >= len(zr) and K >= len(ol):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) and K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "zs = [0]",
      "mutated_line": "zs = [1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [1]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "zs = [0]",
      "mutated_line": "zs = [-1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [-1]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "zs = [0]",
      "mutated_line": "zs = [1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [1]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "os = [0]",
      "mutated_line": "os = [1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [1]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "os = [0]",
      "mutated_line": "os = [-1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [-1]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "os = [0]",
      "mutated_line": "os = [1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [1]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if c == '1':",
      "mutated_line": "if c != '1':",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c != '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "UOI",
      "lineno": 12,
      "original_line": "tzs = zs[-1]",
      "mutated_line": "tzs = zs[+1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[+1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "UOI",
      "lineno": 13,
      "original_line": "tos = os[-1]",
      "mutated_line": "tos = os[+1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[+1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if S[i] == '1':",
      "mutated_line": "if S[i] != '1':",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] != '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N + 1, -1, -1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N + 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N * 1, -1, -1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N * 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, +1, -1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, +1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, +1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, +1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if S[i] == '0':",
      "mutated_line": "if S[i] != '0':",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] != '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if K >= len(zr) or K >= len(ol):",
      "mutated_line": "if K > len(zr) or K >= len(ol):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K > len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if K >= len(zr) or K >= len(ol):",
      "mutated_line": "if K < len(zr) or K >= len(ol):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K < len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if K >= len(zr) or K >= len(ol):",
      "mutated_line": "if K == len(zr) or K >= len(ol):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K == len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if K >= len(zr) or K >= len(ol):",
      "mutated_line": "if K >= len(zr) or K > len(ol):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K > len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if K >= len(zr) or K >= len(ol):",
      "mutated_line": "if K >= len(zr) or K < len(ol):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K < len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if K >= len(zr) or K >= len(ol):",
      "mutated_line": "if K >= len(zr) or K == len(ol):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K == len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 1\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return -1\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 1\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "a1 = [0]",
      "mutated_line": "a1 = [1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [1]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "a1 = [0]",
      "mutated_line": "a1 = [-1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [-1]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "a1 = [0]",
      "mutated_line": "a1 = [1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [1]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "a2 = [0]",
      "mutated_line": "a2 = [1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [1]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "a2 = [0]",
      "mutated_line": "a2 = [-1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [-1]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "a2 = [0]",
      "mutated_line": "a2 = [1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [1]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "mv = float('inf')",
      "mutated_line": "mv = float('')",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "for i in range(K + 1):",
      "mutated_line": "for i in range(K - 1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K - 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "for i in range(K + 1):",
      "mutated_line": "for i in range(K * 1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K * 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "j = K - i",
      "mutated_line": "j = K + i",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K + i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "j = K - i",
      "mutated_line": "j = K * i",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K * i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return max(0, mv)",
      "mutated_line": "return max(1, mv)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(1, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return max(0, mv)",
      "mutated_line": "return max(-1, mv)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(-1, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return max(0, mv)",
      "mutated_line": "return max(1, mv)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(1, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "if c == '1':",
      "mutated_line": "if c == '':",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tzs = zs[-1]",
      "mutated_line": "tzs = zs[-2]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-2]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tzs = zs[-1]",
      "mutated_line": "tzs = zs[-0]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-0]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tzs = zs[-1]",
      "mutated_line": "tzs = zs[-0]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-0]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "tzs = zs[-1]",
      "mutated_line": "tzs = zs[--1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[--1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "tos = os[-1]",
      "mutated_line": "tos = os[-2]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-2]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "tos = os[-1]",
      "mutated_line": "tos = os[-0]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-0]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "tos = os[-1]",
      "mutated_line": "tos = os[-0]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-0]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "tos = os[-1]",
      "mutated_line": "tos = os[--1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[--1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if S[i] == '1':",
      "mutated_line": "if S[i] == '':",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = tzs - zs[i + 1]",
      "mutated_line": "v = tzs + zs[i + 1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs + zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = tzs - zs[i + 1]",
      "mutated_line": "v = tzs * zs[i + 1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs * zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if v == 0:",
      "mutated_line": "if v != 0:",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v != 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 2, -1, -1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 2, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 0, -1, -1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 0, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 0, -1, -1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 0, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - -1, -1, -1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - -1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -2, -1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -2, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -0, -1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -0, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -0, -1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -0, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, --1, -1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, --1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, -2):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -2):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, -0):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -0):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, -0):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -0):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1, -1, -1):",
      "mutated_line": "for i in range(N - 1, -1, --1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, --1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "if S[i] == '0':",
      "mutated_line": "if S[i] == '':",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if v == 0:",
      "mutated_line": "if v != 0:",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v != 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "a1.append(a1[-1] + kk)",
      "mutated_line": "a1.append(a1[-1] - kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] - kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "a1.append(a1[-1] + kk)",
      "mutated_line": "a1.append(a1[-1] * kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] * kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a2.append(a2[-1] + kk)",
      "mutated_line": "a2.append(a2[-1] - kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] - kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "a2.append(a2[-1] + kk)",
      "mutated_line": "a2.append(a2[-1] * kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] * kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for i in range(K + 1):",
      "mutated_line": "for i in range(K + 2):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 2):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for i in range(K + 1):",
      "mutated_line": "for i in range(K + 0):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 0):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for i in range(K + 1):",
      "mutated_line": "for i in range(K + 0):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 0):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "for i in range(K + 1):",
      "mutated_line": "for i in range(K + -1):",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + -1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "mv = min(mv, diff - a1[i] - a2[j] + i * j)",
      "mutated_line": "mv = min(mv, diff - a1[i] - a2[j] - i * j)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] - i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "mv = min(mv, diff - a1[i] - a2[j] + i * j)",
      "mutated_line": "mv = min(mv, (diff - a1[i] - a2[j]) * (i * j))",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, (diff - a1[i] - a2[j]) * (i * j))\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "os.append(os[-1] + 1)",
      "mutated_line": "os.append(os[-1] - 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] - 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "os.append(os[-1] + 1)",
      "mutated_line": "os.append(os[-1] * 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] * 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "zs.append(zs[-1] + 1)",
      "mutated_line": "zs.append(zs[-1] - 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] - 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "zs.append(zs[-1] + 1)",
      "mutated_line": "zs.append(zs[-1] * 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] * 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if v == 0:",
      "mutated_line": "if v == 1:",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 1:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if v == 0:",
      "mutated_line": "if v == -1:",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == -1:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "if v == 0:",
      "mutated_line": "if v == 1:",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 1:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "v = os[i + 1]",
      "mutated_line": "v = os[i - 1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i - 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "v = os[i + 1]",
      "mutated_line": "v = os[i * 1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i * 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if v == 0:",
      "mutated_line": "if v == 1:",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 1:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if v == 0:",
      "mutated_line": "if v == -1:",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == -1:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if v == 0:",
      "mutated_line": "if v == 1:",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 1:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "mv = min(mv, diff - a1[i] - a2[j] + i * j)",
      "mutated_line": "mv = min(mv, diff - a1[i] + a2[j] + i * j)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] + a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "mv = min(mv, diff - a1[i] - a2[j] + i * j)",
      "mutated_line": "mv = min(mv, (diff - a1[i]) * a2[j] + i * j)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, (diff - a1[i]) * a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "mv = min(mv, diff - a1[i] - a2[j] + i * j)",
      "mutated_line": "mv = min(mv, diff - a1[i] - a2[j] + i / j)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i / j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "mv = min(mv, diff - a1[i] - a2[j] + i * j)",
      "mutated_line": "mv = min(mv, diff - a1[i] - a2[j] + (i + j))",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + (i + j))\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "mv = min(mv, diff - a1[i] - a2[j] + i * j)",
      "mutated_line": "mv = min(mv, diff - a1[i] - a2[j] + i ** j)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i ** j)\n    return max(0, mv)"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "zs.append(zs[-1])",
      "mutated_line": "zs.append(zs[+1])",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[+1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "os.append(os[-1] + 1)",
      "mutated_line": "os.append(os[-1] + 2)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 2)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "os.append(os[-1] + 1)",
      "mutated_line": "os.append(os[-1] + 0)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 0)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "os.append(os[-1] + 1)",
      "mutated_line": "os.append(os[-1] + 0)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 0)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "os.append(os[-1] + 1)",
      "mutated_line": "os.append(os[-1] + -1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + -1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "zs.append(zs[-1] + 1)",
      "mutated_line": "zs.append(zs[-1] + 2)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 2)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "zs.append(zs[-1] + 1)",
      "mutated_line": "zs.append(zs[-1] + 0)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 0)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "zs.append(zs[-1] + 1)",
      "mutated_line": "zs.append(zs[-1] + 0)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 0)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "zs.append(zs[-1] + 1)",
      "mutated_line": "zs.append(zs[-1] + -1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + -1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "os.append(os[-1])",
      "mutated_line": "os.append(os[+1])",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[+1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = tzs - zs[i + 1]",
      "mutated_line": "v = tzs - zs[i - 1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i - 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = tzs - zs[i + 1]",
      "mutated_line": "v = tzs - zs[i * 1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i * 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v = os[i + 1]",
      "mutated_line": "v = os[i + 2]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 2]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v = os[i + 1]",
      "mutated_line": "v = os[i + 0]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 0]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v = os[i + 1]",
      "mutated_line": "v = os[i + 0]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 0]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "v = os[i + 1]",
      "mutated_line": "v = os[i + -1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + -1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "a1.append(a1[-1] + kk)",
      "mutated_line": "a1.append(a1[+1] + kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[+1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "UOI",
      "lineno": 43,
      "original_line": "a2.append(a2[-1] + kk)",
      "mutated_line": "a2.append(a2[+1] + kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[+1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "mv = min(mv, diff - a1[i] - a2[j] + i * j)",
      "mutated_line": "mv = min(mv, diff + a1[i] - a2[j] + i * j)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff + a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "mv = min(mv, diff - a1[i] - a2[j] + i * j)",
      "mutated_line": "mv = min(mv, diff * a1[i] - a2[j] + i * j)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff * a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "zs.append(zs[-1])",
      "mutated_line": "zs.append(zs[-2])",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-2])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "zs.append(zs[-1])",
      "mutated_line": "zs.append(zs[-0])",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-0])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "zs.append(zs[-1])",
      "mutated_line": "zs.append(zs[-0])",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-0])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "zs.append(zs[-1])",
      "mutated_line": "zs.append(zs[--1])",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[--1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "os.append(os[-1] + 1)",
      "mutated_line": "os.append(os[+1] + 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[+1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "UOI",
      "lineno": 9,
      "original_line": "zs.append(zs[-1] + 1)",
      "mutated_line": "zs.append(zs[+1] + 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[+1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "os.append(os[-1])",
      "mutated_line": "os.append(os[-2])",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-2])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "os.append(os[-1])",
      "mutated_line": "os.append(os[-0])",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-0])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "os.append(os[-1])",
      "mutated_line": "os.append(os[-0])",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-0])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "os.append(os[-1])",
      "mutated_line": "os.append(os[--1])",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[--1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = tzs - zs[i + 1]",
      "mutated_line": "v = tzs - zs[i + 2]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 2]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = tzs - zs[i + 1]",
      "mutated_line": "v = tzs - zs[i + 0]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 0]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = tzs - zs[i + 1]",
      "mutated_line": "v = tzs - zs[i + 0]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 0]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = tzs - zs[i + 1]",
      "mutated_line": "v = tzs - zs[i + -1]",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + -1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "a1.append(a1[-1] + kk)",
      "mutated_line": "a1.append(a1[-2] + kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-2] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "a1.append(a1[-1] + kk)",
      "mutated_line": "a1.append(a1[-0] + kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-0] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "a1.append(a1[-1] + kk)",
      "mutated_line": "a1.append(a1[-0] + kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-0] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "a1.append(a1[-1] + kk)",
      "mutated_line": "a1.append(a1[--1] + kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[--1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a2.append(a2[-1] + kk)",
      "mutated_line": "a2.append(a2[-2] + kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-2] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a2.append(a2[-1] + kk)",
      "mutated_line": "a2.append(a2[-0] + kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-0] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a2.append(a2[-1] + kk)",
      "mutated_line": "a2.append(a2[-0] + kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-0] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "a2.append(a2[-1] + kk)",
      "mutated_line": "a2.append(a2[--1] + kk)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[--1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "os.append(os[-1] + 1)",
      "mutated_line": "os.append(os[-2] + 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-2] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "os.append(os[-1] + 1)",
      "mutated_line": "os.append(os[-0] + 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-0] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "os.append(os[-1] + 1)",
      "mutated_line": "os.append(os[-0] + 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-0] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "os.append(os[-1] + 1)",
      "mutated_line": "os.append(os[--1] + 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[--1] + 1)\n        else:\n            zs.append(zs[-1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "zs.append(zs[-1] + 1)",
      "mutated_line": "zs.append(zs[-2] + 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-2] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "zs.append(zs[-1] + 1)",
      "mutated_line": "zs.append(zs[-0] + 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-0] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "zs.append(zs[-1] + 1)",
      "mutated_line": "zs.append(zs[-0] + 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[-0] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "zs.append(zs[-1] + 1)",
      "mutated_line": "zs.append(zs[--1] + 1)",
      "code": "def minimize_inversions(N, K, S):\n    zs = [0]\n    os = [0]\n    for c in S:\n        if c == '1':\n            zs.append(zs[-1])\n            os.append(os[-1] + 1)\n        else:\n            zs.append(zs[--1] + 1)\n            os.append(os[-1])\n    tzs = zs[-1]\n    tos = os[-1]\n    zr = []\n    ol = []\n    for i in range(N):\n        if S[i] == '1':\n            v = tzs - zs[i + 1]\n            if v == 0:\n                break\n            else:\n                zr.append(v)\n    for i in range(N - 1, -1, -1):\n        if S[i] == '0':\n            v = os[i + 1]\n            if v == 0:\n                break\n            else:\n                ol.append(v)\n    if K >= len(zr) or K >= len(ol):\n        return 0\n    a1 = [0]\n    for kk in zr:\n        a1.append(a1[-1] + kk)\n    a2 = [0]\n    for kk in ol:\n        a2.append(a2[-1] + kk)\n    mv = float('inf')\n    diff = sum(zr)\n    for i in range(K + 1):\n        j = K - i\n        mv = min(mv, diff - a1[i] - a2[j] + i * j)\n    return max(0, mv)"
    }
  ]
}