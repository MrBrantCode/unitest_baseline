{
  "task_id": "taco_9671",
  "entry_point": "minimum_edges_to_remove",
  "mutant_count": 58,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "USE = [0] * M",
      "mutated_line": "USE = [0] / M",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] / M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "USE = [0] * M",
      "mutated_line": "USE = [0] + M",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] + M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "USE = [0] * M",
      "mutated_line": "USE = [0] ** M",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] ** M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "WEIGHTSUM = [0] + [X[i] for i in range(N)]",
      "mutated_line": "WEIGHTSUM = [0] - [X[i] for i in range(N)]",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] - [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "WEIGHTSUM = [0] + [X[i] for i in range(N)]",
      "mutated_line": "WEIGHTSUM = [0] * [X[i] for i in range(N)]",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] * [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while Group[x] != x:",
      "mutated_line": "while Group[x] == x:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] == x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if find(x) != find(y):",
      "mutated_line": "if find(x) == find(y):",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) == find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if find(x) != find(y):",
      "mutated_line": "if find(x) == find(y):",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) == find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if w <= WEIGHTSUM[find(x)]:",
      "mutated_line": "if w < WEIGHTSUM[find(x)]:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w < WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if w <= WEIGHTSUM[find(x)]:",
      "mutated_line": "if w > WEIGHTSUM[find(x)]:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w > WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if w <= WEIGHTSUM[find(x)]:",
      "mutated_line": "if w == WEIGHTSUM[find(x)]:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w == WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return USE.count(0)",
      "mutated_line": "return USE.count(1)",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(1)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return USE.count(0)",
      "mutated_line": "return USE.count(-1)",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(-1)"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return USE.count(0)",
      "mutated_line": "return USE.count(1)",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(1)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "USE = [0] * M",
      "mutated_line": "USE = [1] * M",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [1] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "USE = [0] * M",
      "mutated_line": "USE = [-1] * M",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [-1] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "USE = [0] * M",
      "mutated_line": "USE = [1] * M",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [1] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "WEIGHTSUM = [0] + [X[i] for i in range(N)]",
      "mutated_line": "WEIGHTSUM = [1] + [X[i] for i in range(N)]",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [1] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "WEIGHTSUM = [0] + [X[i] for i in range(N)]",
      "mutated_line": "WEIGHTSUM = [-1] + [X[i] for i in range(N)]",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [-1] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "WEIGHTSUM = [0] + [X[i] for i in range(N)]",
      "mutated_line": "WEIGHTSUM = [1] + [X[i] for i in range(N)]",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [1] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]",
      "mutated_line": "WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] - WEIGHTSUM[find(y)]",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] - WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]",
      "mutated_line": "WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] * WEIGHTSUM[find(y)]",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] * WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 45,
      "original_line": "if USE[nq] == 1:",
      "mutated_line": "if USE[nq] != 1:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] != 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "for e in EDGELIST[x] + EDGELIST[y]:",
      "mutated_line": "for e in EDGELIST[x] - EDGELIST[y]:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] - EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "for e in EDGELIST[x] + EDGELIST[y]:",
      "mutated_line": "for e in EDGELIST[x] * EDGELIST[y]:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] * EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "USE[nq] = 1",
      "mutated_line": "USE[nq] = 2",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 2\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "USE[nq] = 1",
      "mutated_line": "USE[nq] = 0",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 0\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "USE[nq] = 1",
      "mutated_line": "USE[nq] = 0",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 0\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "USE[nq] = 1",
      "mutated_line": "USE[nq] = -1",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = -1\n    return USE.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "EDGELIST = [[] for _ in range(N + 1)]",
      "mutated_line": "for (i, (x, y, w)) in enumerate(edges):",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N - 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "EDGELIST = [[] for _ in range(N + 1)]",
      "mutated_line": "for (i, (x, y, w)) in enumerate(edges):",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N * 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "Group = [i for i in range(N + 1)]",
      "mutated_line": "",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N - 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "Group = [i for i in range(N + 1)]",
      "mutated_line": "",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N * 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if USE[nq] == 1:",
      "mutated_line": "if USE[nq] == 2:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 2:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if USE[nq] == 1:",
      "mutated_line": "if USE[nq] == 0:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 0:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if USE[nq] == 1:",
      "mutated_line": "if USE[nq] == 0:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 0:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "if USE[nq] == 1:",
      "mutated_line": "if USE[nq] == -1:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == -1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if edges[e][2] <= w:",
      "mutated_line": "if edges[e][2] < w:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] < w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if edges[e][2] <= w:",
      "mutated_line": "if edges[e][2] > w:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] > w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if edges[e][2] <= w:",
      "mutated_line": "if edges[e][2] == w:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] == w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges.sort(key=lambda x: x[2])",
      "mutated_line": "edges.sort(key=lambda x: x[3])",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[3])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges.sort(key=lambda x: x[2])",
      "mutated_line": "edges.sort(key=lambda x: x[1])",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[1])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges.sort(key=lambda x: x[2])",
      "mutated_line": "edges.sort(key=lambda x: x[0])",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[0])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges.sort(key=lambda x: x[2])",
      "mutated_line": "edges.sort(key=lambda x: x[1])",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[1])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "edges.sort(key=lambda x: x[2])",
      "mutated_line": "edges.sort(key=lambda x: x[-2])",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[-2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGELIST = [[] for _ in range(N + 1)]",
      "mutated_line": "for (i, (x, y, w)) in enumerate(edges):",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 2)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGELIST = [[] for _ in range(N + 1)]",
      "mutated_line": "for (i, (x, y, w)) in enumerate(edges):",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 0)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGELIST = [[] for _ in range(N + 1)]",
      "mutated_line": "for (i, (x, y, w)) in enumerate(edges):",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 0)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "EDGELIST = [[] for _ in range(N + 1)]",
      "mutated_line": "for (i, (x, y, w)) in enumerate(edges):",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + -1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "Group = [i for i in range(N + 1)]",
      "mutated_line": "",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 2)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "Group = [i for i in range(N + 1)]",
      "mutated_line": "",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 0)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "Group = [i for i in range(N + 1)]",
      "mutated_line": "",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 0)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "Group = [i for i in range(N + 1)]",
      "mutated_line": "",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + -1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if edges[e][2] <= w:",
      "mutated_line": "if edges[e][3] <= w:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][3] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if edges[e][2] <= w:",
      "mutated_line": "if edges[e][1] <= w:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][1] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if edges[e][2] <= w:",
      "mutated_line": "if edges[e][0] <= w:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][0] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if edges[e][2] <= w:",
      "mutated_line": "if edges[e][1] <= w:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][1] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if edges[e][2] <= w:",
      "mutated_line": "if edges[e][-2] <= w:",
      "code": "def minimum_edges_to_remove(N, M, X, edges):\n    from collections import deque\n    edges.sort(key=lambda x: x[2])\n    EDGELIST = [[] for _ in range(N + 1)]\n    for (i, (x, y, w)) in enumerate(edges):\n        EDGELIST[x].append(i)\n        EDGELIST[y].append(i)\n    Group = [i for i in range(N + 1)]\n\n    def find(x):\n        while Group[x] != x:\n            x = Group[x]\n        return x\n\n    def Union(x, y):\n        if find(x) != find(y):\n            Group[find(y)] = Group[find(x)] = min(find(y), find(x))\n    USE = [0] * M\n    WEIGHTSUM = [0] + [X[i] for i in range(N)]\n    QUE = deque()\n    for (i, (x, y, w)) in enumerate(edges):\n        if find(x) != find(y):\n            WEIGHTSUM[find(x)] = WEIGHTSUM[find(y)] = WEIGHTSUM[find(x)] + WEIGHTSUM[find(y)]\n            Union(x, y)\n        if w <= WEIGHTSUM[find(x)]:\n            QUE.append(i)\n    while QUE:\n        q = QUE.pop()\n        (x, y, w) = edges[q]\n        NQUE = deque([q])\n        while NQUE:\n            nq = NQUE.pop()\n            if USE[nq] == 1:\n                continue\n            (x, y, _) = edges[nq]\n            for e in EDGELIST[x] + EDGELIST[y]:\n                if edges[e][-2] <= w:\n                    NQUE.append(e)\n            USE[nq] = 1\n    return USE.count(0)"
    }
  ]
}