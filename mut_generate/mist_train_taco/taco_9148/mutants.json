{
  "task_id": "taco_9148",
  "entry_point": "count_valid_subsegments",
  "mutant_count": 130,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "n1_head = 0",
      "mutated_line": "n1_head = 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 1\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "n1_head = 0",
      "mutated_line": "n1_head = -1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = -1\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "n1_head = 0",
      "mutated_line": "n1_head = 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 1\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 1\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = -1\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 1\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n1 = ais.count(1)",
      "mutated_line": "n1 = ais.count(2)",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(2)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n1 = ais.count(1)",
      "mutated_line": "n1 = ais.count(0)",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(0)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n1 = ais.count(1)",
      "mutated_line": "n1 = ais.count(0)",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(0)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "n1 = ais.count(1)",
      "mutated_line": "n1 = ais.count(-1)",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(-1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "one_serie = [0 for _ in range(n)]",
      "mutated_line": "one_serie = [1 for _ in range(n)]",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [1 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "one_serie = [0 for _ in range(n)]",
      "mutated_line": "one_serie = [-1 for _ in range(n)]",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [-1 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "one_serie = [0 for _ in range(n)]",
      "mutated_line": "one_serie = [1 for _ in range(n)]",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [1 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if ais[i] == 1:",
      "mutated_line": "if ais[i] != 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] != 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = 1",
      "mutated_line": "p = 2",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 2\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 0\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = 1",
      "mutated_line": "p = 0",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 0\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "p = 1",
      "mutated_line": "p = -1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = -1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 1\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = -1\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 1\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 0 or ais[i - 1] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 or ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "n1_head += 1",
      "mutated_line": "n1_head -= 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head -= 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "n1_tail = n1 - n1_head",
      "mutated_line": "n1_tail = n1 + n1_head",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 + n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "n1_tail = n1 - n1_head",
      "mutated_line": "n1_tail = n1 * n1_head",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 * n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while j < n:",
      "mutated_line": "while j <= n:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j <= n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while j < n:",
      "mutated_line": "while j >= n:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j >= n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "while j < n:",
      "mutated_line": "while j != n:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j != n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if ais[i] == 1:",
      "mutated_line": "if ais[i] == 2:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 2:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if ais[i] == 1:",
      "mutated_line": "if ais[i] == 0:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 0:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if ais[i] == 1:",
      "mutated_line": "if ais[i] == 0:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 0:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if ais[i] == 1:",
      "mutated_line": "if ais[i] == -1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == -1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) - 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) - 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) * 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) * 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i >= 0 and ais[i - 1] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i >= 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i <= 0 and ais[i - 1] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i <= 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i != 0 and ais[i - 1] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i != 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 0 and ais[i - 1] != 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] != 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "n1_head += 1",
      "mutated_line": "n1_head += 2",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 2\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "n1_head += 1",
      "mutated_line": "n1_head += 0",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 0\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "n1_head += 1",
      "mutated_line": "n1_head += 0",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 0\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "n1_head += 1",
      "mutated_line": "n1_head += -1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += -1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if ais[j] == 1:",
      "mutated_line": "if ais[j] != 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] != 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "n1_tail -= one_serie[j]",
      "mutated_line": "n1_tail += one_serie[j]",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail += one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 27,
      "original_line": "s += one_serie[j]",
      "mutated_line": "s -= one_serie[j]",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s -= one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "j += one_serie[j]",
      "mutated_line": "j -= one_serie[j]",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j -= one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "p *= ais[j]",
      "mutated_line": "p /= ais[j]",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p /= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "s += ais[j]",
      "mutated_line": "s -= ais[j]",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s -= ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "j += 1",
      "mutated_line": "j -= 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j -= 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 2",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 2\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 0",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 0\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 0",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 0\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + -1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + -1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 1 and ais[i - 1] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 1 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > -1 and ais[i - 1] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > -1 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 1 and ais[i - 1] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 1 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 0 and ais[i - 1] == 2:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 2:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 0 and ais[i - 1] == 0:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 0:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 0 and ais[i - 1] == 0:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 0:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 0 and ais[i - 1] == -1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == -1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ais[j] == 1:",
      "mutated_line": "if ais[j] == 2:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 2:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ais[j] == 1:",
      "mutated_line": "if ais[j] == 0:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 0:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ais[j] == 1:",
      "mutated_line": "if ais[j] == 0:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 0:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "if ais[j] == 1:",
      "mutated_line": "if ais[j] == -1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == -1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 0 or 1 <= p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 or 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 25,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count -= 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "if p == s * k:",
      "mutated_line": "if p != s * k:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p != s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count -= 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "j += 1",
      "mutated_line": "j += 2",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 2\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 0\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "j += 1",
      "mutated_line": "j += 0",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 0\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "j += 1",
      "mutated_line": "j += -1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += -1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i != n - 1 else one_serie[i + 1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i != n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (1 if i == n - 1 else one_serie[i + 1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (1 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (-1 if i == n - 1 else one_serie[i + 1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (-1 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (1 if i == n - 1 else one_serie[i + 1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (1 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 0 and ais[i + 1] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i + 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 0 and ais[i * 1] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i * 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k != 0 and 1 <= p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k != 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 0 and 1 < p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 < p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 0 and 1 > p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 > p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 0 and 1 == p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 == p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 2\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 0\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 0\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += -1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if p == s * k:",
      "mutated_line": "if p == s / k:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s / k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if p == s * k:",
      "mutated_line": "if p == s + k:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s + k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "if p == s * k:",
      "mutated_line": "if p == s ** k:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s ** k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 2\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 0\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 0\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += -1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif p > (s + n1_tail) * k:",
      "mutated_line": "elif p >= (s + n1_tail) * k:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p >= (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif p > (s + n1_tail) * k:",
      "mutated_line": "elif p <= (s + n1_tail) * k:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p <= (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "elif p > (s + n1_tail) * k:",
      "mutated_line": "elif p != (s + n1_tail) * k:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p != (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n + 1 else one_serie[i + 1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n + 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n * 1 else one_serie[i + 1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n * 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i - 1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i - 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i * 1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i * 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 0 and ais[i - 2] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 2] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 0 and ais[i - 0] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 0] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 0 and ais[i - 0] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 0] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "if i > 0 and ais[i - 1] == 1:",
      "mutated_line": "if i > 0 and ais[i - -1] == 1:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - -1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p * k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p * k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p + k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p + k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 1 and 1 <= p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 1 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == -1 and 1 <= p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == -1 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 1 and 1 <= p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 1 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 0 and 2 <= p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 2 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 0 and 0 <= p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 0 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 0 and 0 <= p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 0 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 0 and -1 <= p // k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and -1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 0 and 1 <= p // k + s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k + s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 0 and 1 <= p // k * s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k * s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "elif p > (s + n1_tail) * k:",
      "mutated_line": "elif p > (s + n1_tail) / k:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) / k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "elif p > (s + n1_tail) * k:",
      "mutated_line": "elif p > s + n1_tail + k:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > s + n1_tail + k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "elif p > (s + n1_tail) * k:",
      "mutated_line": "elif p > (s + n1_tail) ** k:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) ** k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 2 else one_serie[i + 1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 2 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 0 else one_serie[i + 1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 0 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 0 else one_serie[i + 1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 0 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - -1 else one_serie[i + 1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - -1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 2]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 2]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 0]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 0]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 0]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 0]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1",
      "mutated_line": "one_serie[i] = (0 if i == n - 1 else one_serie[i + -1]) + 1",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + -1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 0 and 1 <= p / k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p / k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "if p % k == 0 and 1 <= p // k - s <= one_serie[j]:",
      "mutated_line": "if p % k == 0 and 1 <= p * k - s <= one_serie[j]:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p * k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s + n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "elif p > (s + n1_tail) * k:",
      "mutated_line": "elif p > (s - n1_tail) * k:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > (s - n1_tail) * k:\n                    break\n                j += 1\n    return count"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "elif p > (s + n1_tail) * k:",
      "mutated_line": "elif p > s * n1_tail * k:",
      "code": "def count_valid_subsegments(n, k, ais):\n    n1 = ais.count(1)\n    one_serie = [0 for _ in range(n)]\n    for i in reversed(range(n)):\n        if ais[i] == 1:\n            one_serie[i] = (0 if i == n - 1 else one_serie[i + 1]) + 1\n    n1_head = 0\n    count = 0\n    for i in range(n):\n        p = 1\n        s = 0\n        if i > 0 and ais[i - 1] == 1:\n            n1_head += 1\n        n1_tail = n1 - n1_head\n        j = i\n        while j < n:\n            if ais[j] == 1:\n                if p % k == 0 and 1 <= p // k - s <= one_serie[j]:\n                    count += 1\n                n1_tail -= one_serie[j]\n                s += one_serie[j]\n                j += one_serie[j]\n            else:\n                p *= ais[j]\n                s += ais[j]\n                if p == s * k:\n                    count += 1\n                elif p > s * n1_tail * k:\n                    break\n                j += 1\n    return count"
    }
  ]
}