{
  "task_id": "taco_797",
  "entry_point": "calculate_inversion_sum",
  "mutant_count": 79,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 - 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 * 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) / 2",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) / 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) * 2",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) * 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "x -= 1",
      "mutated_line": "x += 1",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x += 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "y -= 1",
      "mutated_line": "y += 1",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y += 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD",
      "mutated_line": "ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) * MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) * MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD",
      "mutated_line": "ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) + MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) + MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ans = (ans << q) % MOD",
      "mutated_line": "ans = (ans << q) * MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) * MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "ans = (ans << q) % MOD",
      "mutated_line": "ans = (ans << q) + MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) + MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 * 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 + 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 8\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 6\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 0\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 1\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + -7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD - 1) // 2",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD - 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = MOD * 1 // 2",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = MOD * 1 // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) // 3",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 3\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) // 1",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 1\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) // 0",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 0\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) // 1",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 1\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 1) // -2",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // -2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mat = [[0] * n for _ in range(n)]",
      "mutated_line": "mat = [[0] / n for _ in range(n)]",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] / n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mat = [[0] * n for _ in range(n)]",
      "mutated_line": "mat = [[0] + n for _ in range(n)]",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] + n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "mat = [[0] * n for _ in range(n)]",
      "mutated_line": "mat = [[0] ** n for _ in range(n)]",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] ** n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x -= 1",
      "mutated_line": "x -= 2",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 2\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 0\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x -= 1",
      "mutated_line": "x -= 0",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 0\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x -= 1",
      "mutated_line": "x -= -1",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= -1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y -= 1",
      "mutated_line": "y -= 2",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 2\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 0\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y -= 1",
      "mutated_line": "y -= 0",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 0\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y -= 1",
      "mutated_line": "y -= -1",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= -1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD",
      "mutated_line": "mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 * MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 * MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD",
      "mutated_line": "mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 + MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 + MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 11 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 9 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 0 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 1 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = -10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 10 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 8 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 0 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 1 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** -9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 2) // 2",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 2) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 0) // 2",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 0) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + 0) // 2",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 0) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "INV2 = (MOD + 1) // 2",
      "mutated_line": "INV2 = (MOD + -1) // 2",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + -1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD",
      "mutated_line": "mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) / INV2 % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) / INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD",
      "mutated_line": "mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x] + INV2) % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x] + INV2) % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD",
      "mutated_line": "mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) ** INV2 % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) ** INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "if i == x or i == y:",
      "mutated_line": "if i == x and i == y:",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x and i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD",
      "mutated_line": "mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 * MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 * MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD",
      "mutated_line": "mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 + MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 + MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD",
      "mutated_line": "mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 * MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 * MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD",
      "mutated_line": "mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 + MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 + MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mat = [[0] * n for _ in range(n)]",
      "mutated_line": "mat = [[1] * n for _ in range(n)]",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mat = [[0] * n for _ in range(n)]",
      "mutated_line": "mat = [[-1] * n for _ in range(n)]",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[-1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mat = [[0] * n for _ in range(n)]",
      "mutated_line": "mat = [[1] * n for _ in range(n)]",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[1] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "mat[i][j] = int(A[i] < A[j])",
      "mutated_line": "mat[i][j] = int(A[i] <= A[j])",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] <= A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "mat[i][j] = int(A[i] < A[j])",
      "mutated_line": "mat[i][j] = int(A[i] >= A[j])",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] >= A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "mat[i][j] = int(A[i] < A[j])",
      "mutated_line": "mat[i][j] = int(A[i] != A[j])",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] != A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD",
      "mutated_line": "mat[x][y] = mat[y][x] = (mat[x][y] - mat[y][x]) * INV2 % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] - mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD",
      "mutated_line": "mat[x][y] = mat[y][x] = mat[x][y] * mat[y][x] * INV2 % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = mat[x][y] * mat[y][x] * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if i == x or i == y:",
      "mutated_line": "if i != x or i == y:",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i != x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if i == x or i == y:",
      "mutated_line": "if i == x or i != y:",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i != y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD",
      "mutated_line": "mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) / INV2 % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) / INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD",
      "mutated_line": "mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i] + INV2) % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i] + INV2) % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD",
      "mutated_line": "mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) ** INV2 % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) ** INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD",
      "mutated_line": "mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) / INV2 % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) / INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD",
      "mutated_line": "mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y] + INV2) % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y] + INV2) % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD",
      "mutated_line": "mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) ** INV2 % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) ** INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD",
      "mutated_line": "mat[x][i] = mat[y][i] = (mat[x][i] - mat[y][i]) * INV2 % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] - mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD",
      "mutated_line": "mat[x][i] = mat[y][i] = mat[x][i] * mat[y][i] * INV2 % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = mat[x][i] * mat[y][i] * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD",
      "mutated_line": "mat[i][x] = mat[i][y] = (mat[i][x] - mat[i][y]) * INV2 % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = (mat[i][x] - mat[i][y]) * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "mat[i][x] = mat[i][y] = (mat[i][x] + mat[i][y]) * INV2 % MOD",
      "mutated_line": "mat[i][x] = mat[i][y] = mat[i][x] * mat[i][y] * INV2 % MOD",
      "code": "def calculate_inversion_sum(n, q, A, operations):\n    MOD = 10 ** 9 + 7\n    INV2 = (MOD + 1) // 2\n    mat = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            mat[i][j] = int(A[i] < A[j])\n    for (x, y) in operations:\n        x -= 1\n        y -= 1\n        mat[x][y] = mat[y][x] = (mat[x][y] + mat[y][x]) * INV2 % MOD\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            mat[x][i] = mat[y][i] = (mat[x][i] + mat[y][i]) * INV2 % MOD\n            mat[i][x] = mat[i][y] = mat[i][x] * mat[i][y] * INV2 % MOD\n    ans = sum((sum(row[:i]) for (i, row) in enumerate(mat))) % MOD\n    ans = (ans << q) % MOD\n    return ans"
    }
  ]
}