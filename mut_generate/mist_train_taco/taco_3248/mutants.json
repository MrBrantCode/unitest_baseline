{
  "task_id": "taco_3248",
  "entry_point": "find_min_insertions",
  "mutant_count": 86,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "hmap[c] += 1",
      "mutated_line": "hmap[c] -= 1",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] -= 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 1\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "j = 0",
      "mutated_line": "j = -1",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = -1\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 1\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if len(board) == 0:",
      "mutated_line": "if len(board) != 0:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) != 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 1\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j = 0",
      "mutated_line": "j = -1",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = -1\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "j = 0",
      "mutated_line": "j = 1",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 1\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "hmap[c] += 1",
      "mutated_line": "hmap[c] += 2",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 2\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "hmap[c] += 1",
      "mutated_line": "hmap[c] += 0",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 0\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "hmap[c] += 1",
      "mutated_line": "hmap[c] += 0",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 0\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "hmap[c] += 1",
      "mutated_line": "hmap[c] += -1",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += -1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "return -1 if res == float('inf') else res",
      "mutated_line": "return -1 if res != float('inf') else res",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res != float('inf') else res"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "return -1 if res == float('inf') else res",
      "mutated_line": "return +1 if res == float('inf') else res",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return +1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(len(board) + 1):",
      "mutated_line": "for i in range(len(board) - 1):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) - 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(len(board) + 1):",
      "mutated_line": "for i in range(len(board) * 1):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) * 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "LCR",
      "lineno": 7,
      "original_line": "if i < len(board) and board[i] == board[j]:",
      "mutated_line": "if i < len(board) or board[i] == board[j]:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) or board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i - j >= 3:",
      "mutated_line": "if i - j > 3:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j > 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i - j >= 3:",
      "mutated_line": "if i - j < 3:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j < 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "if i - j >= 3:",
      "mutated_line": "if i - j == 3:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j == 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(board) == 0:",
      "mutated_line": "if len(board) == 1:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 1:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(board) == 0:",
      "mutated_line": "if len(board) == -1:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == -1:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "if len(board) == 0:",
      "mutated_line": "if len(board) == 1:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 1:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 1\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return -1\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 1\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt = float('inf')",
      "mutated_line": "cnt = float('')",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(len(board) + 1):",
      "mutated_line": "for i in range(len(board) - 1):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) - 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "for i in range(len(board) + 1):",
      "mutated_line": "for i in range(len(board) * 1):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) * 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if i < len(board) and board[i] == board[j]:",
      "mutated_line": "if i < len(board) or board[i] == board[j]:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) or board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "need = 3 - (i - j)",
      "mutated_line": "need = 3 + (i - j)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 + (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "need = 3 - (i - j)",
      "mutated_line": "need = 3 * (i - j)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 * (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if hmap[board[j]] >= need:",
      "mutated_line": "if hmap[board[j]] > need:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] > need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if hmap[board[j]] >= need:",
      "mutated_line": "if hmap[board[j]] < need:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] < need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if hmap[board[j]] >= need:",
      "mutated_line": "if hmap[board[j]] == need:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] == need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ASR",
      "lineno": 26,
      "original_line": "hmap[board[j]] -= need",
      "mutated_line": "hmap[board[j]] += need",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] += need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "hmap[board[j]] += need",
      "mutated_line": "hmap[board[j]] -= need",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] -= need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1 if res == float('inf') else res",
      "mutated_line": "return -2 if res == float('inf') else res",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -2 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1 if res == float('inf') else res",
      "mutated_line": "return -0 if res == float('inf') else res",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -0 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1 if res == float('inf') else res",
      "mutated_line": "return -0 if res == float('inf') else res",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -0 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1 if res == float('inf') else res",
      "mutated_line": "return --1 if res == float('inf') else res",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return --1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(len(board) + 1):",
      "mutated_line": "for i in range(len(board) + 2):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 2):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(len(board) + 1):",
      "mutated_line": "for i in range(len(board) + 0):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 0):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(len(board) + 1):",
      "mutated_line": "for i in range(len(board) + 0):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 0):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(len(board) + 1):",
      "mutated_line": "for i in range(len(board) + -1):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + -1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i < len(board) and board[i] == board[j]:",
      "mutated_line": "if i <= len(board) and board[i] == board[j]:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i <= len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i < len(board) and board[i] == board[j]:",
      "mutated_line": "if i >= len(board) and board[i] == board[j]:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i >= len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i < len(board) and board[i] == board[j]:",
      "mutated_line": "if i != len(board) and board[i] == board[j]:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i != len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if i < len(board) and board[i] == board[j]:",
      "mutated_line": "if i < len(board) and board[i] != board[j]:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] != board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if i - j >= 3:",
      "mutated_line": "if i + j >= 3:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i + j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "if i - j >= 3:",
      "mutated_line": "if i * j >= 3:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i * j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i - j >= 3:",
      "mutated_line": "if i - j >= 4:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 4:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i - j >= 3:",
      "mutated_line": "if i - j >= 2:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 2:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i - j >= 3:",
      "mutated_line": "if i - j >= 0:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 0:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i - j >= 3:",
      "mutated_line": "if i - j >= 1:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 1:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "if i - j >= 3:",
      "mutated_line": "if i - j >= -3:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= -3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(len(board) + 1):",
      "mutated_line": "for i in range(len(board) + 2):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 2):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(len(board) + 1):",
      "mutated_line": "for i in range(len(board) + 0):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 0):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(len(board) + 1):",
      "mutated_line": "for i in range(len(board) + 0):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 0):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "for i in range(len(board) + 1):",
      "mutated_line": "for i in range(len(board) + -1):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + -1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i < len(board) and board[i] == board[j]:",
      "mutated_line": "if i <= len(board) and board[i] == board[j]:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i <= len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i < len(board) and board[i] == board[j]:",
      "mutated_line": "if i >= len(board) and board[i] == board[j]:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i >= len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i < len(board) and board[i] == board[j]:",
      "mutated_line": "if i != len(board) and board[i] == board[j]:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i != len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if i < len(board) and board[i] == board[j]:",
      "mutated_line": "if i < len(board) and board[i] != board[j]:",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] != board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "need = 3 - (i - j)",
      "mutated_line": "need = 4 - (i - j)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 4 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "need = 3 - (i - j)",
      "mutated_line": "need = 2 - (i - j)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 2 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "need = 3 - (i - j)",
      "mutated_line": "need = 0 - (i - j)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 0 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "need = 3 - (i - j)",
      "mutated_line": "need = 1 - (i - j)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 1 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "need = 3 - (i - j)",
      "mutated_line": "need = -3 - (i - j)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = -3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "need = 3 - (i - j)",
      "mutated_line": "need = 3 - (i + j)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i + j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "need = 3 - (i - j)",
      "mutated_line": "need = 3 - i * j",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - i * j\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if res != float('inf'):",
      "mutated_line": "if res == float('inf'):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res == float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "return -1 if res == float('inf') else res",
      "mutated_line": "return -1 if res == float('') else res",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('') else res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return remove_consecutive(board[0:j] + board[i:])",
      "mutated_line": "return remove_consecutive(board[0:j] - board[i:])",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] - board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return remove_consecutive(board[0:j] + board[i:])",
      "mutated_line": "return remove_consecutive(board[0:j] * board[i:])",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] * board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res = helper(board[0:j] + board[i:], hmap)",
      "mutated_line": "res = helper(board[0:j] - board[i:], hmap)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] - board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "res = helper(board[0:j] + board[i:], hmap)",
      "mutated_line": "res = helper(board[0:j] * board[i:], hmap)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] * board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if res != float('inf'):",
      "mutated_line": "if res != float(''):",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float(''):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "cnt = min(cnt, res + need)",
      "mutated_line": "cnt = min(cnt, res - need)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res - need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "cnt = min(cnt, res + need)",
      "mutated_line": "cnt = min(cnt, res * need)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res * need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return remove_consecutive(board[0:j] + board[i:])",
      "mutated_line": "return remove_consecutive(board[1:j] + board[i:])",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[1:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return remove_consecutive(board[0:j] + board[i:])",
      "mutated_line": "return remove_consecutive(board[-1:j] + board[i:])",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[-1:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return remove_consecutive(board[0:j] + board[i:])",
      "mutated_line": "return remove_consecutive(board[1:j] + board[i:])",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[1:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[0:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res = helper(board[0:j] + board[i:], hmap)",
      "mutated_line": "res = helper(board[1:j] + board[i:], hmap)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[1:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res = helper(board[0:j] + board[i:], hmap)",
      "mutated_line": "res = helper(board[-1:j] + board[i:], hmap)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[-1:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "res = helper(board[0:j] + board[i:], hmap)",
      "mutated_line": "res = helper(board[1:j] + board[i:], hmap)",
      "code": "import collections\n\ndef find_min_insertions(board, hand):\n\n    def remove_consecutive(board):\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            if i - j >= 3:\n                return remove_consecutive(board[0:j] + board[i:])\n            else:\n                j = i\n        return board\n\n    def helper(board, hmap):\n        board = remove_consecutive(board)\n        if len(board) == 0:\n            return 0\n        cnt = float('inf')\n        j = 0\n        for i in range(len(board) + 1):\n            if i < len(board) and board[i] == board[j]:\n                continue\n            need = 3 - (i - j)\n            if hmap[board[j]] >= need:\n                hmap[board[j]] -= need\n                res = helper(board[1:j] + board[i:], hmap)\n                if res != float('inf'):\n                    cnt = min(cnt, res + need)\n                hmap[board[j]] += need\n            j = i\n        return cnt\n    hmap = collections.defaultdict(int)\n    for c in hand:\n        hmap[c] += 1\n    res = helper(board, hmap)\n    return -1 if res == float('inf') else res"
    }
  ]
}