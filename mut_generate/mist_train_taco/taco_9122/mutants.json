{
  "task_id": "taco_9122",
  "entry_point": "bfs",
  "mutant_count": 112,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "mark[source] = True",
      "mutated_line": "mark[source] = False",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = False\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 1\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = -1\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 1\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for link in range(2):",
      "mutated_line": "for link in range(3):",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(3):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for link in range(2):",
      "mutated_line": "for link in range(1):",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(1):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for link in range(2):",
      "mutated_line": "for link in range(0):",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(0):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for link in range(2):",
      "mutated_line": "for link in range(1):",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(1):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for link in range(2):",
      "mutated_line": "for link in range(-2):",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(-2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "mark = [False] * n",
      "mutated_line": "mark = [False] / n",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] / n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "mark = [False] * n",
      "mutated_line": "mark = [False] + n",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] + n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "mark = [False] * n",
      "mutated_line": "mark = [False] ** n",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] ** n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 0 or cnt[1][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 or cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res -= (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res -= (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt = [[0 for _ in range(n)] for _ in range(2)]",
      "mutated_line": "cnt = [[1 for _ in range(n)] for _ in range(2)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[1 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt = [[0 for _ in range(n)] for _ in range(2)]",
      "mutated_line": "cnt = [[-1 for _ in range(n)] for _ in range(2)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[-1 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt = [[0 for _ in range(n)] for _ in range(2)]",
      "mutated_line": "cnt = [[1 for _ in range(n)] for _ in range(2)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[1 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "g[c][u - 1].append(v - 1)",
      "mutated_line": "g[c][u - 1].append(v + 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v + 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "g[c][u - 1].append(v - 1)",
      "mutated_line": "g[c][u - 1].append(v * 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v * 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "g[c][v - 1].append(u - 1)",
      "mutated_line": "g[c][v - 1].append(u + 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u + 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "g[c][v - 1].append(u - 1)",
      "mutated_line": "g[c][v - 1].append(u * 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u * 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "LCR",
      "lineno": 30,
      "original_line": "if not mark[u] and len(g[link][u]) > 0:",
      "mutated_line": "if not mark[u] or len(g[link][u]) > 0:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] or len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "res += cnt[link][u] * (cnt[link][u] - 1)",
      "mutated_line": "res -= cnt[link][u] * (cnt[link][u] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res -= cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] >= 0 and cnt[1][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] >= 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] <= 0 and cnt[1][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] <= 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] != 0 and cnt[1][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] != 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 0 and cnt[1][i] >= 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] >= 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 0 and cnt[1][i] <= 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] <= 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 0 and cnt[1][i] != 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] != 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 1) / (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) / (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += cnt[0][i] - 1 + (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += cnt[0][i] - 1 + (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 1) ** (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) ** (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "mark[v] = True",
      "mutated_line": "mark[v] = False",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = False\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "g = [[[] for _ in range(n)] for _ in range(2)]",
      "mutated_line": "g = [[[] for _ in range(n)] for _ in range(3)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(3)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "g = [[[] for _ in range(n)] for _ in range(2)]",
      "mutated_line": "g = [[[] for _ in range(n)] for _ in range(1)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(1)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "g = [[[] for _ in range(n)] for _ in range(2)]",
      "mutated_line": "g = [[[] for _ in range(n)] for _ in range(0)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(0)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "g = [[[] for _ in range(n)] for _ in range(2)]",
      "mutated_line": "g = [[[] for _ in range(n)] for _ in range(1)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(1)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "g = [[[] for _ in range(n)] for _ in range(2)]",
      "mutated_line": "g = [[[] for _ in range(n)] for _ in range(-2)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(-2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt = [[0 for _ in range(n)] for _ in range(2)]",
      "mutated_line": "cnt = [[0 for _ in range(n)] for _ in range(3)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(3)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt = [[0 for _ in range(n)] for _ in range(2)]",
      "mutated_line": "cnt = [[0 for _ in range(n)] for _ in range(1)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(1)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt = [[0 for _ in range(n)] for _ in range(2)]",
      "mutated_line": "cnt = [[0 for _ in range(n)] for _ in range(0)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(0)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt = [[0 for _ in range(n)] for _ in range(2)]",
      "mutated_line": "cnt = [[0 for _ in range(n)] for _ in range(1)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(1)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "cnt = [[0 for _ in range(n)] for _ in range(2)]",
      "mutated_line": "cnt = [[0 for _ in range(n)] for _ in range(-2)]",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(-2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "g[c][u - 1].append(v - 1)",
      "mutated_line": "g[c][u - 1].append(v - 2)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 2)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "g[c][u - 1].append(v - 1)",
      "mutated_line": "g[c][u - 1].append(v - 0)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 0)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "g[c][u - 1].append(v - 1)",
      "mutated_line": "g[c][u - 1].append(v - 0)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 0)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "g[c][u - 1].append(v - 1)",
      "mutated_line": "g[c][u - 1].append(v - -1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - -1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "g[c][v - 1].append(u - 1)",
      "mutated_line": "g[c][v - 1].append(u - 2)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 2)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "g[c][v - 1].append(u - 1)",
      "mutated_line": "g[c][v - 1].append(u - 0)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 0)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "g[c][v - 1].append(u - 1)",
      "mutated_line": "g[c][v - 1].append(u - 0)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 0)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "g[c][v - 1].append(u - 1)",
      "mutated_line": "g[c][v - 1].append(u - -1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - -1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "mark = [False] * n",
      "mutated_line": "mark = [True] * n",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [True] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if not mark[u] and len(g[link][u]) > 0:",
      "mutated_line": "if not mark[u] and len(g[link][u]) >= 0:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) >= 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if not mark[u] and len(g[link][u]) > 0:",
      "mutated_line": "if not mark[u] and len(g[link][u]) <= 0:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) <= 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if not mark[u] and len(g[link][u]) > 0:",
      "mutated_line": "if not mark[u] and len(g[link][u]) != 0:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) != 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res += cnt[link][u] * (cnt[link][u] - 1)",
      "mutated_line": "res += cnt[link][u] / (cnt[link][u] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] / (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res += cnt[link][u] * (cnt[link][u] - 1)",
      "mutated_line": "res += cnt[link][u] + (cnt[link][u] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] + (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res += cnt[link][u] * (cnt[link][u] - 1)",
      "mutated_line": "res += cnt[link][u] ** (cnt[link][u] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] ** (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 1 and cnt[1][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 1 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > -1 and cnt[1][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > -1 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 1 and cnt[1][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 1 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 0 and cnt[1][i] > 2:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 2:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 0 and cnt[1][i] > 0:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 0:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 0 and cnt[1][i] > 0:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 0:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 0 and cnt[1][i] > -1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > -1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] + 1) * (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] + 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += cnt[0][i] * 1 * (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += cnt[0][i] * 1 * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 1) * (cnt[1][i] + 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] + 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 1) * (cnt[1][i] * 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] * 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "g[c][u - 1].append(v - 1)",
      "mutated_line": "g[c][u + 1].append(v - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u + 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "g[c][u - 1].append(v - 1)",
      "mutated_line": "g[c][u * 1].append(v - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u * 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "g[c][v - 1].append(u - 1)",
      "mutated_line": "g[c][v + 1].append(u - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v + 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "g[c][v - 1].append(u - 1)",
      "mutated_line": "g[c][v * 1].append(u - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v * 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if not mark[u] and len(g[link][u]) > 0:",
      "mutated_line": "if not mark[u] and len(g[link][u]) > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 1:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if not mark[u] and len(g[link][u]) > 0:",
      "mutated_line": "if not mark[u] and len(g[link][u]) > -1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > -1:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "if not mark[u] and len(g[link][u]) > 0:",
      "mutated_line": "if not mark[u] and len(g[link][u]) > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 1:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res += cnt[link][u] * (cnt[link][u] - 1)",
      "mutated_line": "res += cnt[link][u] * (cnt[link][u] + 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] + 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "res += cnt[link][u] * (cnt[link][u] - 1)",
      "mutated_line": "res += cnt[link][u] * (cnt[link][u] * 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] * 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 2) * (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 2) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 0) * (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 0) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 0) * (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 0) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - -1) * (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - -1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 2)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 2)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 0)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 0)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 0)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - -1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - -1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "g[c][u - 1].append(v - 1)",
      "mutated_line": "g[c][u - 2].append(v - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 2].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "g[c][u - 1].append(v - 1)",
      "mutated_line": "g[c][u - 0].append(v - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 0].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "g[c][u - 1].append(v - 1)",
      "mutated_line": "g[c][u - 0].append(v - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 0].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "g[c][u - 1].append(v - 1)",
      "mutated_line": "g[c][u - -1].append(v - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - -1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "g[c][v - 1].append(u - 1)",
      "mutated_line": "g[c][v - 2].append(u - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 2].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "g[c][v - 1].append(u - 1)",
      "mutated_line": "g[c][v - 0].append(u - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 0].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "g[c][v - 1].append(u - 1)",
      "mutated_line": "g[c][v - 0].append(u - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 0].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "g[c][v - 1].append(u - 1)",
      "mutated_line": "g[c][v - -1].append(u - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - -1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res += cnt[link][u] * (cnt[link][u] - 1)",
      "mutated_line": "res += cnt[link][u] * (cnt[link][u] - 2)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 2)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res += cnt[link][u] * (cnt[link][u] - 1)",
      "mutated_line": "res += cnt[link][u] * (cnt[link][u] - 0)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 0)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res += cnt[link][u] * (cnt[link][u] - 1)",
      "mutated_line": "res += cnt[link][u] * (cnt[link][u] - 0)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 0)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "res += cnt[link][u] * (cnt[link][u] - 1)",
      "mutated_line": "res += cnt[link][u] * (cnt[link][u] - -1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - -1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[1][i] > 0 and cnt[1][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[1][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[-1][i] > 0 and cnt[1][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[-1][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[1][i] > 0 and cnt[1][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[1][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 0 and cnt[2][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[2][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 0 and cnt[0][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[0][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 0 and cnt[0][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[0][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if cnt[0][i] > 0 and cnt[1][i] > 1:",
      "mutated_line": "if cnt[0][i] > 0 and cnt[-1][i] > 1:",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[-1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[1][i] - 1) * (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[1][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[-1][i] - 1) * (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[-1][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[1][i] - 1) * (cnt[1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[1][i] - 1) * (cnt[1][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 1) * (cnt[2][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[2][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 1) * (cnt[0][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[0][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 1) * (cnt[0][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[0][i] - 1)\n    return res"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "res += (cnt[0][i] - 1) * (cnt[1][i] - 1)",
      "mutated_line": "res += (cnt[0][i] - 1) * (cnt[-1][i] - 1)",
      "code": "from collections import deque\n\ndef bfs(source, graph, mark, fcount):\n    visited = [source]\n    q = deque()\n    mark[source] = True\n    q.append(source)\n    while q:\n        u = q.popleft()\n        for v in graph[u]:\n            if not mark[v]:\n                mark[v] = True\n                visited.append(v)\n                q.append(v)\n    for u in visited:\n        fcount[u] = len(visited)\n\ndef count_valid_pairs(n, edges):\n    g = [[[] for _ in range(n)] for _ in range(2)]\n    cnt = [[0 for _ in range(n)] for _ in range(2)]\n    for (u, v, c) in edges:\n        g[c][u - 1].append(v - 1)\n        g[c][v - 1].append(u - 1)\n    res = 0\n    for link in range(2):\n        mark = [False] * n\n        for u in range(n):\n            if not mark[u] and len(g[link][u]) > 0:\n                bfs(u, g[link], mark, cnt[link])\n                res += cnt[link][u] * (cnt[link][u] - 1)\n    for i in range(n):\n        if cnt[0][i] > 0 and cnt[1][i] > 1:\n            res += (cnt[0][i] - 1) * (cnt[-1][i] - 1)\n    return res"
    }
  ]
}