{
  "task_id": "taco_3030",
  "entry_point": "divisors",
  "mutant_count": 73,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 2:",
      "mutated_line": "if n <= 2:",
      "code": "import math\n\ndef divisors(n):\n    if n <= 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 2:",
      "mutated_line": "if n >= 2:",
      "code": "import math\n\ndef divisors(n):\n    if n >= 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if n < 2:",
      "mutated_line": "if n != 2:",
      "code": "import math\n\ndef divisors(n):\n    if n != 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if nn * nn == n:",
      "mutated_line": "if nn * nn != n:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn != n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "nn -= 1",
      "mutated_line": "nn += 1",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn += 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "S = sum(A) - M",
      "mutated_line": "S = sum(A) + M",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) + M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "S = sum(A) - M",
      "mutated_line": "S = sum(A) * M",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) * M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "R = 1",
      "mutated_line": "R = 2",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 2\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "R = 1",
      "mutated_line": "R = 0",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 0\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "R = 1",
      "mutated_line": "R = 0",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 0\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "R = 1",
      "mutated_line": "R = -1",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = -1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 3:",
      "code": "import math\n\ndef divisors(n):\n    if n < 3:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 1:",
      "code": "import math\n\ndef divisors(n):\n    if n < 1:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 0:",
      "code": "import math\n\ndef divisors(n):\n    if n < 0:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 2:",
      "mutated_line": "if n < 1:",
      "code": "import math\n\ndef divisors(n):\n    if n < 1:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if n < 2:",
      "mutated_line": "if n < -2:",
      "code": "import math\n\ndef divisors(n):\n    if n < -2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if nn * nn == n:",
      "mutated_line": "if nn / nn == n:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn / nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if nn * nn == n:",
      "mutated_line": "if nn + nn == n:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn + nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if nn * nn == n:",
      "mutated_line": "if nn ** nn == n:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn ** nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nn -= 1",
      "mutated_line": "nn -= 2",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 2\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nn -= 1",
      "mutated_line": "nn -= 0",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 0\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nn -= 1",
      "mutated_line": "nn -= 0",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 0\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "nn -= 1",
      "mutated_line": "nn -= -1",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= -1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, nn + 1):",
      "mutated_line": "for i in range(3, nn + 1):",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(3, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, nn + 1):",
      "mutated_line": "for i in range(1, nn + 1):",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(1, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, nn + 1):",
      "mutated_line": "for i in range(0, nn + 1):",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(0, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, nn + 1):",
      "mutated_line": "for i in range(1, nn + 1):",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(1, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, nn + 1):",
      "mutated_line": "for i in range(-2, nn + 1):",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(-2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(2, nn + 1):",
      "mutated_line": "for i in range(2, nn - 1):",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn - 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "for i in range(2, nn + 1):",
      "mutated_line": "for i in range(2, nn * 1):",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn * 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i != 0:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i != 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 1\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = -1\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 1\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "s += m",
      "mutated_line": "s -= m",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s -= m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if s == S:",
      "mutated_line": "if s != S:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s != S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, nn + 1):",
      "mutated_line": "for i in range(2, nn + 2):",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 2):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, nn + 1):",
      "mutated_line": "for i in range(2, nn + 0):",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 0):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, nn + 1):",
      "mutated_line": "for i in range(2, nn + 0):",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 0):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "for i in range(2, nn + 1):",
      "mutated_line": "for i in range(2, nn + -1):",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + -1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n * i == 0:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n * i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n + i == 0:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n + i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == 1:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 1:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == -1:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == -1:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if n % i == 0:",
      "mutated_line": "if n % i == 1:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 1:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "r.sort(reverse=True)",
      "mutated_line": "r.sort(reverse=False)",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=False)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "A.sort(reverse=True)",
      "mutated_line": "A.sort(reverse=False)",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=False)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if a < p:",
      "mutated_line": "if a <= p:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a <= p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if a < p:",
      "mutated_line": "if a >= p:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a >= p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if a < p:",
      "mutated_line": "if a != p:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a != p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "m = S - s",
      "mutated_line": "m = S + s",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S + s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "m = S - s",
      "mutated_line": "m = S * s",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S * s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if m > a:",
      "mutated_line": "if m >= a:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m >= a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if m > a:",
      "mutated_line": "if m <= a:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m <= a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if m > a:",
      "mutated_line": "if m != a:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m != a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if m * (N - i) < S - s:",
      "mutated_line": "if m * (N - i) <= S - s:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) <= S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if m * (N - i) < S - s:",
      "mutated_line": "if m * (N - i) >= S - s:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) >= S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if m * (N - i) < S - s:",
      "mutated_line": "if m * (N - i) != S - s:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) != S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if s == S:",
      "mutated_line": "if s != S:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s != S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "r.append(n // i)",
      "mutated_line": "r.append(n / i)",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n / i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "r.append(n // i)",
      "mutated_line": "r.append(n * i)",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n * i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "m = p * (a // p)",
      "mutated_line": "m = p / (a // p)",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p / (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "m = p * (a // p)",
      "mutated_line": "m = p + a // p",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p + a // p\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "m = p * (a // p)",
      "mutated_line": "m = p ** (a // p)",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p ** (a // p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if m * (N - i) < S - s:",
      "mutated_line": "if m / (N - i) < S - s:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m / (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if m * (N - i) < S - s:",
      "mutated_line": "if m + (N - i) < S - s:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m + (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if m * (N - i) < S - s:",
      "mutated_line": "if m ** (N - i) < S - s:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m ** (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if m * (N - i) < S - s:",
      "mutated_line": "if m * (N - i) < S + s:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S + s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if m * (N - i) < S - s:",
      "mutated_line": "if m * (N - i) < S * s:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N - i) < S * s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "m = p * (a // p)",
      "mutated_line": "m = p * (a / p)",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a / p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "m = p * (a // p)",
      "mutated_line": "m = p * (a * p)",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a * p)\n            if m * (N - i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if m * (N - i) < S - s:",
      "mutated_line": "if m * (N + i) < S - s:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N + i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "if m * (N - i) < S - s:",
      "mutated_line": "if m * (N * i) < S - s:",
      "code": "import math\n\ndef divisors(n):\n    if n < 2:\n        return []\n    r = [n]\n    nn = int(math.floor(math.sqrt(n)))\n    if nn * nn == n:\n        r.append(nn)\n        nn -= 1\n    for i in range(2, nn + 1):\n        if n % i == 0:\n            r.append(i)\n            r.append(n // i)\n    r.sort(reverse=True)\n    return r\n\ndef find_max_gcd_of_good_sequence(N, M, A):\n    S = sum(A) - M\n    A.sort(reverse=True)\n    R = 1\n    for p in divisors(S):\n        s = 0\n        for i in range(N):\n            a = A[i]\n            if a < p:\n                break\n            m = S - s\n            if m > a:\n                m = p * (a // p)\n            if m * (N * i) < S - s:\n                break\n            s += m\n            if s == S:\n                break\n        if s == S:\n            R = p\n            break\n    return R"
    }
  ]
}