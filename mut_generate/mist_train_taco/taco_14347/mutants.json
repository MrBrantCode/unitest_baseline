{
  "task_id": "taco_14347",
  "entry_point": "max_min_heap_stones",
  "mutant_count": 112,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i < j - 1:",
      "mutated_line": "while i <= j - 1:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i <= j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i < j - 1:",
      "mutated_line": "while i >= j - 1:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i >= j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while i < j - 1:",
      "mutated_line": "while i != j - 1:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i != j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "a[i - 1] += d",
      "mutated_line": "a[i - 1] -= d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] -= d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 2] -= 2 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] -= 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ASR",
      "lineno": 12,
      "original_line": "a[i] -= 3 * d",
      "mutated_line": "a[i] += 3 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] += 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return min(a[0], a[1]) >= m",
      "mutated_line": "return min(a[0], a[1]) > m",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) > m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return min(a[0], a[1]) >= m",
      "mutated_line": "return min(a[0], a[1]) < m",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) < m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ROR",
      "lineno": 13,
      "original_line": "return min(a[0], a[1]) >= m",
      "mutated_line": "return min(a[0], a[1]) == m",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) == m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "while i < j - 1:",
      "mutated_line": "while i < j + 1:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j + 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "while i < j - 1:",
      "mutated_line": "while i < j * 1:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j * 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m = (i + j) // 2",
      "mutated_line": "m = (i + j) / 2",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) / 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m = (i + j) // 2",
      "mutated_line": "m = (i + j) * 2",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) * 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) + 1, 1, -1):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) + 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) * 1, 1, -1):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) * 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - 1, 2, -1):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 2, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - 1, 0, -1):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 0, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - 1, 0, -1):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 0, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - 1, -1, -1):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "UOI",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - 1, 1, +1):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, +1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if a[i] < m:",
      "mutated_line": "if a[i] <= m:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] <= m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if a[i] < m:",
      "mutated_line": "if a[i] >= m:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] >= m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "if a[i] < m:",
      "mutated_line": "if a[i] != m:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] != m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "d = (a[i] - m) // 3",
      "mutated_line": "d = (a[i] - m) / 3",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) / 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "d = (a[i] - m) // 3",
      "mutated_line": "d = (a[i] - m) * 3",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) * 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if og[i] < 3 * d:",
      "mutated_line": "if og[i] <= 3 * d:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] <= 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if og[i] < 3 * d:",
      "mutated_line": "if og[i] >= 3 * d:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] >= 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if og[i] < 3 * d:",
      "mutated_line": "if og[i] != 3 * d:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] != 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 2] += 2 / d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 / d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 2] += 2 + d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 + d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 2] += 2 ** d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 ** d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "a[i] -= 3 * d",
      "mutated_line": "a[i] -= 3 / d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 / d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "a[i] -= 3 * d",
      "mutated_line": "a[i] -= 3 + d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 + d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "a[i] -= 3 * d",
      "mutated_line": "a[i] -= 3 ** d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 ** d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while i < j - 1:",
      "mutated_line": "while i < j - 2:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 2:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while i < j - 1:",
      "mutated_line": "while i < j - 0:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 0:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while i < j - 1:",
      "mutated_line": "while i < j - 0:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 0:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while i < j - 1:",
      "mutated_line": "while i < j - -1:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - -1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m = (i + j) // 2",
      "mutated_line": "m = (i - j) // 2",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i - j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "m = (i + j) // 2",
      "mutated_line": "m = i * j // 2",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = i * j // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m = (i + j) // 2",
      "mutated_line": "m = (i + j) // 3",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 3\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m = (i + j) // 2",
      "mutated_line": "m = (i + j) // 1",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 1\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m = (i + j) // 2",
      "mutated_line": "m = (i + j) // 0",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 0\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m = (i + j) // 2",
      "mutated_line": "m = (i + j) // 1",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 1\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "m = (i + j) // 2",
      "mutated_line": "m = (i + j) // -2",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // -2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "j = m - 1",
      "mutated_line": "j = m + 1",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m + 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "j = m - 1",
      "mutated_line": "j = m * 1",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m * 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - 2, 1, -1):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 2, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - 0, 1, -1):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 0, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - 0, 1, -1):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 0, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - -1, 1, -1):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - -1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - 1, 1, -2):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -2):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - 1, 1, -0):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -0):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - 1, 1, -0):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -0):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for i in range(len(a) - 1, 1, -1):",
      "mutated_line": "for i in range(len(a) - 1, 1, --1):",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, --1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return True\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "d = (a[i] - m) // 3",
      "mutated_line": "d = (a[i] + m) // 3",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] + m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "d = (a[i] - m) // 3",
      "mutated_line": "d = a[i] * m // 3",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = a[i] * m // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d = (a[i] - m) // 3",
      "mutated_line": "d = (a[i] - m) // 4",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 4\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d = (a[i] - m) // 3",
      "mutated_line": "d = (a[i] - m) // 2",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 2\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d = (a[i] - m) // 3",
      "mutated_line": "d = (a[i] - m) // 0",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 0\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d = (a[i] - m) // 3",
      "mutated_line": "d = (a[i] - m) // 1",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 1\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "d = (a[i] - m) // 3",
      "mutated_line": "d = (a[i] - m) // -3",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // -3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if og[i] < 3 * d:",
      "mutated_line": "if og[i] < 3 / d:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 / d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if og[i] < 3 * d:",
      "mutated_line": "if og[i] < 3 + d:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 + d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if og[i] < 3 * d:",
      "mutated_line": "if og[i] < 3 ** d:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 ** d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "d = og[i] // 3",
      "mutated_line": "d = og[i] / 3",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] / 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "d = og[i] // 3",
      "mutated_line": "d = og[i] * 3",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] * 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "a[i - 1] += d",
      "mutated_line": "a[i + 1] += d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i + 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "a[i - 1] += d",
      "mutated_line": "a[i * 1] += d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i * 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i + 2] += 2 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i + 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i * 2] += 2 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i * 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 2] += 3 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 3 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 2] += 1 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 1 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 2] += 0 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 0 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 2] += 1 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 1 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 2] += -2 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += -2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "a[i] -= 3 * d",
      "mutated_line": "a[i] -= 4 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 4 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "a[i] -= 3 * d",
      "mutated_line": "a[i] -= 2 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 2 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "a[i] -= 3 * d",
      "mutated_line": "a[i] -= 0 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 0 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "a[i] -= 3 * d",
      "mutated_line": "a[i] -= 1 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 1 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "a[i] -= 3 * d",
      "mutated_line": "a[i] -= -3 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= -3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j = m - 1",
      "mutated_line": "j = m - 2",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 2\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j = m - 1",
      "mutated_line": "j = m - 0",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 0\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j = m - 1",
      "mutated_line": "j = m - 0",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 0\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "j = m - 1",
      "mutated_line": "j = m - -1",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - -1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if og[i] < 3 * d:",
      "mutated_line": "if og[i] < 4 * d:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 4 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if og[i] < 3 * d:",
      "mutated_line": "if og[i] < 2 * d:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 2 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if og[i] < 3 * d:",
      "mutated_line": "if og[i] < 0 * d:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 0 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if og[i] < 3 * d:",
      "mutated_line": "if og[i] < 1 * d:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 1 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if og[i] < 3 * d:",
      "mutated_line": "if og[i] < -3 * d:",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < -3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "d = og[i] // 3",
      "mutated_line": "d = og[i] // 4",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 4\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "d = og[i] // 3",
      "mutated_line": "d = og[i] // 2",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 2\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "d = og[i] // 3",
      "mutated_line": "d = og[i] // 0",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 0\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "d = og[i] // 3",
      "mutated_line": "d = og[i] // 1",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 1\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "d = og[i] // 3",
      "mutated_line": "d = og[i] // -3",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // -3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a[i - 1] += d",
      "mutated_line": "a[i - 2] += d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 2] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a[i - 1] += d",
      "mutated_line": "a[i - 0] += d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 0] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a[i - 1] += d",
      "mutated_line": "a[i - 0] += d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 0] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a[i - 1] += d",
      "mutated_line": "a[i - -1] += d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - -1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 3] += 2 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 3] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 1] += 2 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 1] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 0] += 2 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 0] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - 1] += 2 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 1] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a[i - 2] += 2 * d",
      "mutated_line": "a[i - -2] += 2 * d",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - -2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(a[0], a[1]) >= m",
      "mutated_line": "return min(a[1], a[1]) >= m",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[1], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(a[0], a[1]) >= m",
      "mutated_line": "return min(a[-1], a[1]) >= m",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[-1], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(a[0], a[1]) >= m",
      "mutated_line": "return min(a[1], a[1]) >= m",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[1], a[1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(a[0], a[1]) >= m",
      "mutated_line": "return min(a[0], a[2]) >= m",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[2]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(a[0], a[1]) >= m",
      "mutated_line": "return min(a[0], a[0]) >= m",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[0]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(a[0], a[1]) >= m",
      "mutated_line": "return min(a[0], a[0]) >= m",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[0]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return min(a[0], a[1]) >= m",
      "mutated_line": "return min(a[0], a[-1]) >= m",
      "code": "def max_min_heap_stones(heaps):\n\n    def feasible(a, m):\n        og = a[:]\n        for i in range(len(a) - 1, 1, -1):\n            if a[i] < m:\n                return False\n            d = (a[i] - m) // 3\n            if og[i] < 3 * d:\n                d = og[i] // 3\n            a[i - 1] += d\n            a[i - 2] += 2 * d\n            a[i] -= 3 * d\n        return min(a[0], a[-1]) >= m\n    (i, j) = (min(heaps), max(heaps))\n    while i < j - 1:\n        m = (i + j) // 2\n        if feasible(heaps[:], m):\n            i = m\n        else:\n            j = m - 1\n    return j if feasible(heaps, j) else i"
    }
  ]
}