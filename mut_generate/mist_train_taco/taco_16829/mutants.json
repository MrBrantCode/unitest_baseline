{
  "task_id": "taco_16829",
  "entry_point": "longest_possible",
  "mutant_count": 22,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return minutes * 60 + seconds",
      "mutated_line": "return minutes * 60 - seconds",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 - seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return minutes * 60 + seconds",
      "mutated_line": "return minutes * 60 * seconds",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 * seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False",
      "mutated_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else True",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else True"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return minutes * 60 + seconds",
      "mutated_line": "return minutes / 60 + seconds",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes / 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return minutes * 60 + seconds",
      "mutated_line": "return minutes + 60 + seconds",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes + 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return minutes * 60 + seconds",
      "mutated_line": "return minutes ** 60 + seconds",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes ** 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]",
      "mutated_line": "candidates = [song for song in songs if calculate_seconds(song['playback']) < playback]",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) < playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]",
      "mutated_line": "candidates = [song for song in songs if calculate_seconds(song['playback']) > playback]",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) > playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]",
      "mutated_line": "candidates = [song for song in songs if calculate_seconds(song['playback']) == playback]",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) == playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False",
      "mutated_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0][''] if candidates else False",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0][''] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return minutes * 60 + seconds",
      "mutated_line": "return minutes * 61 + seconds",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 61 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return minutes * 60 + seconds",
      "mutated_line": "return minutes * 59 + seconds",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 59 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return minutes * 60 + seconds",
      "mutated_line": "return minutes * 0 + seconds",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 0 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return minutes * 60 + seconds",
      "mutated_line": "return minutes * 1 + seconds",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 1 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return minutes * 60 + seconds",
      "mutated_line": "return minutes * -60 + seconds",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * -60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False",
      "mutated_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[1]['title'] if candidates else False",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[1]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False",
      "mutated_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[-1]['title'] if candidates else False",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[-1]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False",
      "mutated_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[1]['title'] if candidates else False",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[1]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "(minutes, seconds) = [int(x) for x in s.split(':')]",
      "mutated_line": "(minutes, seconds) = [int(x) for x in s.split('')]",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split('')]\n        return minutes * 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]",
      "mutated_line": "candidates = [song for song in songs if calculate_seconds(song['']) <= playback]",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False",
      "mutated_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=False)[0]['title'] if candidates else False",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=False)[0]['title'] if candidates else False"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['playback']), reverse=True)[0]['title'] if candidates else False",
      "mutated_line": "return sorted(candidates, key=lambda x: calculate_seconds(x['']), reverse=True)[0]['title'] if candidates else False",
      "code": "def longest_possible(playback, songs):\n\n    def calculate_seconds(s):\n        (minutes, seconds) = [int(x) for x in s.split(':')]\n        return minutes * 60 + seconds\n    candidates = [song for song in songs if calculate_seconds(song['playback']) <= playback]\n    return sorted(candidates, key=lambda x: calculate_seconds(x['']), reverse=True)[0]['title'] if candidates else False"
    }
  ]
}