{
  "task_id": "taco_1003",
  "entry_point": "find_min_max_f_values",
  "mutant_count": 116,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 1\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count = 0",
      "mutated_line": "count = -1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = -1\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "count = 0",
      "mutated_line": "count = 1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 1\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "leavepar = [0] * (n + 1)",
      "mutated_line": "leavepar = [0] / (n + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] / (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "leavepar = [0] * (n + 1)",
      "mutated_line": "leavepar = [0] + (n + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] + (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "leavepar = [0] * (n + 1)",
      "mutated_line": "leavepar = [0] ** (n + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] ** (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = 1",
      "mutated_line": "ans = 2",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 2\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 0\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = 1",
      "mutated_line": "ans = 0",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 0\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "ans = 1",
      "mutated_line": "ans = -1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = -1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "leavepar = [0] * (n + 1)",
      "mutated_line": "leavepar = [0] * (n - 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n - 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "leavepar = [0] * (n + 1)",
      "mutated_line": "leavepar = [0] * (n * 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n * 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if len(graph[i]) == 1:",
      "mutated_line": "if len(graph[i]) != 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) != 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "leavepar[graph[i][0]] += 1",
      "mutated_line": "leavepar[graph[i][0]] -= 1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] -= 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] / (n + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] / (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] + (n + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] + (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] ** (n + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] ** (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ret = bfs(graph, 1)",
      "mutated_line": "ret = bfs(graph, 2)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 2)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ret = bfs(graph, 1)",
      "mutated_line": "ret = bfs(graph, 0)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 0)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ret = bfs(graph, 1)",
      "mutated_line": "ret = bfs(graph, 0)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 0)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "ret = bfs(graph, 1)",
      "mutated_line": "ret = bfs(graph, -1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, -1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(even, odd) = (False, False)",
      "mutated_line": "(even, odd) = (True, False)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (True, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(even, odd) = (False, False)",
      "mutated_line": "(even, odd) = (False, True)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, True)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if ret[i] % 2 == 1:",
      "mutated_line": "if ret[i] % 2 != 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 != 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if ret[i] % 2 == 0:",
      "mutated_line": "if ret[i] % 2 != 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 != 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "LCR",
      "lineno": 44,
      "original_line": "if even == True and odd == True:",
      "mutated_line": "if even == True or odd == True:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True or odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return (ans, n - count - 1)",
      "mutated_line": "return (ans, n - count + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count + 1)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return (ans, n - count - 1)",
      "mutated_line": "return (ans, (n - count) * 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, (n - count) * 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "leavepar = [0] * (n + 1)",
      "mutated_line": "leavepar = [1] * (n + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [1] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "leavepar = [0] * (n + 1)",
      "mutated_line": "leavepar = [-1] * (n + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [-1] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "leavepar = [0] * (n + 1)",
      "mutated_line": "leavepar = [1] * (n + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [1] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "leavepar = [0] * (n + 1)",
      "mutated_line": "leavepar = [0] * (n + 2)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 2)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "leavepar = [0] * (n + 1)",
      "mutated_line": "leavepar = [0] * (n + 0)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 0)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "leavepar = [0] * (n + 1)",
      "mutated_line": "leavepar = [0] * (n + 0)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 0)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "leavepar = [0] * (n + 1)",
      "mutated_line": "leavepar = [0] * (n + -1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + -1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(graph[i]) == 1:",
      "mutated_line": "if len(graph[i]) == 2:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 2:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(graph[i]) == 1:",
      "mutated_line": "if len(graph[i]) == 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 0:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(graph[i]) == 1:",
      "mutated_line": "if len(graph[i]) == 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 0:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if len(graph[i]) == 1:",
      "mutated_line": "if len(graph[i]) == -1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == -1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "leavepar[graph[i][0]] += 1",
      "mutated_line": "leavepar[graph[i][0]] += 2",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 2\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "leavepar[graph[i][0]] += 1",
      "mutated_line": "leavepar[graph[i][0]] += 0",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 0\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "leavepar[graph[i][0]] += 1",
      "mutated_line": "leavepar[graph[i][0]] += 0",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 0\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "leavepar[graph[i][0]] += 1",
      "mutated_line": "leavepar[graph[i][0]] += -1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += -1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if leavepar[graph[i][0]] >= 2:",
      "mutated_line": "if leavepar[graph[i][0]] > 2:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] > 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if leavepar[graph[i][0]] >= 2:",
      "mutated_line": "if leavepar[graph[i][0]] < 2:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] < 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if leavepar[graph[i][0]] >= 2:",
      "mutated_line": "if leavepar[graph[i][0]] == 2:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] == 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count -= 1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count -= 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n - 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n - 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n * 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n * 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if ret[i] % 2 == 1:",
      "mutated_line": "if ret[i] * 2 == 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] * 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "if ret[i] % 2 == 1:",
      "mutated_line": "if ret[i] + 2 == 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] + 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if ret[i] % 2 == 1:",
      "mutated_line": "if ret[i] % 2 == 2:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 2:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if ret[i] % 2 == 1:",
      "mutated_line": "if ret[i] % 2 == 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 0:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if ret[i] % 2 == 1:",
      "mutated_line": "if ret[i] % 2 == 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 0:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if ret[i] % 2 == 1:",
      "mutated_line": "if ret[i] % 2 == -1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == -1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "odd = True",
      "mutated_line": "odd = False",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = False\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if ret[i] % 2 == 0:",
      "mutated_line": "if ret[i] * 2 == 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] * 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "if ret[i] % 2 == 0:",
      "mutated_line": "if ret[i] + 2 == 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] + 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ret[i] % 2 == 0:",
      "mutated_line": "if ret[i] % 2 == 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 1:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ret[i] % 2 == 0:",
      "mutated_line": "if ret[i] % 2 == -1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == -1:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ret[i] % 2 == 0:",
      "mutated_line": "if ret[i] % 2 == 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 1:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "even = True",
      "mutated_line": "even = False",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = False\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if even == True and odd == True:",
      "mutated_line": "if even != True and odd == True:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even != True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 44,
      "original_line": "if even == True and odd == True:",
      "mutated_line": "if even == True and odd != True:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd != True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = 3",
      "mutated_line": "ans = 4",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 4\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = 3",
      "mutated_line": "ans = 2",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 2\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = 3",
      "mutated_line": "ans = 0",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 0\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = 3",
      "mutated_line": "ans = 1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 1\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "ans = 3",
      "mutated_line": "ans = -3",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = -3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return (ans, n - count - 1)",
      "mutated_line": "return (ans, n + count - 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n + count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 48,
      "original_line": "return (ans, n - count - 1)",
      "mutated_line": "return (ans, n * count - 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n * count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return (ans, n - count - 1)",
      "mutated_line": "return (ans, n - count - 2)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 2)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return (ans, n - count - 1)",
      "mutated_line": "return (ans, n - count - 0)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 0)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return (ans, n - count - 1)",
      "mutated_line": "return (ans, n - count - 0)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 0)"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return (ans, n - count - 1)",
      "mutated_line": "return (ans, n - count - -1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - -1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if leavepar[graph[i][0]] >= 2:",
      "mutated_line": "if leavepar[graph[i][0]] >= 3:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 3:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if leavepar[graph[i][0]] >= 2:",
      "mutated_line": "if leavepar[graph[i][0]] >= 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 1:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if leavepar[graph[i][0]] >= 2:",
      "mutated_line": "if leavepar[graph[i][0]] >= 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 0:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if leavepar[graph[i][0]] >= 2:",
      "mutated_line": "if leavepar[graph[i][0]] >= 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 1:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if leavepar[graph[i][0]] >= 2:",
      "mutated_line": "if leavepar[graph[i][0]] >= -2:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= -2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count += 2",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 2\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 0\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count += 0",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 0\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "count += 1",
      "mutated_line": "count += -1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += -1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [1] * (n + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [1] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [-1] * (n + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [-1] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [1] * (n + 1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [1] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 2)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 2)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 0)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 0)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + 0)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 0)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "dist = [0] * (n + 1)",
      "mutated_line": "dist = [0] * (n + -1)",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + -1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if neighbour not in visited:",
      "mutated_line": "if neighbour in visited:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if ret[i] % 2 == 1:",
      "mutated_line": "if ret[i] % 3 == 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 3 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if ret[i] % 2 == 1:",
      "mutated_line": "if ret[i] % 1 == 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 1 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if ret[i] % 2 == 1:",
      "mutated_line": "if ret[i] % 0 == 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 0 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if ret[i] % 2 == 1:",
      "mutated_line": "if ret[i] % 1 == 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 1 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if ret[i] % 2 == 1:",
      "mutated_line": "if ret[i] % -2 == 1:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % -2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ret[i] % 2 == 0:",
      "mutated_line": "if ret[i] % 3 == 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 3 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ret[i] % 2 == 0:",
      "mutated_line": "if ret[i] % 1 == 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 1 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ret[i] % 2 == 0:",
      "mutated_line": "if ret[i] % 0 == 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 0 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ret[i] % 2 == 0:",
      "mutated_line": "if ret[i] % 1 == 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 1 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "if ret[i] % 2 == 0:",
      "mutated_line": "if ret[i] % -2 == 0:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % -2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if even == True and odd == True:",
      "mutated_line": "if even == False and odd == True:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == False and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "if even == True and odd == True:",
      "mutated_line": "if even == True and odd == False:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == False:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "leavepar[graph[i][0]] += 1",
      "mutated_line": "leavepar[graph[i][1]] += 1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][1]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "leavepar[graph[i][0]] += 1",
      "mutated_line": "leavepar[graph[i][-1]] += 1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][-1]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "leavepar[graph[i][0]] += 1",
      "mutated_line": "leavepar[graph[i][1]] += 1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][1]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dist[neighbour] = dist[vertex] + 1",
      "mutated_line": "dist[neighbour] = dist[vertex] - 1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] - 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "dist[neighbour] = dist[vertex] + 1",
      "mutated_line": "dist[neighbour] = dist[vertex] * 1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] * 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if leavepar[graph[i][0]] >= 2:",
      "mutated_line": "if leavepar[graph[i][1]] >= 2:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][1]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if leavepar[graph[i][0]] >= 2:",
      "mutated_line": "if leavepar[graph[i][-1]] >= 2:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][-1]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if leavepar[graph[i][0]] >= 2:",
      "mutated_line": "if leavepar[graph[i][1]] >= 2:",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][1]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[neighbour] = dist[vertex] + 1",
      "mutated_line": "dist[neighbour] = dist[vertex] + 2",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 2\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[neighbour] = dist[vertex] + 1",
      "mutated_line": "dist[neighbour] = dist[vertex] + 0",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 0\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[neighbour] = dist[vertex] + 1",
      "mutated_line": "dist[neighbour] = dist[vertex] + 0",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + 0\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "dist[neighbour] = dist[vertex] + 1",
      "mutated_line": "dist[neighbour] = dist[vertex] + -1",
      "code": "import collections\nfrom collections import defaultdict\n\ndef find_min_max_f_values(n, edges):\n    graph = defaultdict(list)\n    for (a, b) in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    count = 0\n    leavepar = [0] * (n + 1)\n    leave = []\n    for i in graph:\n        if len(graph[i]) == 1:\n            leave.append(i)\n            leavepar[graph[i][0]] += 1\n            if leavepar[graph[i][0]] >= 2:\n                count += 1\n\n    def bfs(graph, root):\n        visited = set()\n        dist = [0] * (n + 1)\n        queue = collections.deque([root])\n        visited.add(root)\n        while queue:\n            vertex = queue.popleft()\n            for neighbour in graph[vertex]:\n                if neighbour not in visited:\n                    dist[neighbour] = dist[vertex] + -1\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n        return dist\n    ret = bfs(graph, 1)\n    ans = 1\n    (even, odd) = (False, False)\n    for i in leave:\n        if ret[i] % 2 == 1:\n            odd = True\n        if ret[i] % 2 == 0:\n            even = True\n        if even == True and odd == True:\n            ans = 3\n            break\n    return (ans, n - count - 1)"
    }
  ]
}