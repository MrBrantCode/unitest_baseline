{
  "task_id": "taco_10735",
  "entry_point": "calculate_zero_time",
  "mutant_count": 98,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244354",
      "code": "from functools import lru_cache\nMOD = 998244354\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244352",
      "code": "from functools import lru_cache\nMOD = 998244352\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 0",
      "code": "from functools import lru_cache\nMOD = 0\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 1",
      "code": "from functools import lru_cache\nMOD = 1\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = -998244353",
      "code": "from functools import lru_cache\nMOD = -998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return dfs(ss.pop())[1] % MOD",
      "mutated_line": "return dfs(ss.pop())[1] * MOD",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "return dfs(ss.pop())[1] % MOD",
      "mutated_line": "return dfs(ss.pop())[1] + MOD",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "rg[v - 1].append(u - 1)",
      "mutated_line": "rg[v - 1].append(u + 1)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u + 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "rg[v - 1].append(u - 1)",
      "mutated_line": "rg[v - 1].append(u * 1)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u * 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ss.discard(u - 1)",
      "mutated_line": "ss.discard(u + 1)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u + 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "ss.discard(u - 1)",
      "mutated_line": "ss.discard(u * 1)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u * 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "s, e = 1, a[u]",
      "mutated_line": "(s, e) = (2, a[u])",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (2, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "s, e = 1, a[u]",
      "mutated_line": "(s, e) = (0, a[u])",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (0, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "s, e = 1, a[u]",
      "mutated_line": "(s, e) = (0, a[u])",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (0, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "s, e = 1, a[u]",
      "mutated_line": "(s, e) = (-1, a[u])",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (-1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if last == 0:",
      "mutated_line": "if last != 0:",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last != 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if vs > e:",
      "mutated_line": "if vs >= e:",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs >= e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if vs > e:",
      "mutated_line": "if vs <= e:",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs <= e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if vs > e:",
      "mutated_line": "if vs != e:",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs != e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 28,
      "original_line": "e += ve - vs + 1",
      "mutated_line": "e -= ve - vs + 1",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e -= ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return e - s + 1, e",
      "mutated_line": "return (e - s - 1, e)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s - 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return e - s + 1, e",
      "mutated_line": "return ((e - s) * 1, e)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return ((e - s) * 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return dfs(ss.pop())[1] % MOD",
      "mutated_line": "return dfs(ss.pop())[2] % MOD",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[2] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return dfs(ss.pop())[1] % MOD",
      "mutated_line": "return dfs(ss.pop())[0] % MOD",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[0] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return dfs(ss.pop())[1] % MOD",
      "mutated_line": "return dfs(ss.pop())[0] % MOD",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[0] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "return dfs(ss.pop())[1] % MOD",
      "mutated_line": "return dfs(ss.pop())[-1] % MOD",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[-1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rg[v - 1].append(u - 1)",
      "mutated_line": "rg[v - 1].append(u - 2)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 2)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rg[v - 1].append(u - 1)",
      "mutated_line": "rg[v - 1].append(u - 0)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 0)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rg[v - 1].append(u - 1)",
      "mutated_line": "rg[v - 1].append(u - 0)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 0)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rg[v - 1].append(u - 1)",
      "mutated_line": "rg[v - 1].append(u - -1)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - -1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ss.discard(u - 1)",
      "mutated_line": "ss.discard(u - 2)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 2)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ss.discard(u - 1)",
      "mutated_line": "ss.discard(u - 0)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 0)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ss.discard(u - 1)",
      "mutated_line": "ss.discard(u - 0)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 0)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "ss.discard(u - 1)",
      "mutated_line": "ss.discard(u - -1)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - -1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if last == 0:",
      "mutated_line": "if last == 1:",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 1:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if last == 0:",
      "mutated_line": "if last == -1:",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == -1:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if last == 0:",
      "mutated_line": "if last == 1:",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 1:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "e += ve - vs + 1",
      "mutated_line": "e += ve - vs - 1",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs - 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "e += ve - vs + 1",
      "mutated_line": "e += (ve - vs) * 1",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += (ve - vs) * 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return e - s + 1, e",
      "mutated_line": "return (e + s + 1, e)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e + s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return e - s + 1, e",
      "mutated_line": "return (e * s + 1, e)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e * s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return e - s + 1, e",
      "mutated_line": "return (e - s + 2, e)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 2, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return e - s + 1, e",
      "mutated_line": "return (e - s + 0, e)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 0, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return e - s + 1, e",
      "mutated_line": "return (e - s + 0, e)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 0, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return e - s + 1, e",
      "mutated_line": "return (e - s + -1, e)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + -1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "rg[v - 1].append(u - 1)",
      "mutated_line": "rg[v + 1].append(u - 1)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v + 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "rg[v - 1].append(u - 1)",
      "mutated_line": "rg[v * 1].append(u - 1)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v * 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end - last - 2, end + 1))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last - 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append(((end - last) * 2, end + 1))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append(((end - last) * 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end - last + 2, end - 1))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end - 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end - last + 2, end * 1))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end * 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 + e - s + 1) - 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) - 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = ((ve - (ve - vs + 1 + e - s + 1)) * 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = ((ve - (ve - vs + 1 + e - s + 1)) * 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "e += ve - vs + 1",
      "mutated_line": "e += ve + vs + 1",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve + vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "e += ve - vs + 1",
      "mutated_line": "e += ve * vs + 1",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve * vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "e += ve - vs + 1",
      "mutated_line": "e += ve - vs + 2",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 2\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "e += ve - vs + 1",
      "mutated_line": "e += ve - vs + 0",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 0\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "e += ve - vs + 1",
      "mutated_line": "e += ve - vs + 0",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 0\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "e += ve - vs + 1",
      "mutated_line": "e += ve - vs + -1",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + -1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rg[v - 1].append(u - 1)",
      "mutated_line": "rg[v - 2].append(u - 1)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 2].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rg[v - 1].append(u - 1)",
      "mutated_line": "rg[v - 0].append(u - 1)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 0].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rg[v - 1].append(u - 1)",
      "mutated_line": "rg[v - 0].append(u - 1)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 0].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "rg[v - 1].append(u - 1)",
      "mutated_line": "rg[v - -1].append(u - 1)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - -1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end + last + 2, end + 1))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end + last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end * last + 2, end + 1))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end * last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end - last + 3, end + 1))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 3, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end - last + 1, end + 1))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 1, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end - last + 0, end + 1))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 0, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end - last + 1, end + 1))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 1, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end - last + -2, end + 1))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + -2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end - last + 2, end + 2))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 2))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end - last + 2, end + 0))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 0))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end - last + 2, end + 0))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 0))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "book.append((end - last + 2, end + 1))",
      "mutated_line": "book.append((end - last + 2, end + -1))",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + -1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve + (ve - vs + 1 + e - s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve + (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve * (ve - vs + 1 + e - s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve * (ve - vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 + e - s + 1) + 2, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 2, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 + e - s + 1) + 0, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 0, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 + e - s + 1) + 0, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + 0, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 + e - s + 1) + -1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 1) + -1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 + e - s - 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s - 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 + e - s) * 1 + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s) * 1 + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 + e + s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e + s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - ((ve - vs + 1 + e) * s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - ((ve - vs + 1 + e) * s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 + e - s + 2) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 2) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 + e - s + 0) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 0) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 + e - s + 0) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + 0) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 + e - s + -1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 + e - s + -1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 1 - e - s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 1 - e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - ((ve - vs + 1) * e - s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - ((ve - vs + 1) * e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs - 1 + e - s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs - 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - ((ve - vs) * 1 + e - s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - ((ve - vs) * 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve + vs + 1 + e - s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve + vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve * vs + 1 + e - s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve * vs + 1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 2 + e - s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 2 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 0 + e - s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 0 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + 0 + e - s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + 0 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "s, e = ve - (ve - vs + 1 + e - s + 1) + 1, ve",
      "mutated_line": "(s, e) = (ve - (ve - vs + -1 + e - s + 1) + 1, ve)",
      "code": "from functools import lru_cache\nMOD = 998244353\n\ndef calculate_zero_time(n, m, a, edges):\n    rg = [[] for _ in range(n)]\n    ss = set(range(n))\n    for (u, v) in edges:\n        rg[v - 1].append(u - 1)\n        ss.discard(u - 1)\n\n    @lru_cache(None)\n    def dfs(u):\n        r = a[u]\n        (s, e) = (1, a[u])\n        book = []\n        for v in rg[u]:\n            (last, end) = dfs(v)\n            if last == 0:\n                continue\n            book.append((end - last + 2, end + 1))\n        book.sort()\n        for (vs, ve) in book:\n            if vs > e:\n                (s, e) = (ve - (ve - vs + -1 + e - s + 1) + 1, ve)\n            else:\n                e += ve - vs + 1\n        return (e - s + 1, e)\n    return dfs(ss.pop())[1] % MOD"
    }
  ]
}