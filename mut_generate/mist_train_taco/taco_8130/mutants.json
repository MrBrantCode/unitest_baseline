{
  "task_id": "taco_8130",
  "entry_point": "inverse",
  "mutant_count": 165,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 1\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ret = 0",
      "mutated_line": "ret = -1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = -1\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ret = 0",
      "mutated_line": "ret = 1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 1\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while x > 0:",
      "mutated_line": "while x >= 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x >= 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while x > 0:",
      "mutated_line": "while x <= 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x <= 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while x > 0:",
      "mutated_line": "while x != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x != 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "ret += x % 2",
      "mutated_line": "ret -= x % 2",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret -= x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "flag = True",
      "mutated_line": "flag = False",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = False\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if S[0] != 1:",
      "mutated_line": "if S[0] == 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] == 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 54,
      "original_line": "ans *= nans",
      "mutated_line": "ans /= nans",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans /= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 55,
      "original_line": "ans *= inverse(notl, MOD)",
      "mutated_line": "ans /= inverse(notl, MOD)",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans /= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "return ans % MOD",
      "mutated_line": "return ans * MOD",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans * MOD"
    },
    {
      "operator": "AOR",
      "lineno": 58,
      "original_line": "return ans % MOD",
      "mutated_line": "return ans + MOD",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans + MOD"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return pow(a, mod - 2, mod)",
      "mutated_line": "return pow(a, mod + 2, mod)",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod + 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "return pow(a, mod - 2, mod)",
      "mutated_line": "return pow(a, mod * 2, mod)",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod * 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while x > 0:",
      "mutated_line": "while x > 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 1:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while x > 0:",
      "mutated_line": "while x > -1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > -1:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while x > 0:",
      "mutated_line": "while x > 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 1:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ret += x % 2",
      "mutated_line": "ret += x * 2",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x * 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "ret += x % 2",
      "mutated_line": "ret += x + 2",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x + 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x //= 2",
      "mutated_line": "x //= 3",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 3\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x //= 2",
      "mutated_line": "x //= 1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 1\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x //= 2",
      "mutated_line": "x //= 0",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 0\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x //= 2",
      "mutated_line": "x //= 1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 1\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "x //= 2",
      "mutated_line": "x //= -2",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= -2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if S[0] != 1:",
      "mutated_line": "if S[0] != 2:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 2:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if S[0] != 1:",
      "mutated_line": "if S[0] != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 0:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if S[0] != 1:",
      "mutated_line": "if S[0] != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 0:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if S[0] != 1:",
      "mutated_line": "if S[0] != -1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != -1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "flag = False",
      "mutated_line": "flag = True",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = True\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(M - 1):",
      "mutated_line": "for i in range(M + 1):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M + 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "for i in range(M - 1):",
      "mutated_line": "for i in range(M * 1):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M * 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if S[i + 1] % S[i] != 0:",
      "mutated_line": "if S[i + 1] % S[i] == 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] == 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 1\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return -1\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 1\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(M - 1):",
      "mutated_line": "for i in range(M + 1):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M + 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for i in range(M - 1):",
      "mutated_line": "for i in range(M * 1):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M * 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "notl = N - N // l",
      "mutated_line": "notl = N + N // l",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N + N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "notl = N - N // l",
      "mutated_line": "notl = N * (N // l)",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N * (N // l)\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "diff = l // r",
      "mutated_line": "diff = l / r",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l / r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "diff = l // r",
      "mutated_line": "diff = l * r",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l * r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ymax = N // r",
      "mutated_line": "ymax = N / r",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N / r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "ymax = N // r",
      "mutated_line": "ymax = N * r",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N * r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if ty != 1:",
      "mutated_line": "if ty == 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty == 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "nans = 0",
      "mutated_line": "nans = 1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 1\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "nans = 0",
      "mutated_line": "nans = -1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = -1\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "nans = 0",
      "mutated_line": "nans = 1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 1\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(a, mod - 2, mod)",
      "mutated_line": "return pow(a, mod - 3, mod)",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 3, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(a, mod - 2, mod)",
      "mutated_line": "return pow(a, mod - 1, mod)",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 1, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(a, mod - 2, mod)",
      "mutated_line": "return pow(a, mod - 0, mod)",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 0, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(a, mod - 2, mod)",
      "mutated_line": "return pow(a, mod - 1, mod)",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 1, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return pow(a, mod - 2, mod)",
      "mutated_line": "return pow(a, mod - -2, mod)",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - -2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ret += x % 2",
      "mutated_line": "ret += x % 3",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 3\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ret += x % 2",
      "mutated_line": "ret += x % 1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 1\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ret += x % 2",
      "mutated_line": "ret += x % 0",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 0\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ret += x % 2",
      "mutated_line": "ret += x % 1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 1\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "ret += x % 2",
      "mutated_line": "ret += x % -2",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % -2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if S[0] != 1:",
      "mutated_line": "if S[1] != 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[1] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if S[0] != 1:",
      "mutated_line": "if S[-1] != 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[-1] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if S[0] != 1:",
      "mutated_line": "if S[1] != 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[1] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(M - 1):",
      "mutated_line": "for i in range(M - 2):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 2):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(M - 1):",
      "mutated_line": "for i in range(M - 0):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 0):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(M - 1):",
      "mutated_line": "for i in range(M - 0):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 0):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "for i in range(M - 1):",
      "mutated_line": "for i in range(M - -1):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - -1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if S[i + 1] % S[i] != 0:",
      "mutated_line": "if S[i + 1] * S[i] != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] * S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if S[i + 1] % S[i] != 0:",
      "mutated_line": "if S[i + 1] + S[i] != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] + S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if S[i + 1] % S[i] != 0:",
      "mutated_line": "if S[i + 1] % S[i] != 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 1:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if S[i + 1] % S[i] != 0:",
      "mutated_line": "if S[i + 1] % S[i] != -1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != -1:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if S[i + 1] % S[i] != 0:",
      "mutated_line": "if S[i + 1] % S[i] != 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 1:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "flag = False",
      "mutated_line": "flag = True",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = True\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(M - 1):",
      "mutated_line": "for i in range(M - 2):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 2):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(M - 1):",
      "mutated_line": "for i in range(M - 0):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 0):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(M - 1):",
      "mutated_line": "for i in range(M - 0):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 0):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for i in range(M - 1):",
      "mutated_line": "for i in range(M - -1):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - -1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = S[i + 1]",
      "mutated_line": "r = S[i - 1]",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i - 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "r = S[i + 1]",
      "mutated_line": "r = S[i * 1]",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i * 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "notl = N - N // l",
      "mutated_line": "notl = N - N / l",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N / l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "notl = N - N // l",
      "mutated_line": "notl = N - N * l",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N * l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(3, int(diff ** 0.5) + 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(3, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(1, int(diff ** 0.5) + 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(1, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(0, int(diff ** 0.5) + 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(0, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(1, int(diff ** 0.5) + 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(1, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(-2, int(diff ** 0.5) + 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(-2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff ** 0.5) - 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) - 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff ** 0.5) * 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) * 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if ty % j == 0:",
      "mutated_line": "if ty % j != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j != 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if ty != 1:",
      "mutated_line": "if ty != 2:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 2:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if ty != 1:",
      "mutated_line": "if ty != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 0:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if ty != 1:",
      "mutated_line": "if ty != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 0:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if ty != 1:",
      "mutated_line": "if ty != -1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != -1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for bi in range(2 ** len(s)):",
      "mutated_line": "for bi in range(2 * len(s)):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 * len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "for bi in range(2 ** len(s)):",
      "mutated_line": "for bi in range(2 + len(s)):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 + len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "nmul = 1",
      "mutated_line": "nmul = 2",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 2\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "nmul = 1",
      "mutated_line": "nmul = 0",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 0\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "nmul = 1",
      "mutated_line": "nmul = 0",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 0\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "nmul = 1",
      "mutated_line": "nmul = -1",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = -1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "nddd = ymax // nmul",
      "mutated_line": "nddd = ymax / nmul",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax / nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "nddd = ymax // nmul",
      "mutated_line": "nddd = ymax * nmul",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax * nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 50,
      "original_line": "if npopc % 2 == 0:",
      "mutated_line": "if npopc % 2 != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 != 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 51,
      "original_line": "nans += nddd",
      "mutated_line": "nans -= nddd",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans -= nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 53,
      "original_line": "nans -= nddd",
      "mutated_line": "nans += nddd",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans += nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = S[i + 1]",
      "mutated_line": "r = S[i + 2]",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 2]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = S[i + 1]",
      "mutated_line": "r = S[i + 0]",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 0]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = S[i + 1]",
      "mutated_line": "r = S[i + 0]",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 0]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "r = S[i + 1]",
      "mutated_line": "r = S[i + -1]",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + -1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff ** 0.5) + 11):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 11):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff ** 0.5) + 9):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 9):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff ** 0.5) + 0):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 0):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff ** 0.5) + 1):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 1):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff ** 0.5) + -10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + -10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ty % j == 0:",
      "mutated_line": "if ty * j == 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty * j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "if ty % j == 0:",
      "mutated_line": "if ty + j == 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty + j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ty % j == 0:",
      "mutated_line": "if ty % j == 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 1:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ty % j == 0:",
      "mutated_line": "if ty % j == -1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == -1:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if ty % j == 0:",
      "mutated_line": "if ty % j == 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 1:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while ty % j == 0:",
      "mutated_line": "while ty % j != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j != 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for bi in range(2 ** len(s)):",
      "mutated_line": "for bi in range(3 ** len(s)):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(3 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for bi in range(2 ** len(s)):",
      "mutated_line": "for bi in range(1 ** len(s)):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(1 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for bi in range(2 ** len(s)):",
      "mutated_line": "for bi in range(0 ** len(s)):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(0 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for bi in range(2 ** len(s)):",
      "mutated_line": "for bi in range(1 ** len(s)):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(1 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "for bi in range(2 ** len(s)):",
      "mutated_line": "for bi in range(-2 ** len(s)):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(-2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 2 ** j & bi >= 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi >= 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 2 ** j & bi <= 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi <= 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 2 ** j & bi != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi != 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "ASR",
      "lineno": 48,
      "original_line": "nmul *= s[j]",
      "mutated_line": "nmul /= s[j]",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul /= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "if npopc % 2 == 0:",
      "mutated_line": "if npopc * 2 == 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc * 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 50,
      "original_line": "if npopc % 2 == 0:",
      "mutated_line": "if npopc + 2 == 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc + 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if npopc % 2 == 0:",
      "mutated_line": "if npopc % 2 == 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 1:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if npopc % 2 == 0:",
      "mutated_line": "if npopc % 2 == -1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == -1:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if npopc % 2 == 0:",
      "mutated_line": "if npopc % 2 == 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 1:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if S[i + 1] % S[i] != 0:",
      "mutated_line": "if S[i - 1] % S[i] != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i - 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if S[i + 1] % S[i] != 0:",
      "mutated_line": "if S[i * 1] % S[i] != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i * 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff * 0.5) + 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff * 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff + 0.5) + 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff + 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "while ty % j == 0:",
      "mutated_line": "while ty * j == 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty * j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "while ty % j == 0:",
      "mutated_line": "while ty + j == 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty + j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while ty % j == 0:",
      "mutated_line": "while ty % j == 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 1:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while ty % j == 0:",
      "mutated_line": "while ty % j == -1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == -1:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "while ty % j == 0:",
      "mutated_line": "while ty % j == 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 1:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 2 ** j | bi > 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j | bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 2 ** j & bi > 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 1:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 2 ** j & bi > -1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > -1:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 2 ** j & bi > 1:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 1:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if npopc % 2 == 0:",
      "mutated_line": "if npopc % 3 == 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 3 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if npopc % 2 == 0:",
      "mutated_line": "if npopc % 1 == 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 1 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if npopc % 2 == 0:",
      "mutated_line": "if npopc % 0 == 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 0 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if npopc % 2 == 0:",
      "mutated_line": "if npopc % 1 == 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 1 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "if npopc % 2 == 0:",
      "mutated_line": "if npopc % -2 == 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % -2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if S[i + 1] % S[i] != 0:",
      "mutated_line": "if S[i + 2] % S[i] != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 2] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if S[i + 1] % S[i] != 0:",
      "mutated_line": "if S[i + 0] % S[i] != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 0] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if S[i + 1] % S[i] != 0:",
      "mutated_line": "if S[i + 0] % S[i] != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 0] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if S[i + 1] % S[i] != 0:",
      "mutated_line": "if S[i + -1] % S[i] != 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + -1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff ** 1.5) + 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 1.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff ** -0.5) + 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** -0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff ** 0) + 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff ** 1) + 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 1) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "for j in range(2, int(diff ** 0.5) + 10):",
      "mutated_line": "for j in range(2, int(diff ** -0.5) + 10):",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** -0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 2 * j & bi > 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 * j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 2 + j & bi > 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 2 + j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 3 ** j & bi > 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 3 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 1 ** j & bi > 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 1 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 0 ** j & bi > 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 0 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if 1 ** j & bi > 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if 1 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "if 2 ** j & bi > 0:",
      "mutated_line": "if -2 ** j & bi > 0:",
      "code": "import math\n\ndef inverse(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef popcnt(x):\n    ret = 0\n    while x > 0:\n        ret += x % 2\n        x //= 2\n    return ret\n\ndef calculate_gcd_set_probability(N, M, MOD, S):\n    flag = True\n    if S[0] != 1:\n        flag = False\n    for i in range(M - 1):\n        if S[i + 1] % S[i] != 0:\n            flag = False\n    if not flag:\n        return 0\n    ans = inverse(N, MOD)\n    S.reverse()\n    for i in range(M - 1):\n        l = S[i]\n        r = S[i + 1]\n        notl = N - N // l\n        diff = l // r\n        ymax = N // r\n        s = set()\n        ty = diff\n        for j in range(2, int(diff ** 0.5) + 10):\n            if ty % j == 0:\n                s.add(j)\n                while ty % j == 0:\n                    ty //= j\n        if ty != 1:\n            s.add(ty)\n        s = list(s)\n        s.sort()\n        nans = 0\n        for bi in range(2 ** len(s)):\n            npopc = popcnt(bi)\n            nmul = 1\n            for j in range(len(s)):\n                if -2 ** j & bi > 0:\n                    nmul *= s[j]\n            nddd = ymax // nmul\n            if npopc % 2 == 0:\n                nans += nddd\n            else:\n                nans -= nddd\n        ans *= nans\n        ans *= inverse(notl, MOD)\n        ans %= MOD\n    return ans % MOD"
    }
  ]
}