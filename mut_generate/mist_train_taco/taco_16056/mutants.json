{
  "task_id": "taco_16056",
  "entry_point": "determine_fortune",
  "mutant_count": 327,
  "mutants": [
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):",
      "mutated_line": "if not do_intersect(p1, q1, p2, q2) and (not do_intersect(p1, q1, p3, q3)) and (not do_intersect(p3, q3, p2, q2)):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) and (not do_intersect(p1, q1, p3, q3)) and (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if area >= 1900000:",
      "mutated_line": "if area > 1900000:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area > 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if area >= 1900000:",
      "mutated_line": "if area < 1900000:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area < 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 49,
      "original_line": "if area >= 1900000:",
      "mutated_line": "if area == 1900000:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area == 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "LCR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) or q[0] >= min(p[0], r[0]) or q[1] <= max(p[1], r[1]) or (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) or q[0] >= min(p[0], r[0]) or q[1] <= max(p[1], r[1]) or (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) + (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) + (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) * ((q[0] - p[0]) * (r[1] - q[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) * ((q[0] - p[0]) * (r[1] - q[1]))\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 7,
      "original_line": "if val == 0:",
      "mutated_line": "if val != 0:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val != 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "if o1 != o2 and o3 != o4:",
      "mutated_line": "if o1 != o2 or o3 != o4:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 or o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if o1 == 0 and on_segment(p1, p2, q1):",
      "mutated_line": "if o1 == 0 or on_segment(p1, p2, q1):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 or on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if o2 == 0 and on_segment(p1, q2, q1):",
      "mutated_line": "if o2 == 0 or on_segment(p1, q2, q1):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 or on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if o3 == 0 and on_segment(p2, p1, q2):",
      "mutated_line": "if o3 == 0 or on_segment(p2, p1, q2):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 or on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "LCR",
      "lineno": 24,
      "original_line": "if o4 == 0 and on_segment(p2, q1, q2):",
      "mutated_line": "if o4 == 0 or on_segment(p2, q1, q2):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 or on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return True\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) / 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) / 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = (by - ay) * (dx - cx) - (bx - ax) * (dy - cy) + 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = (by - ay) * (dx - cx) - (bx - ax) * (dy - cy) + 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) ** 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) ** 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) * dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) * dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) // dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) // dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) * dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) * dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) // dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) // dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return 'kyo'",
      "mutated_line": "return ''",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return ''\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 / (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 / (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 + (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 + (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 ** (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 ** (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if area >= 1900000:",
      "mutated_line": "if area >= 1900001:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900001:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if area >= 1900000:",
      "mutated_line": "if area >= 1899999:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1899999:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if area >= 1900000:",
      "mutated_line": "if area >= 0:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 0:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if area >= 1900000:",
      "mutated_line": "if area >= 1:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "if area >= 1900000:",
      "mutated_line": "if area >= -1900000:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= -1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 50,
      "original_line": "return 'dai-kichi'",
      "mutated_line": "return ''",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return ''\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "elif area >= 1000000:",
      "mutated_line": "elif area > 1000000:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area > 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "elif area >= 1000000:",
      "mutated_line": "elif area < 1000000:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area < 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "elif area >= 1000000:",
      "mutated_line": "elif area == 1000000:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area == 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] < max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] < max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] > max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] > max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] == max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] == max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] > min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] > min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] < min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] < min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] == min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] == min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] < max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] < max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] > max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] > max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] == max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] == max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] > min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] > min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] < min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] < min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] == min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] == min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) / (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) / (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = q[1] - p[1] + (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = q[1] - p[1] + (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) ** (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) ** (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) / (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) / (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0] + (r[1] - q[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0] + (r[1] - q[1]))\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) ** (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) ** (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if val == 0:",
      "mutated_line": "if val == 1:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 1:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if val == 0:",
      "mutated_line": "if val == -1:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == -1:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "if val == 0:",
      "mutated_line": "if val == 1:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 1:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 1\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return -1\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 1\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 1 if val >= 0 else 2",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val >= 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 1 if val <= 0 else 2",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val <= 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 1 if val != 0 else 2",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val != 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 2 if val > 0 else 2",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 2 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 0 if val > 0 else 2",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 0 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 0 if val > 0 else 2",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 0 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return -1 if val > 0 else 2",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return -1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 1 if val > 0 else 3",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 3\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 1 if val > 0 else 1",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 1\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 1 if val > 0 else 0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 0\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 1 if val > 0 else 1",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 1\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 1 if val > 0 else -2",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else -2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if o1 != o2 and o3 != o4:",
      "mutated_line": "if o1 == o2 and o3 != o4:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 == o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if o1 != o2 and o3 != o4:",
      "mutated_line": "if o1 != o2 and o3 == o4:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 == o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return False\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if o1 == 0 and on_segment(p1, p2, q1):",
      "mutated_line": "if o1 != 0 and on_segment(p1, p2, q1):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 != 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return False\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if o2 == 0 and on_segment(p1, q2, q1):",
      "mutated_line": "if o2 != 0 and on_segment(p1, q2, q1):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 != 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return False\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if o3 == 0 and on_segment(p2, p1, q2):",
      "mutated_line": "if o3 != 0 and on_segment(p2, p1, q2):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 != 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return False\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 24,
      "original_line": "if o4 == 0 and on_segment(p2, q1, q2):",
      "mutated_line": "if o4 != 0 and on_segment(p2, q1, q2):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 != 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return False\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) + (bx - ax) * (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) + (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = (by - ay) * (dx - cx) * ((bx - ax) * (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = (by - ay) * (dx - cx) * ((bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 2.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 2.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 0.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 0.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * -1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * -1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) + (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) + (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = (cy * dx - cx * dy) * (bx - ax) * ((ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = (cy * dx - cx * dy) * (bx - ax) * ((ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) + (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) + (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = (cy * dx - cx * dy) * (by - ay) * ((ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = (cy * dx - cx * dy) * (by - ay) * ((ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(1.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(1.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(-0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(-0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(1 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(1 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(-0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(-0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) - x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) - x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * ((x1 * (y2 - y3) + x2 * (y3 - y1)) * (x3 * (y1 - y2))))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * ((x1 * (y2 - y3) + x2 * (y3 - y1)) * (x3 * (y1 - y2))))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "elif area >= 1000000:",
      "mutated_line": "elif area >= 1000001:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000001:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "elif area >= 1000000:",
      "mutated_line": "elif area >= 999999:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 999999:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "elif area >= 1000000:",
      "mutated_line": "elif area >= 0:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 0:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "elif area >= 1000000:",
      "mutated_line": "elif area >= 1:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "elif area >= 1000000:",
      "mutated_line": "elif area >= -1000000:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= -1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return 'chu-kichi'",
      "mutated_line": "return ''",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return ''\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "elif area >= 100000:",
      "mutated_line": "elif area > 100000:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area > 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "elif area >= 100000:",
      "mutated_line": "elif area < 100000:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area < 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "elif area >= 100000:",
      "mutated_line": "elif area == 100000:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area == 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] + p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] + p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = q[1] * p[1] * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = q[1] * p[1] * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] + q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] + q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] * q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] * q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] + p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] + p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - q[0] * p[0] * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - q[0] * p[0] * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] + q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] + q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] * q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] * q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 1 if val > 1 else 2",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 1 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 1 if val > -1 else 2",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > -1 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "return 1 if val > 0 else 2",
      "mutated_line": "return 1 if val > 1 else 2",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 1 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if o1 == 0 and on_segment(p1, p2, q1):",
      "mutated_line": "if o1 == 1 and on_segment(p1, p2, q1):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 1 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if o1 == 0 and on_segment(p1, p2, q1):",
      "mutated_line": "if o1 == -1 and on_segment(p1, p2, q1):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == -1 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if o1 == 0 and on_segment(p1, p2, q1):",
      "mutated_line": "if o1 == 1 and on_segment(p1, p2, q1):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 1 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if o2 == 0 and on_segment(p1, q2, q1):",
      "mutated_line": "if o2 == 1 and on_segment(p1, q2, q1):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 1 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if o2 == 0 and on_segment(p1, q2, q1):",
      "mutated_line": "if o2 == -1 and on_segment(p1, q2, q1):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == -1 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if o2 == 0 and on_segment(p1, q2, q1):",
      "mutated_line": "if o2 == 1 and on_segment(p1, q2, q1):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 1 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if o3 == 0 and on_segment(p2, p1, q2):",
      "mutated_line": "if o3 == 1 and on_segment(p2, p1, q2):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 1 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if o3 == 0 and on_segment(p2, p1, q2):",
      "mutated_line": "if o3 == -1 and on_segment(p2, p1, q2):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == -1 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if o3 == 0 and on_segment(p2, p1, q2):",
      "mutated_line": "if o3 == 1 and on_segment(p2, p1, q2):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 1 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if o4 == 0 and on_segment(p2, q1, q2):",
      "mutated_line": "if o4 == 1 and on_segment(p2, q1, q2):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 1 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if o4 == 0 and on_segment(p2, q1, q2):",
      "mutated_line": "if o4 == -1 and on_segment(p2, q1, q2):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == -1 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "if o4 == 0 and on_segment(p2, q1, q2):",
      "mutated_line": "if o4 == 1 and on_segment(p2, q1, q2):",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 1 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) / (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) / (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = (by - ay + (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = (by - ay + (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) ** (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) ** (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) / (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) / (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - (bx - ax + (dy - cy))) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax + (dy - cy))) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) ** (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) ** (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) / (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) / (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = (cy * dx - cx * dy + (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = (cy * dx - cx * dy + (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) ** (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) ** (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) / (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) / (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by + (dx - cx))) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by + (dx - cx))) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) ** (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) ** (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) / (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) / (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = (cy * dx - cx * dy + (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = (cy * dx - cx * dy + (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) ** (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) ** (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) / (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) / (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by + (dy - cy))) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by + (dy - cy))) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) ** (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) ** (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(p1, q1) = (coord1[:2], coord1[2:])",
      "mutated_line": "(p1, q1) = (coord1[:3], coord1[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:3], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(p1, q1) = (coord1[:2], coord1[2:])",
      "mutated_line": "(p1, q1) = (coord1[:1], coord1[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:1], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(p1, q1) = (coord1[:2], coord1[2:])",
      "mutated_line": "(p1, q1) = (coord1[:0], coord1[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:0], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(p1, q1) = (coord1[:2], coord1[2:])",
      "mutated_line": "(p1, q1) = (coord1[:1], coord1[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:1], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(p1, q1) = (coord1[:2], coord1[2:])",
      "mutated_line": "(p1, q1) = (coord1[:-2], coord1[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:-2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(p1, q1) = (coord1[:2], coord1[2:])",
      "mutated_line": "(p1, q1) = (coord1[:2], coord1[3:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[3:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(p1, q1) = (coord1[:2], coord1[2:])",
      "mutated_line": "(p1, q1) = (coord1[:2], coord1[1:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[1:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(p1, q1) = (coord1[:2], coord1[2:])",
      "mutated_line": "(p1, q1) = (coord1[:2], coord1[0:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[0:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(p1, q1) = (coord1[:2], coord1[2:])",
      "mutated_line": "(p1, q1) = (coord1[:2], coord1[1:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[1:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "(p1, q1) = (coord1[:2], coord1[2:])",
      "mutated_line": "(p1, q1) = (coord1[:2], coord1[-2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[-2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(p2, q2) = (coord2[:2], coord2[2:])",
      "mutated_line": "(p2, q2) = (coord2[:3], coord2[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:3], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(p2, q2) = (coord2[:2], coord2[2:])",
      "mutated_line": "(p2, q2) = (coord2[:1], coord2[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:1], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(p2, q2) = (coord2[:2], coord2[2:])",
      "mutated_line": "(p2, q2) = (coord2[:0], coord2[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:0], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(p2, q2) = (coord2[:2], coord2[2:])",
      "mutated_line": "(p2, q2) = (coord2[:1], coord2[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:1], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(p2, q2) = (coord2[:2], coord2[2:])",
      "mutated_line": "(p2, q2) = (coord2[:-2], coord2[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:-2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(p2, q2) = (coord2[:2], coord2[2:])",
      "mutated_line": "(p2, q2) = (coord2[:2], coord2[3:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[3:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(p2, q2) = (coord2[:2], coord2[2:])",
      "mutated_line": "(p2, q2) = (coord2[:2], coord2[1:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[1:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(p2, q2) = (coord2[:2], coord2[2:])",
      "mutated_line": "(p2, q2) = (coord2[:2], coord2[0:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[0:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(p2, q2) = (coord2[:2], coord2[2:])",
      "mutated_line": "(p2, q2) = (coord2[:2], coord2[1:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[1:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "(p2, q2) = (coord2[:2], coord2[2:])",
      "mutated_line": "(p2, q2) = (coord2[:2], coord2[-2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[-2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(p3, q3) = (coord3[:2], coord3[2:])",
      "mutated_line": "(p3, q3) = (coord3[:3], coord3[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:3], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(p3, q3) = (coord3[:2], coord3[2:])",
      "mutated_line": "(p3, q3) = (coord3[:1], coord3[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:1], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(p3, q3) = (coord3[:2], coord3[2:])",
      "mutated_line": "(p3, q3) = (coord3[:0], coord3[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:0], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(p3, q3) = (coord3[:2], coord3[2:])",
      "mutated_line": "(p3, q3) = (coord3[:1], coord3[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:1], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(p3, q3) = (coord3[:2], coord3[2:])",
      "mutated_line": "(p3, q3) = (coord3[:-2], coord3[2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:-2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(p3, q3) = (coord3[:2], coord3[2:])",
      "mutated_line": "(p3, q3) = (coord3[:2], coord3[3:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[3:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(p3, q3) = (coord3[:2], coord3[2:])",
      "mutated_line": "(p3, q3) = (coord3[:2], coord3[1:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[1:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(p3, q3) = (coord3[:2], coord3[2:])",
      "mutated_line": "(p3, q3) = (coord3[:2], coord3[0:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[0:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(p3, q3) = (coord3[:2], coord3[2:])",
      "mutated_line": "(p3, q3) = (coord3[:2], coord3[1:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[1:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "(p3, q3) = (coord3[:2], coord3[2:])",
      "mutated_line": "(p3, q3) = (coord3[:2], coord3[-2:])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[-2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) - x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) - x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) * (x2 * (y3 - y1)) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) * (x2 * (y3 - y1)) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 / (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 / (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + (x3 + (y1 - y2))))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + (x3 + (y1 - y2))))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 ** (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 ** (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "elif area >= 100000:",
      "mutated_line": "elif area >= 100001:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100001:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "elif area >= 100000:",
      "mutated_line": "elif area >= 99999:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 99999:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "elif area >= 100000:",
      "mutated_line": "elif area >= 0:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 0:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "elif area >= 100000:",
      "mutated_line": "elif area >= 1:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 1:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "elif area >= 100000:",
      "mutated_line": "elif area >= -100000:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= -100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 54,
      "original_line": "return 'kichi'",
      "mutated_line": "return ''",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return ''\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "elif area > 0:",
      "mutated_line": "elif area >= 0:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area >= 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "elif area > 0:",
      "mutated_line": "elif area <= 0:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area <= 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "elif area > 0:",
      "mutated_line": "elif area != 0:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area != 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[1] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[1] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[-1] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[-1] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[1] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[1] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[1] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[1] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[-1] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[-1] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[1] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[1] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[2] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[2] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[0] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[0] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[0] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[0] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[-1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[-1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[2] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[2] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[0] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[0] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[0] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[0] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[-1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[-1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by + ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by + ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = (by * ay * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = (by * ay * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx + cx) - (bx - ax) * (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx + cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx * cx) - (bx - ax) * (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx * cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - (bx + ax) * (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx + ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - bx * ax * (dy - cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - bx * ax * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy + cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy + cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0",
      "mutated_line": "dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy * cy)) * 1.0",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy * cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx + cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx + cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = (cy * dx * (cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = (cy * dx * (cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx + ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx + ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx * ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx * ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx + ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx + ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - ay * bx * (ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - ay * bx * (ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx + cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx + cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx * cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx * cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx + cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx + cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = (cy * dx * (cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = (cy * dx * (cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by + ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by + ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by * ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by * ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx + ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx + ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - ay * bx * (ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - ay * bx * (ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy + cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy + cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy * cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy * cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 / (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 / (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 + (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 + (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 ** (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 ** (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 / (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 / (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) + (x2 + (y3 - y1)) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + (x2 + (y3 - y1)) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 ** (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 ** (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 + y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 + y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 * y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 * y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "elif area > 0:",
      "mutated_line": "elif area > 1:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 1:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "elif area > 0:",
      "mutated_line": "elif area > -1:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > -1:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "elif area > 0:",
      "mutated_line": "elif area > 1:",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 1:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "return 'syo-kichi'",
      "mutated_line": "return ''",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return ''\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 58,
      "original_line": "return 'kyo'",
      "mutated_line": "return ''",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return ''"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[1], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[1], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[-1], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[-1], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[1], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[1], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[1]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[1]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[-1]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[-1]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[1]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[1]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[1], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[1], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[-1], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[-1], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[1], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[1], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[1]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[1]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[-1]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[-1]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[1]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[1]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[2], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[2], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[0], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[0], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[0], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[0], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[-1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[-1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[2])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[2])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[0])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[0])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[0])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[0])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[-1])) and (q[1] >= min(p[1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[-1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[2], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[2], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[0], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[0], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[0], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[0], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[-1], r[1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[-1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[2]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[2]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[0]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[0]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[0]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[0]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))",
      "mutated_line": "return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[-1]))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[-1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[2] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[2] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[0] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[0] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[0] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[0] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[-1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[-1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[2]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[2]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[0]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[0]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[0]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[0]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[-1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[-1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[1] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[1] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[-1] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[-1] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[1] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[1] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[1]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[1]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[-1]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[-1]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[1]) - (q[0] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[1]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[1] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[1] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[-1] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[-1] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[1] - p[0]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[1] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[1]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[1]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[-1]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[-1]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[1]) * (r[1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[1]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[2] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[2] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[0] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[0] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[0] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[0] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[-1] - q[1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[-1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[2])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[2])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[0])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[0])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[0])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[0])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])",
      "mutated_line": "val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[-1])",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[-1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy / dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy / dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy + dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy + dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy ** dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy ** dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx / dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx / dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - (cx + dy)) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - (cx + dy)) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx ** dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx ** dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay / bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay / bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay + bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay + bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay ** bx - ax * by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay ** bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax / by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax / by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - (ax + by)) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - (ax + by)) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn",
      "mutated_line": "x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax ** by) * (dx - cx)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax ** by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy / dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy / dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy + dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy + dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy ** dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy ** dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx / dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx / dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - (cx + dy)) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - (cx + dy)) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx ** dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx ** dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay / bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay / bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay + bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay + bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay ** bx - ax * by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay ** bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax / by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax / by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - (ax + by)) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - (ax + by)) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn",
      "mutated_line": "y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax ** by) * (dy - cy)) / dn",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax ** by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 + y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 + y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 * y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 * y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 + y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 + y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    },
    {
      "operator": "AOR",
      "lineno": 47,
      "original_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))",
      "mutated_line": "area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 * y1) + x3 * (y1 - y2)))",
      "code": "def determine_fortune(coord1, coord2, coord3):\n\n    def on_segment(p, q, r):\n        return q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1]))\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        return 1 if val > 0 else 2\n\n    def do_intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def ip(xy1, xy2):\n        (ax, ay, bx, by) = xy1\n        (cx, cy, dx, dy) = xy2\n        dn = ((by - ay) * (dx - cx) - (bx - ax) * (dy - cy)) * 1.0\n        x = ((cy * dx - cx * dy) * (bx - ax) - (ay * bx - ax * by) * (dx - cx)) / dn\n        y = ((cy * dx - cx * dy) * (by - ay) - (ay * bx - ax * by) * (dy - cy)) / dn\n        return (x, y)\n    (p1, q1) = (coord1[:2], coord1[2:])\n    (p2, q2) = (coord2[:2], coord2[2:])\n    (p3, q3) = (coord3[:2], coord3[2:])\n    if not do_intersect(p1, q1, p2, q2) or not do_intersect(p1, q1, p3, q3) or (not do_intersect(p3, q3, p2, q2)):\n        return 'kyo'\n    (x1, y1) = ip(coord1, coord2)\n    (x2, y2) = ip(coord2, coord3)\n    (x3, y3) = ip(coord3, coord1)\n    area = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 * y1) + x3 * (y1 - y2)))\n    if area >= 1900000:\n        return 'dai-kichi'\n    elif area >= 1000000:\n        return 'chu-kichi'\n    elif area >= 100000:\n        return 'kichi'\n    elif area > 0:\n        return 'syo-kichi'\n    else:\n        return 'kyo'"
    }
  ]
}