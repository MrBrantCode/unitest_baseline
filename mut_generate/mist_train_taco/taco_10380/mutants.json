{
  "task_id": "taco_10380",
  "entry_point": "generate_polynomials_for_gcd_steps",
  "mutant_count": 201,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n < 1:",
      "mutated_line": "if n <= 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n <= 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n < 1:",
      "mutated_line": "if n >= 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n >= 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if n < 1:",
      "mutated_line": "if n != 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n != 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < 1:",
      "mutated_line": "if n < 2:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 2:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < 1:",
      "mutated_line": "if n < 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 0:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < 1:",
      "mutated_line": "if n < 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 0:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if n < 1:",
      "mutated_line": "if n < -1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < -1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "def gcdSteps(p1, p2, steps=0):",
      "mutated_line": "def gcdSteps(p1, p2, steps=1):",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=1):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "def gcdSteps(p1, p2, steps=0):",
      "mutated_line": "def gcdSteps(p1, p2, steps=-1):",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=-1):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "def gcdSteps(p1, p2, steps=0):",
      "mutated_line": "def gcdSteps(p1, p2, steps=1):",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=1):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "LCR",
      "lineno": 46,
      "original_line": "if len(p1) == 0 or len(p2) == 0:",
      "mutated_line": "if len(p1) == 0 and len(p2) == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 and len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n + 1):",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n + 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n * 1):",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n * 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 53,
      "original_line": "if gcdSteps(a, b) != i + 1:",
      "mutated_line": "if gcdSteps(a, b) == i + 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) == i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "LCR",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 or newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 or newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 or newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 or newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "times = 0",
      "mutated_line": "times = 1",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 1\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "times = 0",
      "mutated_line": "times = -1",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = -1\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "times = 0",
      "mutated_line": "times = 1",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 1\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while len(tmp) >= len(other):",
      "mutated_line": "while len(tmp) > len(other):",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) > len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while len(tmp) >= len(other):",
      "mutated_line": "while len(tmp) < len(other):",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) < len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "while len(tmp) >= len(other):",
      "mutated_line": "while len(tmp) == len(other):",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) == len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "times += 1",
      "mutated_line": "times -= 1",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times -= 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if len(p1) == 0 or len(p2) == 0:",
      "mutated_line": "if len(p1) != 0 or len(p2) == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) != 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 46,
      "original_line": "if len(p1) == 0 or len(p2) == 0:",
      "mutated_line": "if len(p1) == 0 or len(p2) != 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) != 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 2):",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 2):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 0):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - 0):",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 0):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "for i in range(n - 1):",
      "mutated_line": "for i in range(n - -1):",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - -1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "if gcdSteps(a, b) != i + 1:",
      "mutated_line": "if gcdSteps(a, b) != i - 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i - 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 53,
      "original_line": "if gcdSteps(a, b) != i + 1:",
      "mutated_line": "if gcdSteps(a, b) != i * 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i * 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "(a, b) = (b + (a << 1), a)",
      "mutated_line": "(a, b) = (b - (a << 1), a)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b - (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "(a, b) = (b + (a << 1), a)",
      "mutated_line": "(a, b) = (b * (a << 1), a)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b * (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return polynomial([0] * x + self.data)",
      "mutated_line": "return polynomial([0] * x - self.data)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x - self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return polynomial([0] * x + self.data)",
      "mutated_line": "return polynomial([0] * x * self.data)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x * self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y + x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y + x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y * x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y * x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) >= 0 and newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) >= 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) <= 0 and newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) <= 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) != 0 and newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) != 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-1] != 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] != 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) * 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) * 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y + x + 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [y + x + 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) >= 0 and newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) >= 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) <= 0 and newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) <= 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) != 0 and newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) != 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-1] != 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] != 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "times += 1",
      "mutated_line": "times += 2",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 2\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "times += 1",
      "mutated_line": "times += 0",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 0\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "times += 1",
      "mutated_line": "times += 0",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 0\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "times += 1",
      "mutated_line": "times += -1",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += -1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if times > 1000:",
      "mutated_line": "if times >= 1000:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times >= 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if times > 1000:",
      "mutated_line": "if times <= 1000:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times <= 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if times > 1000:",
      "mutated_line": "if times != 1000:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times != 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp + (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp + (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp * ((other << len(tmp) - len(other)) * (tmp[-1] // other[-1]))",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp * ((other << len(tmp) - len(other)) * (tmp[-1] // other[-1]))\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(p1) == 0 or len(p2) == 0:",
      "mutated_line": "if len(p1) == 1 or len(p2) == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 1 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(p1) == 0 or len(p2) == 0:",
      "mutated_line": "if len(p1) == -1 or len(p2) == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == -1 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(p1) == 0 or len(p2) == 0:",
      "mutated_line": "if len(p1) == 1 or len(p2) == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 1 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(p1) == 0 or len(p2) == 0:",
      "mutated_line": "if len(p1) == 0 or len(p2) == 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 1:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(p1) == 0 or len(p2) == 0:",
      "mutated_line": "if len(p1) == 0 or len(p2) == -1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == -1:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "if len(p1) == 0 or len(p2) == 0:",
      "mutated_line": "if len(p1) == 0 or len(p2) == 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 1:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return gcdSteps(p2, p1 % p2, steps + 1)",
      "mutated_line": "return gcdSteps(p2, p1 * p2, steps + 1)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 * p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return gcdSteps(p2, p1 % p2, steps + 1)",
      "mutated_line": "return gcdSteps(p2, p1 + p2, steps + 1)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 + p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return gcdSteps(p2, p1 % p2, steps + 1)",
      "mutated_line": "return gcdSteps(p2, p1 % p2, steps - 1)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps - 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "return gcdSteps(p2, p1 % p2, steps + 1)",
      "mutated_line": "return gcdSteps(p2, p1 % p2, steps * 1)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps * 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "(a, b) = (polynomial([0, 1]), polynomial([1]))",
      "mutated_line": "(a, b) = (polynomial([1, 1]), polynomial([1]))",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([1, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "(a, b) = (polynomial([0, 1]), polynomial([1]))",
      "mutated_line": "(a, b) = (polynomial([-1, 1]), polynomial([1]))",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([-1, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "(a, b) = (polynomial([0, 1]), polynomial([1]))",
      "mutated_line": "(a, b) = (polynomial([1, 1]), polynomial([1]))",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([1, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "(a, b) = (polynomial([0, 1]), polynomial([1]))",
      "mutated_line": "(a, b) = (polynomial([0, 2]), polynomial([1]))",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 2]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "(a, b) = (polynomial([0, 1]), polynomial([1]))",
      "mutated_line": "(a, b) = (polynomial([0, 0]), polynomial([1]))",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 0]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "(a, b) = (polynomial([0, 1]), polynomial([1]))",
      "mutated_line": "(a, b) = (polynomial([0, 0]), polynomial([1]))",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 0]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "(a, b) = (polynomial([0, 1]), polynomial([1]))",
      "mutated_line": "(a, b) = (polynomial([0, -1]), polynomial([1]))",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, -1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "(a, b) = (polynomial([0, 1]), polynomial([1]))",
      "mutated_line": "(a, b) = (polynomial([0, 1]), polynomial([2]))",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([2]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "(a, b) = (polynomial([0, 1]), polynomial([1]))",
      "mutated_line": "(a, b) = (polynomial([0, 1]), polynomial([0]))",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([0]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "(a, b) = (polynomial([0, 1]), polynomial([1]))",
      "mutated_line": "(a, b) = (polynomial([0, 1]), polynomial([0]))",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([0]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "(a, b) = (polynomial([0, 1]), polynomial([1]))",
      "mutated_line": "(a, b) = (polynomial([0, 1]), polynomial([-1]))",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([-1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if gcdSteps(a, b) != i + 1:",
      "mutated_line": "if gcdSteps(a, b) != i + 2:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 2:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if gcdSteps(a, b) != i + 1:",
      "mutated_line": "if gcdSteps(a, b) != i + 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 0:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if gcdSteps(a, b) != i + 1:",
      "mutated_line": "if gcdSteps(a, b) != i + 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 0:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 53,
      "original_line": "if gcdSteps(a, b) != i + 1:",
      "mutated_line": "if gcdSteps(a, b) != i + -1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + -1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return polynomial([0] * x + self.data)",
      "mutated_line": "return polynomial([0] / x + self.data)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] / x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return polynomial([0] * x + self.data)",
      "mutated_line": "return polynomial([0] + x + self.data)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] + x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "return polynomial([0] * x + self.data)",
      "mutated_line": "return polynomial([0] ** x + self.data)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] ** x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 1 and newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 1 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > -1 and newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > -1 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 1 and newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 1 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-1] == 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 1:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-1] == -1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == -1:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-1] == 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 1:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "del newData[-1]",
      "mutated_line": "del newData[+1]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[+1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y - x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y - x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y * x % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [y * x % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 3 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 3 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 1 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 1 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 0 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 0 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 1 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 1 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % -2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % -2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 1 and newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 1 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > -1 and newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > -1 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 1 and newData[-1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 1 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-1] == 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 1:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-1] == -1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == -1:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-1] == 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 1:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "del newData[-1]",
      "mutated_line": "del newData[+1]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[+1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return polynomial([x * amt for x in self.data])",
      "mutated_line": "return polynomial([x / amt for x in self.data])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x / amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return polynomial([x * amt for x in self.data])",
      "mutated_line": "return polynomial([x + amt for x in self.data])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x + amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "return polynomial([x * amt for x in self.data])",
      "mutated_line": "return polynomial([x ** amt for x in self.data])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x ** amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if times > 1000:",
      "mutated_line": "if times > 1001:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1001:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if times > 1000:",
      "mutated_line": "if times > 999:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 999:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if times > 1000:",
      "mutated_line": "if times > 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 0:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if times > 1000:",
      "mutated_line": "if times > 1:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if times > 1000:",
      "mutated_line": "if times > -1000:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > -1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) / (tmp[-1] // other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) / (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - ((other << len(tmp) - len(other)) + tmp[-1] // other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - ((other << len(tmp) - len(other)) + tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) ** (tmp[-1] // other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) ** (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return gcdSteps(p2, p1 % p2, steps + 1)",
      "mutated_line": "return gcdSteps(p2, p1 % p2, steps + 2)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 2)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return gcdSteps(p2, p1 % p2, steps + 1)",
      "mutated_line": "return gcdSteps(p2, p1 % p2, steps + 0)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 0)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return gcdSteps(p2, p1 % p2, steps + 1)",
      "mutated_line": "return gcdSteps(p2, p1 % p2, steps + 0)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 0)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 49,
      "original_line": "return gcdSteps(p2, p1 % p2, steps + 1)",
      "mutated_line": "return gcdSteps(p2, p1 % p2, steps + -1)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + -1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "(a, b) = (b + (a << 1), a)",
      "mutated_line": "(a, b) = (b + (a << 2), a)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 2), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "(a, b) = (b + (a << 1), a)",
      "mutated_line": "(a, b) = (b + (a << 0), a)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 0), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "(a, b) = (b + (a << 1), a)",
      "mutated_line": "(a, b) = (b + (a << 0), a)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 0), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "(a, b) = (b + (a << 1), a)",
      "mutated_line": "(a, b) = (b + (a << -1), a)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << -1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data - [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data - [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data * ([0] * 1000))]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data * ([0] * 1000))]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[+1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[+1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "del newData[-1]",
      "mutated_line": "del newData[-2]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-2]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "del newData[-1]",
      "mutated_line": "del newData[-0]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-0]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "del newData[-1]",
      "mutated_line": "del newData[-0]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-0]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "del newData[-1]",
      "mutated_line": "del newData[--1]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[--1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data - [0] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data - [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data * ([0] * 1000), other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data * ([0] * 1000), other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data - [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data - [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data * ([0] * 1000))]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data * ([0] * 1000))]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[+1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[+1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "del newData[-1]",
      "mutated_line": "del newData[-2]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-2]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "del newData[-1]",
      "mutated_line": "del newData[-0]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-0]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "del newData[-1]",
      "mutated_line": "del newData[-0]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-0]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "del newData[-1]",
      "mutated_line": "del newData[--1]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[--1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "exit(0)",
      "mutated_line": "exit(1)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(1)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "exit(0)",
      "mutated_line": "exit(-1)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(-1)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "exit(0)",
      "mutated_line": "exit(1)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(1)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] / other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] / other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] * other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] * other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return polynomial([0] * x + self.data)",
      "mutated_line": "return polynomial([1] * x + self.data)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([1] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return polynomial([0] * x + self.data)",
      "mutated_line": "return polynomial([-1] * x + self.data)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([-1] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "return polynomial([0] * x + self.data)",
      "mutated_line": "return polynomial([1] * x + self.data)",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([1] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] / 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] / 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data + ([0] + 1000))]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + ([0] + 1000))]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] ** 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] ** 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-2] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-2] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-0] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-0] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-0] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-0] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[--1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[--1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] / 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] / 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + ([0] + 1000), other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + ([0] + 1000), other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] ** 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] ** 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] / 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] / 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + ([0] + 1000))]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + ([0] + 1000))]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] ** 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] ** 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-2] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-2] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-0] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-0] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[-0] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-0] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "while len(newData) > 0 and newData[-1] == 0:",
      "mutated_line": "while len(newData) > 0 and newData[--1] == 0:",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[--1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) + len(other)) * (tmp[-1] // other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) + len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) * len(other)) * (tmp[-1] // other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) * len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1001)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1001)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 999)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 999)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 0)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 0)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * -1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * -1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1001, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1001, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 999, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 999, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 0, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 0, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * -1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * -1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1001)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1001)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 999)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 999)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 0)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 0)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * -1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * -1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[+1] // other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[+1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "UOI",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[+1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[+1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [1] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [1] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [-1] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [-1] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]",
      "mutated_line": "newData = [y - x for (y, x) in zip(self.data, other.data + [1] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [1] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [1] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [1] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [-1] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [-1] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [1] * 1000, other.data + [0] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [1] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [1] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [1] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [-1] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [-1] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]",
      "mutated_line": "newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [1] * 1000)]",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [1] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-2] // other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-2] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-0] // other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-0] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-0] // other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-0] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[--1] // other[-1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[--1] // other[-1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-2])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-2])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-0])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-0])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-0])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-0])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[-1])",
      "mutated_line": "tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[--1])",
      "code": "def generate_polynomials_for_gcd_steps(n):\n    if n < 1:\n        return None\n\n    class polynomial:\n\n        def __init__(self, data):\n            self.data = data\n\n        def __lshift__(self, x):\n            return polynomial([0] * x + self.data)\n\n        def __len__(self):\n            return len(self.data)\n\n        def __sub__(self, other):\n            newData = [y - x for (y, x) in zip(self.data, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __add__(self, other):\n            newData = [(y + x) % 2 for (y, x) in zip(self.data + [0] * 1000, other.data + [0] * 1000)]\n            while len(newData) > 0 and newData[-1] == 0:\n                del newData[-1]\n            return polynomial(newData)\n\n        def __mul__(self, amt):\n            return polynomial([x * amt for x in self.data])\n\n        def __getitem__(self, idx):\n            return self.data[idx]\n\n        def __mod__(self, other):\n            tmp = self\n            times = 0\n            while len(tmp) >= len(other):\n                times += 1\n                if times > 1000:\n                    print(*tmp.data)\n                    print(*other.data)\n                    exit(0)\n                tmp = tmp - (other << len(tmp) - len(other)) * (tmp[-1] // other[--1])\n            return tmp\n\n    def gcdSteps(p1, p2, steps=0):\n        if len(p1) == 0 or len(p2) == 0:\n            return steps\n        else:\n            return gcdSteps(p2, p1 % p2, steps + 1)\n    (a, b) = (polynomial([0, 1]), polynomial([1]))\n    for i in range(n - 1):\n        if gcdSteps(a, b) != i + 1:\n            return None\n        (a, b) = (b + (a << 1), a)\n    return (a.data, b.data)"
    }
  ]
}