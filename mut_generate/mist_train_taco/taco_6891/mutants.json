{
  "task_id": "taco_6891",
  "entry_point": "playerturnatpoint",
  "mutant_count": 195,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % 2 != b % 2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 != b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x > 0:",
      "mutated_line": "if x >= 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x >= 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x > 0:",
      "mutated_line": "if x <= 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x <= 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if x > 0:",
      "mutated_line": "if x != 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x != 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if y > 0:",
      "mutated_line": "if y >= 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y >= 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if y > 0:",
      "mutated_line": "if y <= 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y <= 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if y > 0:",
      "mutated_line": "if y != 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y != 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while len(queue) > 0:",
      "mutated_line": "while len(queue) >= 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) >= 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while len(queue) > 0:",
      "mutated_line": "while len(queue) <= 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) <= 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "while len(queue) > 0:",
      "mutated_line": "while len(queue) != 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) != 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a * 2 == b % 2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a * 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a + 2 == b % 2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a + 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % 2 == b * 2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b * 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % 2 == b + 2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b + 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 2\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 0\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 0\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return -1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 2",
      "mutated_line": "return 3",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 3\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 1\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 2",
      "mutated_line": "return 0",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 0\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 2",
      "mutated_line": "return 1",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 1\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "return 2",
      "mutated_line": "return -2",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return -2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x > 0:",
      "mutated_line": "if x > 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 1:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x > 0:",
      "mutated_line": "if x > -1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > -1:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "if x > 0:",
      "mutated_line": "if x > 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 1:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if y > 0:",
      "mutated_line": "if y > 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 1:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if y > 0:",
      "mutated_line": "if y > -1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > -1:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "if y > 0:",
      "mutated_line": "if y > 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 1:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while len(queue) > 0:",
      "mutated_line": "while len(queue) > 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 1:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while len(queue) > 0:",
      "mutated_line": "while len(queue) > -1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > -1:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "while len(queue) > 0:",
      "mutated_line": "while len(queue) > 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 1:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "LCR",
      "lineno": 18,
      "original_line": "if y == lenarr0 and x > 0:",
      "mutated_line": "if y == lenarr0 or x > 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 or x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if y > 0:",
      "mutated_line": "if y >= 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y >= 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if y > 0:",
      "mutated_line": "if y <= 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y <= 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if y > 0:",
      "mutated_line": "if y != 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y != 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "if x == lenarr and y != lenarr0:",
      "mutated_line": "if x == lenarr or y != lenarr0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr or y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp = [[0] * M for _ in range(N)]",
      "mutated_line": "dp = [[0] / M for _ in range(N)]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] / M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp = [[0] * M for _ in range(N)]",
      "mutated_line": "dp = [[0] + M for _ in range(N)]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] + M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "dp = [[0] * M for _ in range(N)]",
      "mutated_line": "dp = [[0] ** M for _ in range(N)]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] ** M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][+1] = grid[-1][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][+1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-1] = grid[-1][+1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][+1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "solve(grid, dp, N - 1, M - 1)",
      "mutated_line": "solve(grid, dp, N + 1, M - 1)",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N + 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "solve(grid, dp, N - 1, M - 1)",
      "mutated_line": "solve(grid, dp, N * 1, M - 1)",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N * 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "solve(grid, dp, N - 1, M - 1)",
      "mutated_line": "solve(grid, dp, N - 1, M + 1)",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M + 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "solve(grid, dp, N - 1, M - 1)",
      "mutated_line": "solve(grid, dp, N - 1, M * 1)",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M * 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[0][0]",
      "mutated_line": "return dp[0][1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[0][0]",
      "mutated_line": "return dp[0][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][-1]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[0][0]",
      "mutated_line": "return dp[0][1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][1]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % 3 == b % 2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 3 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % 1 == b % 2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 1 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % 0 == b % 2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 0 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % 1 == b % 2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 1 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % -2 == b % 2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % -2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % 2 == b % 3:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 3:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % 2 == b % 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 1:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % 2 == b % 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 0:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % 2 == b % 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 1:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "if a % 2 == b % 2:",
      "mutated_line": "if a % 2 == b % -2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % -2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if y == lenarr0 and x > 0:",
      "mutated_line": "if y != lenarr0 and x > 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y != lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if y == lenarr0 and x > 0:",
      "mutated_line": "if y == lenarr0 and x >= 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x >= 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if y == lenarr0 and x > 0:",
      "mutated_line": "if y == lenarr0 and x <= 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x <= 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if y == lenarr0 and x > 0:",
      "mutated_line": "if y == lenarr0 and x != 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x != 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if y > 0:",
      "mutated_line": "if y > 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 1:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if y > 0:",
      "mutated_line": "if y > -1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > -1:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "if y > 0:",
      "mutated_line": "if y > 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 1:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x == lenarr and y != lenarr0:",
      "mutated_line": "if x != lenarr and y != lenarr0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x != lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if x == lenarr and y != lenarr0:",
      "mutated_line": "if x == lenarr and y == lenarr0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y == lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "elif y == lenarr0 and x != lenarr:",
      "mutated_line": "elif y == lenarr0 or x != lenarr:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 or x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "M = len(grid[0])",
      "mutated_line": "M = len(grid[1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[1])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "M = len(grid[0])",
      "mutated_line": "M = len(grid[-1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[-1])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "M = len(grid[0])",
      "mutated_line": "M = len(grid[1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[1])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[+1][-1] = grid[-1][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[+1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-2] = grid[-1][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-2] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-0] = grid[-1][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-0] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-0] = grid[-1][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-0] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][--1] = grid[-1][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][--1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "UOI",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-1] = grid[+1][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[+1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-1] = grid[-1][-2]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-2]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-1] = grid[-1][-0]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-0]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-1] = grid[-1][-0]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-0]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-1] = grid[-1][--1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][--1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "solve(grid, dp, N - 1, M - 1)",
      "mutated_line": "solve(grid, dp, N - 2, M - 1)",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 2, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "solve(grid, dp, N - 1, M - 1)",
      "mutated_line": "solve(grid, dp, N - 0, M - 1)",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 0, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "solve(grid, dp, N - 1, M - 1)",
      "mutated_line": "solve(grid, dp, N - 0, M - 1)",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 0, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "solve(grid, dp, N - 1, M - 1)",
      "mutated_line": "solve(grid, dp, N - -1, M - 1)",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - -1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "solve(grid, dp, N - 1, M - 1)",
      "mutated_line": "solve(grid, dp, N - 1, M - 2)",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 2)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "solve(grid, dp, N - 1, M - 1)",
      "mutated_line": "solve(grid, dp, N - 1, M - 0)",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 0)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "solve(grid, dp, N - 1, M - 1)",
      "mutated_line": "solve(grid, dp, N - 1, M - 0)",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 0)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "solve(grid, dp, N - 1, M - 1)",
      "mutated_line": "solve(grid, dp, N - 1, M - -1)",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - -1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[0][0]",
      "mutated_line": "return dp[1][0]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[0][0]",
      "mutated_line": "return dp[-1][0]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[-1][0]"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return dp[0][0]",
      "mutated_line": "return dp[1][0]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[1][0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "queue.append([x - 1, y])",
      "mutated_line": "queue.append([x + 1, y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x + 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "queue.append([x - 1, y])",
      "mutated_line": "queue.append([x * 1, y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x * 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "queue.append([x, y - 1])",
      "mutated_line": "queue.append([x, y + 1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y + 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "queue.append([x, y - 1])",
      "mutated_line": "queue.append([x, y * 1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y * 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if y == lenarr0 and x > 0:",
      "mutated_line": "if y == lenarr0 and x > 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 1:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if y == lenarr0 and x > 0:",
      "mutated_line": "if y == lenarr0 and x > -1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > -1:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if y == lenarr0 and x > 0:",
      "mutated_line": "if y == lenarr0 and x > 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 1:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif y == lenarr0 and x != lenarr:",
      "mutated_line": "elif y != lenarr0 and x != lenarr:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y != lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "elif y == lenarr0 and x != lenarr:",
      "mutated_line": "elif y == lenarr0 and x == lenarr:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x == lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "elif turn == 2:",
      "mutated_line": "elif turn != 2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn != 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp = [[0] * M for _ in range(N)]",
      "mutated_line": "dp = [[1] * M for _ in range(N)]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[1] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp = [[0] * M for _ in range(N)]",
      "mutated_line": "dp = [[-1] * M for _ in range(N)]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[-1] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "dp = [[0] * M for _ in range(N)]",
      "mutated_line": "dp = [[1] * M for _ in range(N)]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[1] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-2][-1] = grid[-1][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-2][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-0][-1] = grid[-1][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-0][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-0][-1] = grid[-1][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-0][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[--1][-1] = grid[-1][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[--1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-1] = grid[-2][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-2][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-1] = grid[-0][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-0][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-1] = grid[-0][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-0][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "dp[-1][-1] = grid[-1][-1]",
      "mutated_line": "dp[-1][-1] = grid[--1][-1]",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[--1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append([x - 1, y])",
      "mutated_line": "queue.append([x - 2, y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 2, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append([x - 1, y])",
      "mutated_line": "queue.append([x - 0, y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 0, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append([x - 1, y])",
      "mutated_line": "queue.append([x - 0, y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 0, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "queue.append([x - 1, y])",
      "mutated_line": "queue.append([x - -1, y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - -1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append([x, y - 1])",
      "mutated_line": "queue.append([x, y - 2])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 2])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append([x, y - 1])",
      "mutated_line": "queue.append([x, y - 0])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 0])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append([x, y - 1])",
      "mutated_line": "queue.append([x, y - 0])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 0])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "queue.append([x, y - 1])",
      "mutated_line": "queue.append([x, y - -1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - -1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue.append([x - 1, y])",
      "mutated_line": "queue.append([x + 1, y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x + 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "queue.append([x - 1, y])",
      "mutated_line": "queue.append([x * 1, y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x * 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append([x, y - 1])",
      "mutated_line": "queue.append([x, y + 1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y + 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "queue.append([x, y - 1])",
      "mutated_line": "queue.append([x, y * 1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y * 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x][y + 1])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x][y - 1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y - 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x][y + 1])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x][y * 1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y * 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif turn == 2:",
      "mutated_line": "elif turn == 3:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 3:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif turn == 2:",
      "mutated_line": "elif turn == 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif turn == 2:",
      "mutated_line": "elif turn == 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 0:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif turn == 2:",
      "mutated_line": "elif turn == 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "elif turn == 2:",
      "mutated_line": "elif turn == -2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == -2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + 1] >= arr[x + 1][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] >= arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + 1] <= arr[x + 1][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] <= arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + 1] != arr[x + 1][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] != arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "ROR",
      "lineno": 32,
      "original_line": "elif turn == 1:",
      "mutated_line": "elif turn != 1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn != 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append([x - 1, y])",
      "mutated_line": "queue.append([x - 2, y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 2, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append([x - 1, y])",
      "mutated_line": "queue.append([x - 0, y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 0, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append([x - 1, y])",
      "mutated_line": "queue.append([x - 0, y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 0, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "queue.append([x - 1, y])",
      "mutated_line": "queue.append([x - -1, y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - -1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append([x, y - 1])",
      "mutated_line": "queue.append([x, y - 2])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 2])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append([x, y - 1])",
      "mutated_line": "queue.append([x, y - 0])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 0])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append([x, y - 1])",
      "mutated_line": "queue.append([x, y - 0])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 0])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "queue.append([x, y - 1])",
      "mutated_line": "queue.append([x, y - -1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - -1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x][y + 1])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x][y + 2])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 2])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x][y + 1])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x][y + 0])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 0])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x][y + 1])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x][y + 0])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 0])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x][y + 1])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x][y + -1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + -1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif turn == 1:",
      "mutated_line": "elif turn == 2:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif turn == 1:",
      "mutated_line": "elif turn == 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 0:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif turn == 1:",
      "mutated_line": "elif turn == 0:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 0:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "elif turn == 1:",
      "mutated_line": "elif turn == -1:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == -1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x + 1][y])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x - 1][y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x - 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x + 1][y])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x * 1][y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x * 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y - 1] > arr[x + 1][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y - 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y * 1] > arr[x + 1][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y * 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x + 1][y])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x + 2][y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 2][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x + 1][y])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x + 0][y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 0][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x + 1][y])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x + 0][y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 0][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x + 1][y])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x + -1][y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + -1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + 2] > arr[x + 1][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 2] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + 0] > arr[x + 1][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 0] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + 0] > arr[x + 1][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 0] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + -1] > arr[x + 1][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + -1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + 1] > arr[x - 1][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x - 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + 1] > arr[x * 1][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x * 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x][y + 1])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x][y - 1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y - 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x][y + 1])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x][y * 1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y * 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + 1] > arr[x + 2][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 2][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + 1] > arr[x + 0][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 0][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + 1] > arr[x + 0][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 0][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if arr[x][y + 1] > arr[x + 1][y]:",
      "mutated_line": "if arr[x][y + 1] > arr[x + -1][y]:",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + -1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x][y + 1])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x][y + 2])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 2])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x][y + 1])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x][y + 0])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 0])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x][y + 1])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x][y + 0])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 0])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x][y + 1])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x][y + -1])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + -1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x + 1][y])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x - 1][y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x - 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x + 1][y])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x * 1][y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x * 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))",
      "mutated_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y - 1]))",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y - 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))",
      "mutated_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y * 1]))",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y * 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x + 1][y])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x + 2][y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 2][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x + 1][y])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x + 0][y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 0][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x + 1][y])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x + 0][y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 0][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dp[x][y] = max(arr[x][y], dp[x + 1][y])",
      "mutated_line": "dp[x][y] = max(arr[x][y], dp[x + -1][y])",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + -1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))",
      "mutated_line": "dp[x][y] = max(arr[x][y], min(dp[x - 1][y], dp[x][y + 1]))",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x - 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))",
      "mutated_line": "dp[x][y] = max(arr[x][y], min(dp[x * 1][y], dp[x][y + 1]))",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x * 1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))",
      "mutated_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 2]))",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 2]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))",
      "mutated_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 0]))",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 0]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))",
      "mutated_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 0]))",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 0]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))",
      "mutated_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + -1]))",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + -1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))",
      "mutated_line": "dp[x][y] = max(arr[x][y], min(dp[x + 2][y], dp[x][y + 1]))",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 2][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))",
      "mutated_line": "dp[x][y] = max(arr[x][y], min(dp[x + 0][y], dp[x][y + 1]))",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 0][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))",
      "mutated_line": "dp[x][y] = max(arr[x][y], min(dp[x + 0][y], dp[x][y + 1]))",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + 0][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "dp[x][y] = max(arr[x][y], min(dp[x + 1][y], dp[x][y + 1]))",
      "mutated_line": "dp[x][y] = max(arr[x][y], min(dp[x + -1][y], dp[x][y + 1]))",
      "code": "from collections import deque\n\ndef playerturnatpoint(a, b):\n    if a % 2 == b % 2:\n        return 1\n    else:\n        return 2\n\ndef solve(arr, dp, x, y, queue=deque()):\n    lenarr = x\n    lenarr0 = y\n    if x > 0:\n        queue.append([x - 1, y])\n    if y > 0:\n        queue.append([x, y - 1])\n    while len(queue) > 0:\n        (x, y) = queue.popleft()\n        if y == lenarr0 and x > 0:\n            queue.append([x - 1, y])\n        if y > 0:\n            queue.append([x, y - 1])\n        turn = playerturnatpoint(x, y)\n        if x == lenarr and y != lenarr0:\n            dp[x][y] = max(arr[x][y], dp[x][y + 1])\n        elif y == lenarr0 and x != lenarr:\n            dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 2:\n            if arr[x][y + 1] > arr[x + 1][y]:\n                dp[x][y] = max(arr[x][y], dp[x][y + 1])\n            else:\n                dp[x][y] = max(arr[x][y], dp[x + 1][y])\n        elif turn == 1:\n            dp[x][y] = max(arr[x][y], min(dp[x + -1][y], dp[x][y + 1]))\n\ndef find_min_max_value(grid):\n    N = len(grid)\n    M = len(grid[0])\n    dp = [[0] * M for _ in range(N)]\n    dp[-1][-1] = grid[-1][-1]\n    solve(grid, dp, N - 1, M - 1)\n    return dp[0][0]"
    }
  ]
}