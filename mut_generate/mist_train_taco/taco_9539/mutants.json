{
  "task_id": "taco_9539",
  "entry_point": "find_longest_common_subsequence_without_virus",
  "mutant_count": 193,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v + 2, -1, -1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v + 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v * 2, -1, -1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v * 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 2, +1, -1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, +1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 2, -1, +1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, +1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v - 1 or virus[j] != virus[i + 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 or virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "next_suffix[i] = j - 1",
      "mutated_line": "next_suffix[i] = j + 1",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j + 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "next_suffix[i] = j - 1",
      "mutated_line": "next_suffix[i] = j * 1",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j * 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if k < 0:",
      "mutated_line": "if k <= 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k <= 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if k < 0:",
      "mutated_line": "if k >= 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k >= 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 26,
      "original_line": "if k < 0:",
      "mutated_line": "if k != 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k != 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i < 0 and j < 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 and j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 30,
      "original_line": "if s1[i] == s2[j]:",
      "mutated_line": "if s1[i] != s2[j]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] != s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n + 1, m - 1, v - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n + 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n * 1, m - 1, v - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n * 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 1, m + 1, v - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m + 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 1, m * 1, v - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m * 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 1, m - 1, v + 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v + 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 1, m - 1, v * 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v * 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 3, -1, -1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 3, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 1, -1, -1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 1, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 0, -1, -1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 0, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 1, -1, -1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 1, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - -2, -1, -1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - -2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 2, -2, -1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -2, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 2, -0, -1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -0, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 2, -0, -1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -0, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 2, --1, -1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, --1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 2, -1, -2):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -2):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 2, -1, -0):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -0):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 2, -1, -0):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -0):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "for i in range(v - 2, -1, -1):",
      "mutated_line": "for i in range(v - 2, -1, --1):",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, --1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "j = next_suffix[i + 1]",
      "mutated_line": "j = next_suffix[i - 1]",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i - 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "j = next_suffix[i + 1]",
      "mutated_line": "j = next_suffix[i * 1]",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i * 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j < v - 1 and virus[j] != virus[i + 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j < v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j > v - 1 and virus[j] != virus[i + 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j > v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j == v - 1 and virus[j] != virus[i + 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j == v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v - 1 and virus[j] == virus[i + 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] == virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_suffix[i] = j - 1",
      "mutated_line": "next_suffix[i] = j - 2",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 2\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_suffix[i] = j - 1",
      "mutated_line": "next_suffix[i] = j - 0",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 0\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_suffix[i] = j - 1",
      "mutated_line": "next_suffix[i] = j - 0",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 0\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "next_suffix[i] = j - 1",
      "mutated_line": "next_suffix[i] = j - -1",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - -1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "if args in memo:",
      "mutated_line": "if args not in memo:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args not in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if k < 0:",
      "mutated_line": "if k < 1:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 1:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if k < 0:",
      "mutated_line": "if k < -1:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < -1:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "if k < 0:",
      "mutated_line": "if k < 1:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 1:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i <= 0 or j < 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i <= 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i >= 0 or j < 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i >= 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i != 0 or j < 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i != 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i < 0 or j <= 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j <= 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i < 0 or j >= 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j >= 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i < 0 or j != 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j != 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if s1[i] != virus[k]:",
      "mutated_line": "if s1[i] == virus[k]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] == virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 2, m - 1, v - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 2, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 0, m - 1, v - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 0, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 0, m - 1, v - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 0, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - -1, m - 1, v - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - -1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 1, m - 2, v - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 2, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 1, m - 0, v - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 0, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 1, m - 0, v - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 0, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 1, m - -1, v - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - -1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 1, m - 1, v - 2)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 2)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 1, m - 1, v - 0)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 1, m - 1, v - 0)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 0)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "result = lcs(n - 1, m - 1, v - 1)",
      "mutated_line": "result = lcs(n - 1, m - 1, v - -1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - -1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = next_suffix[i + 1]",
      "mutated_line": "j = next_suffix[i + 2]",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 2]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = next_suffix[i + 1]",
      "mutated_line": "j = next_suffix[i + 0]",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 0]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = next_suffix[i + 1]",
      "mutated_line": "j = next_suffix[i + 0]",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 0]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = next_suffix[i + 1]",
      "mutated_line": "j = next_suffix[i + -1]",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + -1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v + 1 and virus[j] != virus[i + 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v + 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v * 1 and virus[j] != virus[i + 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v * 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return (float('-inf'), '')",
      "mutated_line": "return (float('-inf'), 'MUTATED')",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), 'MUTATED')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i < 1 or j < 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 1 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i < -1 or j < 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < -1 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i < 1 or j < 0:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 1 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i < 0 or j < 1:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 1:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i < 0 or j < -1:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < -1:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if i < 0 or j < 0:",
      "mutated_line": "if i < 0 or j < 1:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 1:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (0, '')",
      "mutated_line": "return (1, '')",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (1, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (0, '')",
      "mutated_line": "return (-1, '')",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (-1, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (0, '')",
      "mutated_line": "return (1, '')",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (1, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "return (0, '')",
      "mutated_line": "return (0, 'MUTATED')",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, 'MUTATED')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "LCR",
      "lineno": 33,
      "original_line": "while newk < v and virus[newk] != s1[i]:",
      "mutated_line": "while newk < v or virus[newk] != s1[i]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v or virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j + 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j + 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j * 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j * 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - 1, k), lcs(i + 1, j, k), key=lambda x: x[0])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i + 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - 1, k), lcs(i * 1, j, k), key=lambda x: x[0])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i * 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v - 2 and virus[j] != virus[i + 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 2 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v - 0 and virus[j] != virus[i + 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 0 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v - 0 and virus[j] != virus[i + 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 0 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v - -1 and virus[j] != virus[i + 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - -1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v - 1 and virus[j] != virus[i - 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i - 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v - 1 and virus[j] != virus[i * 1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i * 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "return (float('-inf'), '')",
      "mutated_line": "return (float(''), '')",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float(''), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while newk < v and virus[newk] != s1[i]:",
      "mutated_line": "while newk <= v and virus[newk] != s1[i]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk <= v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while newk < v and virus[newk] != s1[i]:",
      "mutated_line": "while newk >= v and virus[newk] != s1[i]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk >= v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while newk < v and virus[newk] != s1[i]:",
      "mutated_line": "while newk != v and virus[newk] != s1[i]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk != v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "while newk < v and virus[newk] != s1[i]:",
      "mutated_line": "while newk < v and virus[newk] == s1[i]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] == s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i + 1, j - 1, newk - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i + 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i * 1, j - 1, newk - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i * 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 1, j + 1, newk - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j + 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 1, j * 1, newk - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j * 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 1, j - 1, newk + 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk + 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 1, j - 1, newk * 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk * 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[0] - 1, r[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] - 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[0] * 1, r[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] * 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[0] + 1, r[1] - s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] - s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[0] + 1, r[1] * s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] * s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i + 1, j - 1, k - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i + 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i * 1, j - 1, k - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i * 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 1, j + 1, k - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j + 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 1, j * 1, k - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j * 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 1, j - 1, k + 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k + 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 1, j - 1, k * 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k * 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[0] - 1, r1[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] - 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[0] * 1, r1[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] * 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[0] + 1, r1[1] - s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] - s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[0] + 1, r1[1] * s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] * s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r2 = lcs(i - 1, j - 1, k)",
      "mutated_line": "r2 = lcs(i + 1, j - 1, k)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i + 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r2 = lcs(i - 1, j - 1, k)",
      "mutated_line": "r2 = lcs(i * 1, j - 1, k)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i * 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r2 = lcs(i - 1, j - 1, k)",
      "mutated_line": "r2 = lcs(i - 1, j + 1, k)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j + 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "r2 = lcs(i - 1, j - 1, k)",
      "mutated_line": "r2 = lcs(i - 1, j * 1, k)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j * 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - 2, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 2, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - 0, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 0, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - 0, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 0, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - -1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - -1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - 1, k), lcs(i - 2, j, k), key=lambda x: x[0])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 2, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - 1, k), lcs(i - 0, j, k), key=lambda x: x[0])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 0, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - 1, k), lcs(i - 0, j, k), key=lambda x: x[0])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 0, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - 1, k), lcs(i - -1, j, k), key=lambda x: x[0])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - -1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v - 1 and virus[j] != virus[i + 2]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 2]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v - 1 and virus[j] != virus[i + 0]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 0]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v - 1 and virus[j] != virus[i + 0]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 0]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "while j <= v - 1 and virus[j] != virus[i + 1]:",
      "mutated_line": "while j <= v - 1 and virus[j] != virus[i + -1]:",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + -1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 2, j - 1, newk - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 2, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 0, j - 1, newk - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 0, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 0, j - 1, newk - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 0, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - -1, j - 1, newk - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - -1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 1, j - 2, newk - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 2, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 1, j - 0, newk - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 0, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 1, j - 0, newk - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 0, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 1, j - -1, newk - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - -1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 1, j - 1, newk - 2)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 2)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 1, j - 1, newk - 0)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 0)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 1, j - 1, newk - 0)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 0)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "r = lcs(i - 1, j - 1, newk - 1)",
      "mutated_line": "r = lcs(i - 1, j - 1, newk - -1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - -1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[0] + 2, r[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 2, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[0] + 0, r[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 0, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[0] + 0, r[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 0, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[0] + -1, r[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + -1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 2, j - 1, k - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 2, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 0, j - 1, k - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 0, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 0, j - 1, k - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 0, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - -1, j - 1, k - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - -1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 1, j - 2, k - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 2, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 1, j - 0, k - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 0, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 1, j - 0, k - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 0, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 1, j - -1, k - 1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - -1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 1, j - 1, k - 2)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 2)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 1, j - 1, k - 0)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 0)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 1, j - 1, k - 0)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 0)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "r1 = lcs(i - 1, j - 1, k - 1)",
      "mutated_line": "r1 = lcs(i - 1, j - 1, k - -1)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - -1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[0] + 2, r1[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 2, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[0] + 0, r1[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 0, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[0] + 0, r1[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 0, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[0] + -1, r1[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + -1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r2 = lcs(i - 1, j - 1, k)",
      "mutated_line": "r2 = lcs(i - 2, j - 1, k)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 2, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r2 = lcs(i - 1, j - 1, k)",
      "mutated_line": "r2 = lcs(i - 0, j - 1, k)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 0, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r2 = lcs(i - 1, j - 1, k)",
      "mutated_line": "r2 = lcs(i - 0, j - 1, k)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 0, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r2 = lcs(i - 1, j - 1, k)",
      "mutated_line": "r2 = lcs(i - -1, j - 1, k)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - -1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r2 = lcs(i - 1, j - 1, k)",
      "mutated_line": "r2 = lcs(i - 1, j - 2, k)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 2, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r2 = lcs(i - 1, j - 1, k)",
      "mutated_line": "r2 = lcs(i - 1, j - 0, k)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 0, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r2 = lcs(i - 1, j - 1, k)",
      "mutated_line": "r2 = lcs(i - 1, j - 0, k)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 0, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "r2 = lcs(i - 1, j - 1, k)",
      "mutated_line": "r2 = lcs(i - 1, j - -1, k)",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - -1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[1])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[1])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[-1])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[-1])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])",
      "mutated_line": "return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[1])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[1])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[1] + 1, r[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[1] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[-1] + 1, r[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[-1] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[1] + 1, r[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[1] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[0] + 1, r[2] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[2] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[0] + 1, r[0] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[0] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[0] + 1, r[0] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[0] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "return (r[0] + 1, r[1] + s1[i])",
      "mutated_line": "return (r[0] + 1, r[-1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[-1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[1] + 1, r1[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[1] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[-1] + 1, r1[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[-1] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[1] + 1, r1[1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[1] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[0] + 1, r1[2] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[2] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[0] + 1, r1[0] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[0] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[0] + 1, r1[0] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[0] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "r1 = (r1[0] + 1, r1[1] + s1[i])",
      "mutated_line": "r1 = (r1[0] + 1, r1[-1] + s1[i])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[-1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[0])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return max(r1, r2, key=lambda x: x[0])",
      "mutated_line": "return max(r1, r2, key=lambda x: x[1])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[1])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return max(r1, r2, key=lambda x: x[0])",
      "mutated_line": "return max(r1, r2, key=lambda x: x[-1])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[-1])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "return max(r1, r2, key=lambda x: x[0])",
      "mutated_line": "return max(r1, r2, key=lambda x: x[1])",
      "code": "def find_longest_common_subsequence_without_virus(s1, s2, virus):\n    (n, m, v) = (len(s1), len(s2), len(virus))\n    next_suffix = [v for i in range(v)]\n    for i in range(v - 2, -1, -1):\n        j = next_suffix[i + 1]\n        while j <= v - 1 and virus[j] != virus[i + 1]:\n            j = next_suffix[j]\n        next_suffix[i] = j - 1\n\n    def memoize(function):\n        memo = dict()\n\n        def memoized(*args):\n            if args in memo:\n                return memo[args]\n            ans = function(*args)\n            memo[args] = ans\n            return ans\n        return memoized\n\n    @memoize\n    def lcs(i, j, k):\n        if k < 0:\n            return (float('-inf'), '')\n        if i < 0 or j < 0:\n            return (0, '')\n        if s1[i] == s2[j]:\n            if s1[i] != virus[k]:\n                newk = k\n                while newk < v and virus[newk] != s1[i]:\n                    newk = next_suffix[newk]\n                r = lcs(i - 1, j - 1, newk - 1)\n                return (r[0] + 1, r[1] + s1[i])\n            else:\n                r1 = lcs(i - 1, j - 1, k - 1)\n                r1 = (r1[0] + 1, r1[1] + s1[i])\n                r2 = lcs(i - 1, j - 1, k)\n                return max(r1, r2, key=lambda x: x[1])\n        return max(lcs(i, j - 1, k), lcs(i - 1, j, k), key=lambda x: x[0])\n    result = lcs(n - 1, m - 1, v - 1)\n    return result"
    }
  ]
}