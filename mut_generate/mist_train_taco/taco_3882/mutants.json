{
  "task_id": "taco_3882",
  "entry_point": "construct_directed_graph",
  "mutant_count": 131,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 101",
      "mutated_line": "N = 102",
      "code": "def construct_directed_graph(A, B, D):\n    N = 102\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 101",
      "mutated_line": "N = 100",
      "code": "def construct_directed_graph(A, B, D):\n    N = 100\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 101",
      "mutated_line": "N = 0",
      "code": "def construct_directed_graph(A, B, D):\n    N = 0\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 101",
      "mutated_line": "N = 1",
      "code": "def construct_directed_graph(A, B, D):\n    N = 1\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 101",
      "mutated_line": "N = -101",
      "code": "def construct_directed_graph(A, B, D):\n    N = -101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "F = [[0] * N for _ in range(N)]",
      "mutated_line": "F = [[0] / N for _ in range(N)]",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] / N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "F = [[0] * N for _ in range(N)]",
      "mutated_line": "F = [[0] + N for _ in range(N)]",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] + N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "F = [[0] * N for _ in range(N)]",
      "mutated_line": "F = [[0] ** N for _ in range(N)]",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] ** N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N + 1):",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N + 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N * 1):",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N * 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "S, T = 1, 102",
      "mutated_line": "(S, T) = (2, 102)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (2, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "S, T = 1, 102",
      "mutated_line": "(S, T) = (0, 102)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (0, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "S, T = 1, 102",
      "mutated_line": "(S, T) = (0, 102)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (0, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "S, T = 1, 102",
      "mutated_line": "(S, T) = (-1, 102)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (-1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "S, T = 1, 102",
      "mutated_line": "(S, T) = (1, 103)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 103)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "S, T = 1, 102",
      "mutated_line": "(S, T) = (1, 101)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 101)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "S, T = 1, 102",
      "mutated_line": "(S, T) = (1, 0)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 0)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "S, T = 1, 102",
      "mutated_line": "(S, T) = (1, 1)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 1)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "S, T = 1, 102",
      "mutated_line": "(S, T) = (1, -102)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, -102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return \"Possible\", 2 * N, M, edges, (S, T)",
      "mutated_line": "return ('', 2 * N, M, edges, (S, T))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return \"Possible\", 2 * N, M, edges, (S, T)",
      "mutated_line": "return ('Possible', 2 / N, M, edges, (S, T))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 / N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return \"Possible\", 2 * N, M, edges, (S, T)",
      "mutated_line": "return ('Possible', 2 + N, M, edges, (S, T))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 + N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "return \"Possible\", 2 * N, M, edges, (S, T)",
      "mutated_line": "return ('Possible', 2 ** N, M, edges, (S, T))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 ** N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 1\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res = 0",
      "mutated_line": "res = -1",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = -1\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "res = 0",
      "mutated_line": "res = 1",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 1\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = 101",
      "mutated_line": "v = 102",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 102\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = 101",
      "mutated_line": "v = 100",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 100\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = 101",
      "mutated_line": "v = 0",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 0\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = 101",
      "mutated_line": "v = 1",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 1\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "v = 101",
      "mutated_line": "v = -101",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = -101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if v != D[x][y]:",
      "mutated_line": "if v == D[x][y]:",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v == D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 2):",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 2):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 0):",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 0):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - 0):",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 0):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "for i in range(N - 1):",
      "mutated_line": "for i in range(N - -1):",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - -1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return \"Possible\", 2 * N, M, edges, (S, T)",
      "mutated_line": "return ('Possible', 3 * N, M, edges, (S, T))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 3 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return \"Possible\", 2 * N, M, edges, (S, T)",
      "mutated_line": "return ('Possible', 1 * N, M, edges, (S, T))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 1 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return \"Possible\", 2 * N, M, edges, (S, T)",
      "mutated_line": "return ('Possible', 0 * N, M, edges, (S, T))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 0 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return \"Possible\", 2 * N, M, edges, (S, T)",
      "mutated_line": "return ('Possible', 1 * N, M, edges, (S, T))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 1 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "return \"Possible\", 2 * N, M, edges, (S, T)",
      "mutated_line": "return ('Possible', -2 * N, M, edges, (S, T))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', -2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "F = [[0] * N for _ in range(N)]",
      "mutated_line": "F = [[1] * N for _ in range(N)]",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[1] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "F = [[0] * N for _ in range(N)]",
      "mutated_line": "F = [[-1] * N for _ in range(N)]",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[-1] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "F = [[0] * N for _ in range(N)]",
      "mutated_line": "F = [[1] * N for _ in range(N)]",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[1] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return \"Impossible\"",
      "mutated_line": "return ''",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return ''\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i - 1, i + 2, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i - 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i * 1, i + 2, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i * 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i + 1, i - 2, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i - 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i + 1, i * 2, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i * 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i + 1, i + 2, ''))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, ''))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((103 - i, 102 + i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 - i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((103 * i, 102 + i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 * i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((103 + i, 102 - i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 - i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((103 + i, 102 * i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 * i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((103 + i, 102 + i, ''))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, ''))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i + 2, i + 2, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 2, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i + 0, i + 2, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 0, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i + 0, i + 2, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 0, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i + -1, i + 2, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + -1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i + 1, i + 3, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 3, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i + 1, i + 1, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 1, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i + 1, i + 0, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 0, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i + 1, i + 1, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 1, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "edges.append((i + 1, i + 2, 'X'))",
      "mutated_line": "edges.append((i + 1, i + -2, 'X'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + -2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((104 + i, 102 + i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((104 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((102 + i, 102 + i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((102 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((0 + i, 102 + i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((0 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((1 + i, 102 + i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((1 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((-103 + i, 102 + i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((-103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((103 + i, 103 + i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 103 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((103 + i, 101 + i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 101 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((103 + i, 0 + i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 0 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((103 + i, 1 + i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 1 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "edges.append((103 + i, 102 + i, 'Y'))",
      "mutated_line": "edges.append((103 + i, -102 + i, 'Y'))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, -102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a - 1, 102 + b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a - 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a * 1, 102 + b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a * 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a + 1, 102 - b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 - b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a + 1, 102 * b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 * b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1) * a + (y + 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a + (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, (D[x][y] - (x + 1) * a) * ((y + 1) * b))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, (D[x][y] - (x + 1) * a) * ((y + 1) * b))\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) * a + (y + 1) * b - F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b - F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, ((x + 1) * a + (y + 1) * b) * F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, ((x + 1) * a + (y + 1) * b) * F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a + 2, 102 + b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 2, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a + 0, 102 + b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 0, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a + 0, 102 + b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 0, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a + -1, 102 + b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + -1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a + 1, 103 + b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 103 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a + 1, 101 + b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 101 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a + 1, 0 + b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 0 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a + 1, 1 + b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 1 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "edges.append((a + 1, 102 + b, F[a][b]))",
      "mutated_line": "edges.append((a + 1, -102 + b, F[a][b]))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, -102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] + (x + 1) * a - (y + 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] + (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] * ((x + 1) * a) - (y + 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] * ((x + 1) * a) - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) / b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) / b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1 + b))",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1 + b))\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) ** b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) ** b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) * a - (y + 1) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a - (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) * a * ((y + 1) * b) + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a * ((y + 1) * b) + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1) / a - (y + 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) / a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1 + a) - (y + 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1 + a) - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1) ** a - (y + 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) ** a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1) * a - (y - 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y - 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1) * a - y * 1 * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - y * 1 * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) / a + (y + 1) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) / a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, x + 1 + a + (y + 1) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, x + 1 + a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) ** a + (y + 1) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) ** a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) * a + (y + 1) / b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) / b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) * a + (y + 1 + b) + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1 + b) + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) * a + (y + 1) ** b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) ** b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x - 1) * a - (y + 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x - 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - x * 1 * a - (y + 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - x * 1 * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 2) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 2) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 0) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 0) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 0) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 0) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 1) * a - (y + -1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + -1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x - 1) * a + (y + 1) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x - 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, x * 1 * a + (y + 1) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, x * 1 * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) * a + (y - 1) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y - 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) * a + y * 1 * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + y * 1 * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 2) * a - (y + 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 2) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 0) * a - (y + 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 0) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + 0) * a - (y + 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 0) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)",
      "mutated_line": "res = max(res, D[x][y] - (x + -1) * a - (y + 1) * b)",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + -1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 2) * a + (y + 1) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 2) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 0) * a + (y + 1) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 0) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 0) * a + (y + 1) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 0) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + -1) * a + (y + 1) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + -1) * a + (y + 1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) * a + (y + 2) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 2) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) * a + (y + 0) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 0) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) * a + (y + 0) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + 0) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "v = min(v, (x + 1) * a + (y + 1) * b + F[a][b])",
      "mutated_line": "v = min(v, (x + 1) * a + (y + -1) * b + F[a][b])",
      "code": "def construct_directed_graph(A, B, D):\n    N = 101\n    F = [[0] * N for _ in range(N)]\n    for a in range(N):\n        for b in range(N):\n            res = 0\n            for x in range(A):\n                for y in range(B):\n                    res = max(res, D[x][y] - (x + 1) * a - (y + 1) * b)\n            F[a][b] = res\n    for x in range(A):\n        for y in range(B):\n            v = 101\n            for a in range(N):\n                for b in range(N):\n                    v = min(v, (x + 1) * a + (y + -1) * b + F[a][b])\n            if v != D[x][y]:\n                return 'Impossible'\n    edges = []\n    for i in range(N - 1):\n        edges.append((i + 1, i + 2, 'X'))\n        edges.append((103 + i, 102 + i, 'Y'))\n    for a in range(N):\n        for b in range(N):\n            edges.append((a + 1, 102 + b, F[a][b]))\n    (S, T) = (1, 102)\n    M = len(edges)\n    return ('Possible', 2 * N, M, edges, (S, T))"
    }
  ]
}