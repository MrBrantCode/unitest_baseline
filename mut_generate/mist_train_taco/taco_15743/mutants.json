{
  "task_id": "taco_15743",
  "entry_point": "count_regions_by_slashes",
  "mutant_count": 261,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "grid[y][x] = 1",
      "mutated_line": "grid[y][x] = 2",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 2\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "grid[y][x] = 1",
      "mutated_line": "grid[y][x] = 0",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 0\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "grid[y][x] = 1",
      "mutated_line": "grid[y][x] = 0",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 0\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "grid[y][x] = 1",
      "mutated_line": "grid[y][x] = -1",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = -1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) / 2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) / 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) + 2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) + 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [([0] * len(grid[0])) ** 2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [([0] * len(grid[0])) ** 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) or 0 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) or 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "LCR",
      "lineno": 16,
      "original_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0",
      "mutated_line": "check_orthog = lambda c: in_bounds(c) or grid[c[1]][c[0]] == 0",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) or grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "LCR",
      "lineno": 19,
      "original_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 0:",
      "mutated_line": "if not in_bounds(c) and grid[c[1]][c[0]] != 0:",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) and grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] / len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] / len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [([0] + len(grid[0])) * 2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [([0] + len(grid[0])) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] ** len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] ** len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * 3 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 3 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * 1 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 1 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * 0 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 0 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * 1 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 1 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * -2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * -2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 4,
      "original_line": "for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):",
      "mutated_line": "for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v not in '\\\\\\\\/'):",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v not in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 - (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 - (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 * (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 * (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 - (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 - (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 * (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 * (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 < c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 < c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 > c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 > c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 == c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 == c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 < c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 < c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 > c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 > c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 == c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 == c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0",
      "mutated_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] != 0",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] != 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 0:",
      "mutated_line": "if not in_bounds(c) or grid[c[1]][c[0]] == 0:",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] == 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return True\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(d_x, d_y) = (c[0] - x, c[1] - y)",
      "mutated_line": "(d_x, d_y) = (c[0] + x, c[1] - y)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] + x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(d_x, d_y) = (c[0] - x, c[1] - y)",
      "mutated_line": "(d_x, d_y) = (c[0] * x, c[1] - y)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] * x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(d_x, d_y) = (c[0] - x, c[1] - y)",
      "mutated_line": "(d_x, d_y) = (c[0] - x, c[1] + y)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] + y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "(d_x, d_y) = (c[0] - x, c[1] - y)",
      "mutated_line": "(d_x, d_y) = (c[0] - x, c[1] * y)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] * y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x > 0 > d_y and d_x < 0 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y and d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else ''",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else ''\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "LCR",
      "lineno": 23,
      "original_line": "return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)",
      "mutated_line": "return not (grid[y + d_y][x] == sep or grid[y][x + d_x] == sep)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep or grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])",
      "mutated_line": "return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v != 0])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v != 0])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) / 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) / 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) + 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) + 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) ** 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) ** 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):",
      "mutated_line": "for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in ''):",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in ''):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 - 0][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 - 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 * 0][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 * 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x / 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x / 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x + 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x + 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x ** 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x ** 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 - 1][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 - 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 * 1][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 * 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x / 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x / 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x + 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x + 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x ** 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x ** 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "destroy_island(c[0], c[1], grid)",
      "mutated_line": "destroy_island(c[1], c[1], grid)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[1], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "destroy_island(c[0], c[1], grid)",
      "mutated_line": "destroy_island(c[-1], c[1], grid)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[-1], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "destroy_island(c[0], c[1], grid)",
      "mutated_line": "destroy_island(c[1], c[1], grid)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[1], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "destroy_island(c[0], c[1], grid)",
      "mutated_line": "destroy_island(c[0], c[2], grid)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[2], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "destroy_island(c[0], c[1], grid)",
      "mutated_line": "destroy_island(c[0], c[0], grid)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[0], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "destroy_island(c[0], c[1], grid)",
      "mutated_line": "destroy_island(c[0], c[0], grid)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[0], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "destroy_island(c[0], c[1], grid)",
      "mutated_line": "destroy_island(c[0], c[-1], grid)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[-1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 1 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 1 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: -1 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: -1 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 1 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 1 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 1 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 1 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and -1 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and -1 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 1 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 1 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0",
      "mutated_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 1",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 1\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0",
      "mutated_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == -1",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == -1\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0",
      "mutated_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 1",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 1\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 0:",
      "mutated_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 1:",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 1:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 0:",
      "mutated_line": "if not in_bounds(c) or grid[c[1]][c[0]] != -1:",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != -1:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 0:",
      "mutated_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 1:",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 1:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x >= 0 > d_y or d_x < 0 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x >= 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x <= 0 > d_y or d_x < 0 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x <= 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x != 0 > d_y or d_x < 0 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x != 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x <= 0 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x <= 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x >= 0 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x >= 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x != 0 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x != 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)",
      "mutated_line": "return not (grid[y + d_y][x] != sep and grid[y][x + d_x] == sep)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] != sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)",
      "mutated_line": "return not (grid[y + d_y][x] == sep and grid[y][x + d_x] != sep)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] != sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])",
      "mutated_line": "return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 1])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])",
      "mutated_line": "return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == -1])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == -1])"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])",
      "mutated_line": "return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 1])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 1])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[1] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[1] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[-1] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[-1] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[1] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[1] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 3)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 3)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 1)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 1)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 0)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 0)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 1)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 1)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * -2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * -2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y / 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y / 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y + 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y + 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y ** 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y ** 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 1][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + -1][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + -1][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 1][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 3 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 3 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 1 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 1 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 0 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 0 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 1 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 1 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * -2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * -2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 + (1 if v != '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v != '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 + (2 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (2 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 + (0 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (0 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 + (0 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (0 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 + (-1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (-1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 1)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else -1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else -1)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 1)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y / 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y / 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y + 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y + 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y ** 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y ** 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 2][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 2][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 0][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 0][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + -1][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + -1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 3 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 3 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 1 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 1 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 0 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 0 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 1 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 1 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * -2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * -2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 + (0 if v != '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v != '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 + (1 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (1 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 + (-1 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (-1 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 + (1 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (1 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 2)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 2)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 0)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 0)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else -1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else -1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[2] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[2] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[0] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[0] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[0] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[0] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[-1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[-1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[1] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[1] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[-1] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[-1] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[1] < len(grid[c[1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[1] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(d_x, d_y) = (c[0] - x, c[1] - y)",
      "mutated_line": "(d_x, d_y) = (c[1] - x, c[1] - y)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[1] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(d_x, d_y) = (c[0] - x, c[1] - y)",
      "mutated_line": "(d_x, d_y) = (c[-1] - x, c[1] - y)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[-1] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(d_x, d_y) = (c[0] - x, c[1] - y)",
      "mutated_line": "(d_x, d_y) = (c[1] - x, c[1] - y)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[1] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(d_x, d_y) = (c[0] - x, c[1] - y)",
      "mutated_line": "(d_x, d_y) = (c[0] - x, c[2] - y)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[2] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(d_x, d_y) = (c[0] - x, c[1] - y)",
      "mutated_line": "(d_x, d_y) = (c[0] - x, c[0] - y)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[0] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(d_x, d_y) = (c[0] - x, c[1] - y)",
      "mutated_line": "(d_x, d_y) = (c[0] - x, c[0] - y)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[0] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "(d_x, d_y) = (c[0] - x, c[1] - y)",
      "mutated_line": "(d_x, d_y) = (c[0] - x, c[-1] - y)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[-1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x > 1 > d_y or d_x < 0 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 1 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x > -1 > d_y or d_x < 0 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > -1 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x > 1 > d_y or d_x < 0 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 1 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 1 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 1 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < -1 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < -1 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'",
      "mutated_line": "sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 1 < d_y else '/'",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 1 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[1]) * 2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[1]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[-1]) * 2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[-1]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]",
      "mutated_line": "new_grid = [[0] * len(grid[1]) * 2 for _ in range(len(grid) * 2)]",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[1]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 3 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 3 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 1 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 1 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 0 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 0 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 1 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 1 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * -2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * -2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v",
      "mutated_line": "new_grid[y * 2 + 0][x * 2 + (1 if v == '' else 0)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 3 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 3 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 1 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 1 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 0 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 0 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 1 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 1 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * -2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * -2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v",
      "mutated_line": "new_grid[y * 2 + 1][x * 2 + (0 if v == '' else 1)] = v",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0",
      "mutated_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[1]] == 0",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[1]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0",
      "mutated_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[-1]] == 0",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[-1]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0",
      "mutated_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[1]] == 0",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[1]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 0:",
      "mutated_line": "if not in_bounds(c) or grid[c[1]][c[1]] != 0:",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[1]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 0:",
      "mutated_line": "if not in_bounds(c) or grid[c[1]][c[-1]] != 0:",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[-1]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 0:",
      "mutated_line": "if not in_bounds(c) or grid[c[1]][c[1]] != 0:",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[1]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)",
      "mutated_line": "return not (grid[y + d_y][x] == sep and grid[y][x - d_x] == sep)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x - d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)",
      "mutated_line": "return not (grid[y + d_y][x] == sep and grid[y][x * d_x] == sep)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x * d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x + 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x + 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x * 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x * 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x - 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x - 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x * 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x * 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y + 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y + 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y * 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y * 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y - 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y - 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y * 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y * 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x - 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x - 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x * 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x * 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y - 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y - 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y * 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y * 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x - 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x - 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x * 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x * 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y + 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y + 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y * 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y * 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x + 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x + 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x * 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x * 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y - 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y - 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y * 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y * 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x + 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x + 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x * 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x * 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y + 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y + 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y * 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y * 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[2]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[2]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[0]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[0]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[0]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[0]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])",
      "mutated_line": "in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[-1]])",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[-1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0",
      "mutated_line": "check_orthog = lambda c: in_bounds(c) and grid[c[2]][c[0]] == 0",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[2]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0",
      "mutated_line": "check_orthog = lambda c: in_bounds(c) and grid[c[0]][c[0]] == 0",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[0]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0",
      "mutated_line": "check_orthog = lambda c: in_bounds(c) and grid[c[0]][c[0]] == 0",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[0]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0",
      "mutated_line": "check_orthog = lambda c: in_bounds(c) and grid[c[-1]][c[0]] == 0",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[-1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 0:",
      "mutated_line": "if not in_bounds(c) or grid[c[2]][c[0]] != 0:",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[2]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 0:",
      "mutated_line": "if not in_bounds(c) or grid[c[0]][c[0]] != 0:",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[0]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 0:",
      "mutated_line": "if not in_bounds(c) or grid[c[0]][c[0]] != 0:",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[0]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "if not in_bounds(c) or grid[c[1]][c[0]] != 0:",
      "mutated_line": "if not in_bounds(c) or grid[c[-1]][c[0]] != 0:",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[-1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)",
      "mutated_line": "return not (grid[y - d_y][x] == sep and grid[y][x + d_x] == sep)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y - d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)",
      "mutated_line": "return not (grid[y * d_y][x] == sep and grid[y][x + d_x] == sep)",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y * d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 2, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 2, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 0, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 0, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 0, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 0, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - -1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - -1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 2, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 2, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 0, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 0, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 0, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 0, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + -1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + -1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 2), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 2), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 0), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 0), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 0), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 0), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - -1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - -1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 2))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 2))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 0))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 0))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 0))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 0))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + -1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + -1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 2, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 2, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 0, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 0, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 0, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 0, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + -1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + -1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 2), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 2), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 0), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 0), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 0), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 0), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + -1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + -1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 2, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 2, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 0, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 0, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 0, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 0, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + -1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + -1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 2), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 2), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 0), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 0), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 0), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 0), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - -1), (x - 1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - -1), (x - 1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 2, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 2, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 0, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 0, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 0, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 0, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - -1, y + 1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - -1, y + 1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 2), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 2), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 0), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 0), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 0), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 0), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + -1), (x - 1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + -1), (x - 1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 2, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 2, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 0, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 0, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 0, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 0, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - -1, y - 1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - -1, y - 1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 2))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 2))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 0))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 0))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 0))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 0))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - 1))))",
      "mutated_line": "yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - -1))))",
      "code": "def count_regions_by_slashes(grid):\n\n    def convert_grid(grid):\n        new_grid = [[0] * len(grid[0]) * 2 for _ in range(len(grid) * 2)]\n        for (x, y, v) in ((x, y, v) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v in '\\\\\\\\/'):\n            new_grid[y * 2 + 0][x * 2 + (1 if v == '/' else 0)] = v\n            new_grid[y * 2 + 1][x * 2 + (0 if v == '/' else 1)] = v\n        return new_grid\n\n    def destroy_island(x, y, grid):\n        grid[y][x] = 1\n        for c in search(x, y, grid):\n            destroy_island(c[0], c[1], grid)\n\n    def search(x, y, grid):\n        in_bounds = lambda c: 0 <= c[1] < len(grid) and 0 <= c[0] < len(grid[c[1]])\n        check_orthog = lambda c: in_bounds(c) and grid[c[1]][c[0]] == 0\n\n        def check_diag(c):\n            if not in_bounds(c) or grid[c[1]][c[0]] != 0:\n                return False\n            (d_x, d_y) = (c[0] - x, c[1] - y)\n            sep = '\\\\\\\\' if d_x > 0 > d_y or d_x < 0 < d_y else '/'\n            return not (grid[y + d_y][x] == sep and grid[y][x + d_x] == sep)\n        yield from chain(filter(check_orthog, ((x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1))), filter(check_diag, ((x + 1, y + 1), (x + 1, y - 1), (x - 1, y + 1), (x - 1, y - -1))))\n    grid = convert_grid(grid)\n    return len([destroy_island(x, y, grid) for y in range(len(grid)) for (x, v) in enumerate(grid[y]) if v == 0])"
    }
  ]
}