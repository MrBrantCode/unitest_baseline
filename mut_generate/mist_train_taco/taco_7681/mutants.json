{
  "task_id": "taco_7681",
  "entry_point": "is_interleaved",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if len(s3) != len(s1) + len(s2):",
      "mutated_line": "if len(s3) == len(s1) + len(s2):",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) == len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 4,
      "original_line": "if not s1 or not s2:",
      "mutated_line": "if not s1 and (not s2):",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 and (not s2):\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "return True",
      "mutated_line": "return False",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return False"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "if len(s3) != len(s1) + len(s2):",
      "mutated_line": "if len(s3) != len(s1) - len(s2):",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) - len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 2,
      "original_line": "if len(s3) != len(s1) + len(s2):",
      "mutated_line": "if len(s3) != len(s1) * len(s2):",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) * len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return True\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 5,
      "original_line": "return (s1 or s2) == s3",
      "mutated_line": "return (s1 or s2) != s3",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) != s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 5,
      "original_line": "return (s1 or s2) == s3",
      "mutated_line": "return (s1 and s2) == s3",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 and s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "options = {(0, 0)}",
      "mutated_line": "options = {(1, 0)}",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(1, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "options = {(0, 0)}",
      "mutated_line": "options = {(-1, 0)}",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(-1, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "options = {(0, 0)}",
      "mutated_line": "options = {(1, 0)}",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(1, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "options = {(0, 0)}",
      "mutated_line": "options = {(0, 1)}",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 1)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "options = {(0, 0)}",
      "mutated_line": "options = {(0, -1)}",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, -1)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "options = {(0, 0)}",
      "mutated_line": "options = {(0, 1)}",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 1)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 10,
      "original_line": "if i1 < len(s1) and char == s1[i1]:",
      "mutated_line": "if i1 < len(s1) or char == s1[i1]:",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) or char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "LCR",
      "lineno": 12,
      "original_line": "if i2 < len(s2) and char == s2[i2]:",
      "mutated_line": "if i2 < len(s2) or char == s2[i2]:",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) or char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "return False",
      "mutated_line": "return True",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return True\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i1 < len(s1) and char == s1[i1]:",
      "mutated_line": "if i1 <= len(s1) and char == s1[i1]:",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 <= len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i1 < len(s1) and char == s1[i1]:",
      "mutated_line": "if i1 >= len(s1) and char == s1[i1]:",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 >= len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i1 < len(s1) and char == s1[i1]:",
      "mutated_line": "if i1 != len(s1) and char == s1[i1]:",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 != len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if i1 < len(s1) and char == s1[i1]:",
      "mutated_line": "if i1 < len(s1) and char != s1[i1]:",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char != s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i2 < len(s2) and char == s2[i2]:",
      "mutated_line": "if i2 <= len(s2) and char == s2[i2]:",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 <= len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i2 < len(s2) and char == s2[i2]:",
      "mutated_line": "if i2 >= len(s2) and char == s2[i2]:",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 >= len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i2 < len(s2) and char == s2[i2]:",
      "mutated_line": "if i2 != len(s2) and char == s2[i2]:",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 != len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if i2 < len(s2) and char == s2[i2]:",
      "mutated_line": "if i2 < len(s2) and char != s2[i2]:",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char != s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "new_options.add((i1 + 1, i2))",
      "mutated_line": "new_options.add((i1 - 1, i2))",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 - 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "new_options.add((i1 + 1, i2))",
      "mutated_line": "new_options.add((i1 * 1, i2))",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 * 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "new_options.add((i1, i2 + 1))",
      "mutated_line": "new_options.add((i1, i2 - 1))",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 - 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "new_options.add((i1, i2 + 1))",
      "mutated_line": "new_options.add((i1, i2 * 1))",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 * 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "new_options.add((i1 + 1, i2))",
      "mutated_line": "new_options.add((i1 + 2, i2))",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 2, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "new_options.add((i1 + 1, i2))",
      "mutated_line": "new_options.add((i1 + 0, i2))",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 0, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "new_options.add((i1 + 1, i2))",
      "mutated_line": "new_options.add((i1 + 0, i2))",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 0, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "new_options.add((i1 + 1, i2))",
      "mutated_line": "new_options.add((i1 + -1, i2))",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + -1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "new_options.add((i1, i2 + 1))",
      "mutated_line": "new_options.add((i1, i2 + 2))",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 2))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "new_options.add((i1, i2 + 1))",
      "mutated_line": "new_options.add((i1, i2 + 0))",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 0))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "new_options.add((i1, i2 + 1))",
      "mutated_line": "new_options.add((i1, i2 + 0))",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + 0))\n        options = new_options\n        if not options:\n            return False\n    return True"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "new_options.add((i1, i2 + 1))",
      "mutated_line": "new_options.add((i1, i2 + -1))",
      "code": "def is_interleaved(s1: str, s2: str, s3: str) -> bool:\n    if len(s3) != len(s1) + len(s2):\n        return False\n    if not s1 or not s2:\n        return (s1 or s2) == s3\n    options = {(0, 0)}\n    for char in s3:\n        new_options = set()\n        for (i1, i2) in options:\n            if i1 < len(s1) and char == s1[i1]:\n                new_options.add((i1 + 1, i2))\n            if i2 < len(s2) and char == s2[i2]:\n                new_options.add((i1, i2 + -1))\n        options = new_options\n        if not options:\n            return False\n    return True"
    }
  ]
}