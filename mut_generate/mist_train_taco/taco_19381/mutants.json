{
  "task_id": "taco_19381",
  "entry_point": "calculate_tree_diameters",
  "mutant_count": 150,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "level[u] = level[v] + 1",
      "mutated_line": "level[u] = level[v] - 1",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] - 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "level[u] = level[v] + 1",
      "mutated_line": "level[u] = level[v] * 1",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] * 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if u == v:",
      "mutated_line": "if u != v:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u != v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if level[u] < level[v]:",
      "mutated_line": "if level[u] <= level[v]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] <= level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if level[u] < level[v]:",
      "mutated_line": "if level[u] >= level[v]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] >= level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "if level[u] < level[v]:",
      "mutated_line": "if level[u] != level[v]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] != level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 17,
      "original_line": "if u == v:",
      "mutated_line": "if u != v:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u != v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]",
      "mutated_line": "return level[a] + level[b] + 2 * level[LCA(M, level, a, b)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] + 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]",
      "mutated_line": "return (level[a] + level[b]) * (2 * level[LCA(M, level, a, b)])",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return (level[a] + level[b]) * (2 * level[LCA(M, level, a, b)])\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "N = len(test_case) + 1",
      "mutated_line": "N = len(test_case) - 1",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) - 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "N = len(test_case) + 1",
      "mutated_line": "N = len(test_case) * 1",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) * 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "level = [0] * N",
      "mutated_line": "level = [0] / N",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] / N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "level = [0] * N",
      "mutated_line": "level = [0] + N",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] + N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "level = [0] * N",
      "mutated_line": "level = [0] ** N",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] ** N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "diameter = 0",
      "mutated_line": "diameter = 1",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 1\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "diameter = 0",
      "mutated_line": "diameter = -1",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = -1\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "diameter = 0",
      "mutated_line": "diameter = 1",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 1\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "level[u] = level[v] + 1",
      "mutated_line": "level[u] = level[v] + 2",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 2\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "level[u] = level[v] + 1",
      "mutated_line": "level[u] = level[v] + 0",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 0\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "level[u] = level[v] + 1",
      "mutated_line": "level[u] = level[v] + 0",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 0\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "level[u] = level[v] + 1",
      "mutated_line": "level[u] = level[v] + -1",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + -1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "M[u][0] = v",
      "mutated_line": "M[u][1] = v",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][1] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "M[u][0] = v",
      "mutated_line": "M[u][-1] = v",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][-1] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "M[u][0] = v",
      "mutated_line": "M[u][1] = v",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][1] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, 18):",
      "mutated_line": "for j in range(2, 18):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(2, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, 18):",
      "mutated_line": "for j in range(0, 18):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(0, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, 18):",
      "mutated_line": "for j in range(0, 18):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(0, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, 18):",
      "mutated_line": "for j in range(-1, 18):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(-1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, 18):",
      "mutated_line": "for j in range(1, 19):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 19):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, 18):",
      "mutated_line": "for j in range(1, 17):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 17):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, 18):",
      "mutated_line": "for j in range(1, 0):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 0):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, 18):",
      "mutated_line": "for j in range(1, 1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 1):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "for j in range(1, 18):",
      "mutated_line": "for j in range(1, -18):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, -18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(18, -1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(18, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(16, -1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(16, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(0, -1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(0, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(1, -1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(1, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(-17, -1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(-17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, +1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, +1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -1, +1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, +1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 15,
      "original_line": "if M[u][i] and level[M[u][i]] >= level[v]:",
      "mutated_line": "if M[u][i] or level[M[u][i]] >= level[v]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] or level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(18, -1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(18, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(16, -1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(16, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(0, -1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(0, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(1, -1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(1, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(-17, -1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(-17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, +1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, +1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -1, +1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, +1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "LCR",
      "lineno": 20,
      "original_line": "if M[u][i] and M[u][i] != M[v][i]:",
      "mutated_line": "if M[u][i] or M[u][i] != M[v][i]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] or M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return M[u][0]",
      "mutated_line": "return M[u][1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][1]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return M[u][0]",
      "mutated_line": "return M[u][-1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][-1]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "return M[u][0]",
      "mutated_line": "return M[u][1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][1]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]",
      "mutated_line": "return level[a] - level[b] - 2 * level[LCA(M, level, a, b)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] - level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]",
      "mutated_line": "return level[a] * level[b] - 2 * level[LCA(M, level, a, b)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] * level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]",
      "mutated_line": "return level[a] + level[b] - 2 / level[LCA(M, level, a, b)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 / level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]",
      "mutated_line": "return level[a] + level[b] - (2 + level[LCA(M, level, a, b)])",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - (2 + level[LCA(M, level, a, b)])\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]",
      "mutated_line": "return level[a] + level[b] - 2 ** level[LCA(M, level, a, b)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 ** level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "N = len(test_case) + 1",
      "mutated_line": "N = len(test_case) + 2",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 2\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "N = len(test_case) + 1",
      "mutated_line": "N = len(test_case) + 0",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 0\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "N = len(test_case) + 1",
      "mutated_line": "N = len(test_case) + 0",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 0\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "N = len(test_case) + 1",
      "mutated_line": "N = len(test_case) + -1",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + -1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(u, v) = (0, 0)",
      "mutated_line": "(u, v) = (1, 0)",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (1, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(u, v) = (0, 0)",
      "mutated_line": "(u, v) = (-1, 0)",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (-1, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(u, v) = (0, 0)",
      "mutated_line": "(u, v) = (1, 0)",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (1, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(u, v) = (0, 0)",
      "mutated_line": "(u, v) = (0, 1)",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 1)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(u, v) = (0, 0)",
      "mutated_line": "(u, v) = (0, -1)",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, -1)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "(u, v) = (0, 0)",
      "mutated_line": "(u, v) = (0, 1)",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 1)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(2, N):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(2, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(0, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(0, N):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(0, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "for i in range(1, N):",
      "mutated_line": "for i in range(-1, N):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(-1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if cur > diameter:",
      "mutated_line": "if cur >= diameter:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur >= diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if cur > diameter:",
      "mutated_line": "if cur <= diameter:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur <= diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 42,
      "original_line": "if cur > diameter:",
      "mutated_line": "if cur != diameter:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur != diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if M[u][j - 1]:",
      "mutated_line": "if M[u][j + 1]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j + 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if M[u][j - 1]:",
      "mutated_line": "if M[u][j * 1]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j * 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -2, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -2, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -0, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -0, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -0, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -0, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, --1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, --1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -1, -2):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -2):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -1, -0):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -0):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -1, -0):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -0):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -1, --1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, --1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if M[u][i] and level[M[u][i]] >= level[v]:",
      "mutated_line": "if M[u][i] and level[M[u][i]] > level[v]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] > level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if M[u][i] and level[M[u][i]] >= level[v]:",
      "mutated_line": "if M[u][i] and level[M[u][i]] < level[v]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] < level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if M[u][i] and level[M[u][i]] >= level[v]:",
      "mutated_line": "if M[u][i] and level[M[u][i]] == level[v]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] == level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -2, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -2, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -0, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -0, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -0, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -0, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, --1, -1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, --1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -1, -2):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -2):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -1, -0):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -0):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -1, -0):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -0):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for i in range(17, -1, -1):",
      "mutated_line": "for i in range(17, -1, --1):",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, --1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "if M[u][i] and M[u][i] != M[v][i]:",
      "mutated_line": "if M[u][i] and M[u][i] == M[v][i]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] == M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]",
      "mutated_line": "return level[a] + level[b] - 3 * level[LCA(M, level, a, b)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 3 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]",
      "mutated_line": "return level[a] + level[b] - 1 * level[LCA(M, level, a, b)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 1 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]",
      "mutated_line": "return level[a] + level[b] - 0 * level[LCA(M, level, a, b)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 0 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]",
      "mutated_line": "return level[a] + level[b] - 1 * level[LCA(M, level, a, b)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 1 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]",
      "mutated_line": "return level[a] + level[b] - -2 * level[LCA(M, level, a, b)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - -2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[1 for _ in range(18)] for _ in range(N + 5)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[1 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[-1 for _ in range(18)] for _ in range(N + 5)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[-1 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[1 for _ in range(18)] for _ in range(N + 5)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[1 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "level = [0] * N",
      "mutated_line": "level = [1] * N",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [1] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "level = [0] * N",
      "mutated_line": "level = [-1] * N",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [-1] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "level = [0] * N",
      "mutated_line": "level = [1] * N",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [1] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "p = test_case[i - 1]",
      "mutated_line": "p = test_case[i + 1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i + 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 39,
      "original_line": "p = test_case[i - 1]",
      "mutated_line": "p = test_case[i * 1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i * 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "update(M, level, i, p - 1)",
      "mutated_line": "update(M, level, i, p + 1)",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p + 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "update(M, level, i, p - 1)",
      "mutated_line": "update(M, level, i, p * 1)",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p * 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if cur > diameter:",
      "mutated_line": "if cur >= diameter:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur >= diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if cur > diameter:",
      "mutated_line": "if cur <= diameter:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur <= diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if cur > diameter:",
      "mutated_line": "if cur != diameter:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur != diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if M[u][j - 1]:",
      "mutated_line": "if M[u][j - 2]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 2]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if M[u][j - 1]:",
      "mutated_line": "if M[u][j - 0]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 0]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if M[u][j - 1]:",
      "mutated_line": "if M[u][j - 0]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 0]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if M[u][j - 1]:",
      "mutated_line": "if M[u][j - -1]:",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - -1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "M[u][j] = M[M[u][j - 1]][j - 1]",
      "mutated_line": "M[u][j] = M[M[u][j - 1]][j + 1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j + 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "M[u][j] = M[M[u][j - 1]][j - 1]",
      "mutated_line": "M[u][j] = M[M[u][j - 1]][j * 1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j * 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[0 for _ in range(18)] for _ in range(N - 5)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N - 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[0 for _ in range(18)] for _ in range(N * 5)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N * 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "p = test_case[i - 1]",
      "mutated_line": "p = test_case[i - 2]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 2]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "p = test_case[i - 1]",
      "mutated_line": "p = test_case[i - 0]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 0]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "p = test_case[i - 1]",
      "mutated_line": "p = test_case[i - 0]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 0]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "p = test_case[i - 1]",
      "mutated_line": "p = test_case[i - -1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - -1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "update(M, level, i, p - 1)",
      "mutated_line": "update(M, level, i, p - 2)",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 2)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "update(M, level, i, p - 1)",
      "mutated_line": "update(M, level, i, p - 0)",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 0)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "update(M, level, i, p - 1)",
      "mutated_line": "update(M, level, i, p - 0)",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 0)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "update(M, level, i, p - 1)",
      "mutated_line": "update(M, level, i, p - -1)",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - -1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "M[u][j] = M[M[u][j - 1]][j - 1]",
      "mutated_line": "M[u][j] = M[M[u][j - 1]][j - 2]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 2]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "M[u][j] = M[M[u][j - 1]][j - 1]",
      "mutated_line": "M[u][j] = M[M[u][j - 1]][j - 0]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 0]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "M[u][j] = M[M[u][j - 1]][j - 1]",
      "mutated_line": "M[u][j] = M[M[u][j - 1]][j - 0]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 0]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "M[u][j] = M[M[u][j - 1]][j - 1]",
      "mutated_line": "M[u][j] = M[M[u][j - 1]][j - -1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - -1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[0 for _ in range(19)] for _ in range(N + 5)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(19)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[0 for _ in range(17)] for _ in range(N + 5)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(17)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[0 for _ in range(0)] for _ in range(N + 5)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(0)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[0 for _ in range(1)] for _ in range(N + 5)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(1)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[0 for _ in range(-18)] for _ in range(N + 5)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(-18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[0 for _ in range(18)] for _ in range(N + 6)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 6)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[0 for _ in range(18)] for _ in range(N + 4)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 4)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[0 for _ in range(18)] for _ in range(N + 0)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 0)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[0 for _ in range(18)] for _ in range(N + 1)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 1)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "M = [[0 for _ in range(18)] for _ in range(N + 5)]",
      "mutated_line": "M = [[0 for _ in range(18)] for _ in range(N + -5)]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + -5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "M[u][j] = M[M[u][j - 1]][j - 1]",
      "mutated_line": "M[u][j] = M[M[u][j + 1]][j - 1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j + 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "M[u][j] = M[M[u][j - 1]][j - 1]",
      "mutated_line": "M[u][j] = M[M[u][j * 1]][j - 1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j * 1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "M[u][j] = M[M[u][j - 1]][j - 1]",
      "mutated_line": "M[u][j] = M[M[u][j - 2]][j - 1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 2]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "M[u][j] = M[M[u][j - 1]][j - 1]",
      "mutated_line": "M[u][j] = M[M[u][j - 0]][j - 1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 0]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "M[u][j] = M[M[u][j - 1]][j - 1]",
      "mutated_line": "M[u][j] = M[M[u][j - 0]][j - 1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - 0]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "M[u][j] = M[M[u][j - 1]][j - 1]",
      "mutated_line": "M[u][j] = M[M[u][j - -1]][j - 1]",
      "code": "def calculate_tree_diameters(test_cases):\n\n    def update(M, level, u, v):\n        level[u] = level[v] + 1\n        M[u][0] = v\n        for j in range(1, 18):\n            if M[u][j - 1]:\n                M[u][j] = M[M[u][j - -1]][j - 1]\n\n    def LCA(M, level, u, v):\n        if u == v:\n            return u\n        if level[u] < level[v]:\n            (u, v) = (v, u)\n        for i in range(17, -1, -1):\n            if M[u][i] and level[M[u][i]] >= level[v]:\n                u = M[u][i]\n        if u == v:\n            return u\n        for i in range(17, -1, -1):\n            if M[u][i] and M[u][i] != M[v][i]:\n                u = M[u][i]\n                v = M[v][i]\n        return M[u][0]\n\n    def distance(M, level, a, b):\n        return level[a] + level[b] - 2 * level[LCA(M, level, a, b)]\n    results = []\n    for test_case in test_cases:\n        N = len(test_case) + 1\n        M = [[0 for _ in range(18)] for _ in range(N + 5)]\n        level = [0] * N\n        (u, v) = (0, 0)\n        test_results = []\n        diameter = 0\n        for i in range(1, N):\n            p = test_case[i - 1]\n            update(M, level, i, p - 1)\n            cur = distance(M, level, i, u)\n            if cur > diameter:\n                diameter = cur\n                v = i\n            else:\n                cur = distance(M, level, i, v)\n                if cur > diameter:\n                    diameter = cur\n                    u = i\n            test_results.append(diameter)\n        results.append(test_results)\n    return results"
    }
  ]
}