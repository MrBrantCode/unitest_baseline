{
  "task_id": "taco_3796",
  "entry_point": "count_good_subsequences",
  "mutant_count": 157,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244354",
      "code": "MOD = 998244354\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244352",
      "code": "MOD = 998244352\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 0",
      "code": "MOD = 0\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 1",
      "code": "MOD = 1\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 1,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = -998244353",
      "code": "MOD = -998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] / (2 * n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] / (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] + (2 * n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] + (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] ** (2 * n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] ** (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mark = [0] * (n + 1)",
      "mutated_line": "mark = [0] / (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] / (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mark = [0] * (n + 1)",
      "mutated_line": "mark = [0] + (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] + (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mark = [0] * (n + 1)",
      "mutated_line": "mark = [0] ** (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] ** (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [-1] / (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] / (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [-1] + (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] + (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [-1] ** (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] ** (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "before = 1",
      "mutated_line": "before = 2",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 2\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "before = 1",
      "mutated_line": "before = 0",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 0\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "before = 1",
      "mutated_line": "before = 0",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 0\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "before = 1",
      "mutated_line": "before = -1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = -1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 1\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = -1\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 1\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while idx < len(self.bit):",
      "mutated_line": "while idx <= len(self.bit):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx <= len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while idx < len(self.bit):",
      "mutated_line": "while idx >= len(self.bit):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx >= len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "while idx < len(self.bit):",
      "mutated_line": "while idx != len(self.bit):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx != len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 13,
      "original_line": "self.bit[idx] += x",
      "mutated_line": "self.bit[idx] -= x",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] -= x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 1\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = 0",
      "mutated_line": "x = -1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = -1\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "x = 0",
      "mutated_line": "x = 1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 1\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "x += self.bit[end - 1]",
      "mutated_line": "x -= self.bit[end - 1]",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x -= self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (2 * n - 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n - 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (2 * n * 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n * 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mark = [0] * (n + 1)",
      "mutated_line": "mark = [0] * (n - 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n - 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "mark = [0] * (n + 1)",
      "mutated_line": "mark = [0] * (n * 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n * 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [-1] * (n - 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n - 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [-1] * (n * 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n * 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if other[sequence[i]] == -1:",
      "mutated_line": "if other[sequence[i]] != -1:",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] != -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] / (2 * n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] / (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] + (2 * n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] + (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] ** (2 * n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] ** (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "if mark[x] == 1:",
      "mutated_line": "if mark[x] != 1:",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] != 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "before += dp[x]",
      "mutated_line": "before -= dp[x]",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before -= dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 44,
      "original_line": "ans += dp[x]",
      "mutated_line": "ans -= dp[x]",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans -= dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "j = i | (i + 1)",
      "mutated_line": "j = i & i + 1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i & i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "j = i | (i + 1)",
      "mutated_line": "j = i ^ i + 1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i ^ i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j < len(x):",
      "mutated_line": "if j <= len(x):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j <= len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j < len(x):",
      "mutated_line": "if j >= len(x):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j >= len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if j < len(x):",
      "mutated_line": "if j != len(x):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j != len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 9,
      "original_line": "x[j] += x[i]",
      "mutated_line": "x[j] -= x[i]",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] -= x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "idx |= idx + 1",
      "mutated_line": "idx |= idx - 1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx - 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "idx |= idx + 1",
      "mutated_line": "idx |= idx * 1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx * 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "end &= end - 1",
      "mutated_line": "end &= end + 1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end + 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "end &= end - 1",
      "mutated_line": "end &= end * 1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end * 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [1] * (2 * n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [1] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [-1] * (2 * n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [-1] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [1] * (2 * n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [1] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (2 / n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 / n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (2 + n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 + n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (2 ** n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 ** n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (2 * n + 2)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 2)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (2 * n + 0)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 0)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (2 * n + 0)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 0)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (2 * n + -1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + -1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mark = [0] * (n + 1)",
      "mutated_line": "mark = [1] * (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [1] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mark = [0] * (n + 1)",
      "mutated_line": "mark = [-1] * (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [-1] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mark = [0] * (n + 1)",
      "mutated_line": "mark = [1] * (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [1] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mark = [0] * (n + 1)",
      "mutated_line": "mark = [0] * (n + 2)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 2)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mark = [0] * (n + 1)",
      "mutated_line": "mark = [0] * (n + 0)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 0)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mark = [0] * (n + 1)",
      "mutated_line": "mark = [0] * (n + 0)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 0)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "mark = [0] * (n + 1)",
      "mutated_line": "mark = [0] * (n + -1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + -1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [+1] * (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [+1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [-1] * (n + 2)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 2)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [-1] * (n + 0)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 0)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [-1] * (n + 0)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 0)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [-1] * (n + -1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + -1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for i in reversed(range(2 * n)):",
      "mutated_line": "for i in reversed(range(2 / n)):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 / n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for i in reversed(range(2 * n)):",
      "mutated_line": "for i in reversed(range(2 + n)):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 + n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "for i in reversed(range(2 * n)):",
      "mutated_line": "for i in reversed(range(2 ** n)):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 ** n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "if other[sequence[i]] == -1:",
      "mutated_line": "if other[sequence[i]] == +1:",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == +1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (2 * n - 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n - 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (2 * n * 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n * 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if mark[x] == 1:",
      "mutated_line": "if mark[x] == 2:",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 2:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if mark[x] == 1:",
      "mutated_line": "if mark[x] == 0:",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 0:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if mark[x] == 1:",
      "mutated_line": "if mark[x] == 0:",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 0:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "if mark[x] == 1:",
      "mutated_line": "if mark[x] == -1:",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == -1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "mark[x] = 1",
      "mutated_line": "mark[x] = 2",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 2\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "mark[x] = 1",
      "mutated_line": "mark[x] = 0",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 0\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "mark[x] = 1",
      "mutated_line": "mark[x] = 0",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 0\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "mark[x] = 1",
      "mutated_line": "mark[x] = -1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = -1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp[x] = 2 * before + F.query(other[x])",
      "mutated_line": "dp[x] = 2 * before - F.query(other[x])",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before - F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp[x] = 2 * before + F.query(other[x])",
      "mutated_line": "dp[x] = 2 * before * F.query(other[x])",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before * F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "j = i | (i + 1)",
      "mutated_line": "j = i | i - 1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i - 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "j = i | (i + 1)",
      "mutated_line": "j = i | i * 1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i * 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "idx |= idx + 1",
      "mutated_line": "idx |= idx + 2",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 2\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "idx |= idx + 1",
      "mutated_line": "idx |= idx + 0",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 0\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "idx |= idx + 1",
      "mutated_line": "idx |= idx + 0",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 0\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "idx |= idx + 1",
      "mutated_line": "idx |= idx + -1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + -1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "x += self.bit[end - 1]",
      "mutated_line": "x += self.bit[end + 1]",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end + 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "x += self.bit[end - 1]",
      "mutated_line": "x += self.bit[end * 1]",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end * 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "end &= end - 1",
      "mutated_line": "end &= end - 2",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 2\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "end &= end - 1",
      "mutated_line": "end &= end - 0",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 0\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "end &= end - 1",
      "mutated_line": "end &= end - 0",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 0\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "end &= end - 1",
      "mutated_line": "end &= end - -1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - -1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (3 * n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (3 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (1 * n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (1 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (0 * n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (0 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (1 * n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (1 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "dp = [0] * (2 * n + 1)",
      "mutated_line": "dp = [0] * (-2 * n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (-2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [-2] * (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-2] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [-0] * (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-0] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [-0] * (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-0] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "other = [-1] * (n + 1)",
      "mutated_line": "other = [--1] * (n + 1)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [--1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in reversed(range(2 * n)):",
      "mutated_line": "for i in reversed(range(3 * n)):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(3 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in reversed(range(2 * n)):",
      "mutated_line": "for i in reversed(range(1 * n)):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(1 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in reversed(range(2 * n)):",
      "mutated_line": "for i in reversed(range(0 * n)):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(0 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in reversed(range(2 * n)):",
      "mutated_line": "for i in reversed(range(1 * n)):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(1 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "for i in reversed(range(2 * n)):",
      "mutated_line": "for i in reversed(range(-2 * n)):",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(-2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if other[sequence[i]] == -1:",
      "mutated_line": "if other[sequence[i]] == -2:",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -2:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if other[sequence[i]] == -1:",
      "mutated_line": "if other[sequence[i]] == -0:",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -0:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if other[sequence[i]] == -1:",
      "mutated_line": "if other[sequence[i]] == -0:",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -0:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if other[sequence[i]] == -1:",
      "mutated_line": "if other[sequence[i]] == --1:",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == --1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([1] * (2 * n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([1] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([-1] * (2 * n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([-1] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([1] * (2 * n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([1] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (2 / n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 / n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (2 + n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 + n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (2 ** n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 ** n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (2 * n + 6))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 6))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (2 * n + 4))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 4))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (2 * n + 0))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 0))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (2 * n + 1))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 1))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (2 * n + -5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + -5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "F.update(other[x], -dp[x] % MOD)",
      "mutated_line": "F.update(other[x], -dp[x] * MOD)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] * MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "F.update(other[x], -dp[x] % MOD)",
      "mutated_line": "F.update(other[x], -dp[x] + MOD)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] + MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp[x] = 2 * before + F.query(other[x])",
      "mutated_line": "dp[x] = 2 / before + F.query(other[x])",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 / before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp[x] = 2 * before + F.query(other[x])",
      "mutated_line": "dp[x] = 2 + before + F.query(other[x])",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 + before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 43,
      "original_line": "dp[x] = 2 * before + F.query(other[x])",
      "mutated_line": "dp[x] = 2 ** before + F.query(other[x])",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 ** before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "F.update(other[x], dp[x] % MOD)",
      "mutated_line": "F.update(other[x], dp[x] * MOD)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] * MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "F.update(other[x], dp[x] % MOD)",
      "mutated_line": "F.update(other[x], dp[x] + MOD)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] + MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = i | (i + 1)",
      "mutated_line": "j = i | i + 2",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 2\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = i | (i + 1)",
      "mutated_line": "j = i | i + 0",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 0\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = i | (i + 1)",
      "mutated_line": "j = i | i + 0",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 0\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "j = i | (i + 1)",
      "mutated_line": "j = i | i + -1",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + -1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x += self.bit[end - 1]",
      "mutated_line": "x += self.bit[end - 2]",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 2]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x += self.bit[end - 1]",
      "mutated_line": "x += self.bit[end - 0]",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 0]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x += self.bit[end - 1]",
      "mutated_line": "x += self.bit[end - 0]",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 0]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x += self.bit[end - 1]",
      "mutated_line": "x += self.bit[end - -1]",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - -1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (3 * n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (3 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (1 * n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (1 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (0 * n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (0 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (1 * n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (1 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "F = FenwickTree([0] * (2 * n + 5))",
      "mutated_line": "F = FenwickTree([0] * (-2 * n + 5))",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (-2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 38,
      "original_line": "F.update(other[x], -dp[x] % MOD)",
      "mutated_line": "F.update(other[x], +dp[x] % MOD)",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], +dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[x] = 2 * before + F.query(other[x])",
      "mutated_line": "dp[x] = 3 * before + F.query(other[x])",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 3 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[x] = 2 * before + F.query(other[x])",
      "mutated_line": "dp[x] = 1 * before + F.query(other[x])",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 1 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[x] = 2 * before + F.query(other[x])",
      "mutated_line": "dp[x] = 0 * before + F.query(other[x])",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 0 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[x] = 2 * before + F.query(other[x])",
      "mutated_line": "dp[x] = 1 * before + F.query(other[x])",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = 1 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "dp[x] = 2 * before + F.query(other[x])",
      "mutated_line": "dp[x] = -2 * before + F.query(other[x])",
      "code": "MOD = 998244353\n\nclass FenwickTree:\n\n    def __init__(self, x):\n        self.bit = x[:]\n        for i in range(len(x)):\n            j = i | i + 1\n            if j < len(x):\n                x[j] += x[i]\n\n    def update(self, idx, x):\n        while idx < len(self.bit):\n            self.bit[idx] += x\n            idx |= idx + 1\n\n    def query(self, end):\n        x = 0\n        while end:\n            x += self.bit[end - 1]\n            end &= end - 1\n        return x\n\ndef count_good_subsequences(n, sequence):\n    dp = [0] * (2 * n + 1)\n    mark = [0] * (n + 1)\n    other = [-1] * (n + 1)\n    for i in reversed(range(2 * n)):\n        if other[sequence[i]] == -1:\n            other[sequence[i]] = i\n    F = FenwickTree([0] * (2 * n + 5))\n    before = 1\n    ans = 0\n    for x in sequence:\n        if mark[x] == 1:\n            F.update(other[x], -dp[x] % MOD)\n            before += dp[x]\n            before %= MOD\n        else:\n            mark[x] = 1\n            dp[x] = -2 * before + F.query(other[x])\n            ans += dp[x]\n            F.update(other[x], dp[x] % MOD)\n            ans %= MOD\n    return ans"
    }
  ]
}