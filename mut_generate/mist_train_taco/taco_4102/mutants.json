{
  "task_id": "taco_4102",
  "entry_point": "can_deliver_treasures",
  "mutant_count": 130,
  "mutants": [
    {
      "operator": "ASR",
      "lineno": 4,
      "original_line": "s -= 1",
      "mutated_line": "s += 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s += 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 5,
      "original_line": "e -= 1",
      "mutated_line": "e += 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e += 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s -= 1",
      "mutated_line": "s -= 2",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 2\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s -= 1",
      "mutated_line": "s -= 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 0\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s -= 1",
      "mutated_line": "s -= 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 0\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "s -= 1",
      "mutated_line": "s -= -1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= -1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "e -= 1",
      "mutated_line": "e -= 2",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 2\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "e -= 1",
      "mutated_line": "e -= 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 0\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "e -= 1",
      "mutated_line": "e -= 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 0\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "e -= 1",
      "mutated_line": "e -= -1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= -1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "f = [0] * n",
      "mutated_line": "f = [0] / n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] / n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "f = [0] * n",
      "mutated_line": "f = [0] + n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] + n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "f = [0] * n",
      "mutated_line": "f = [0] ** n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] ** n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "a -= 1",
      "mutated_line": "a += 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a += 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "b -= 1",
      "mutated_line": "b += 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b += 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "f[a] += 1",
      "mutated_line": "f[a] -= 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] -= 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 15,
      "original_line": "f[b] += 1",
      "mutated_line": "f[b] -= 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] -= 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [1] / n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] / n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [1] + n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] + n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [1] ** n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] ** n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "bfs[s] = 0",
      "mutated_line": "bfs[s] = 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 1\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "bfs[s] = 0",
      "mutated_line": "bfs[s] = -1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = -1\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "bfs[s] = 0",
      "mutated_line": "bfs[s] = 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 1\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "par = [None] * n",
      "mutated_line": "par = [None] / n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] / n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "par = [None] * n",
      "mutated_line": "par = [None] + n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] + n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "par = [None] * n",
      "mutated_line": "par = [None] ** n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] ** n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "path = [0] * n",
      "mutated_line": "path = [0] / n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] / n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "path = [0] * n",
      "mutated_line": "path = [0] + n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] + n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "path = [0] * n",
      "mutated_line": "path = [0] ** n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] ** n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "while e != s:",
      "mutated_line": "while e == s:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e == s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [1] / n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] / n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [1] + n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] + n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 35,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [1] ** n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] ** n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bfs[s] = 0",
      "mutated_line": "bfs[s] = 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 1\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bfs[s] = 0",
      "mutated_line": "bfs[s] = -1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = -1\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "bfs[s] = 0",
      "mutated_line": "bfs[s] = 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 1\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 59,
      "original_line": "return 'Yes'",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return ''"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a -= 1",
      "mutated_line": "a -= 2",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 2\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 0\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a -= 1",
      "mutated_line": "a -= 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 0\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "a -= 1",
      "mutated_line": "a -= -1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= -1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "b -= 1",
      "mutated_line": "b -= 2",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 2\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 0\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "b -= 1",
      "mutated_line": "b -= 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 0\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "b -= 1",
      "mutated_line": "b -= -1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= -1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[a] += 1",
      "mutated_line": "f[a] += 2",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 2\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[a] += 1",
      "mutated_line": "f[a] += 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 0\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[a] += 1",
      "mutated_line": "f[a] += 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 0\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "f[a] += 1",
      "mutated_line": "f[a] += -1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += -1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[b] += 1",
      "mutated_line": "f[b] += 2",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 2\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[b] += 1",
      "mutated_line": "f[b] += 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 0\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[b] += 1",
      "mutated_line": "f[b] += 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 0\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "f[b] += 1",
      "mutated_line": "f[b] += -1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += -1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path[e] = 1",
      "mutated_line": "path[e] = 2",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 2\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path[e] = 1",
      "mutated_line": "path[e] = 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 0\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path[e] = 1",
      "mutated_line": "path[e] = 0",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 0\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "path[e] = 1",
      "mutated_line": "path[e] = -1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = -1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ASR",
      "lineno": 55,
      "original_line": "child[x][i] -= t * (i + 1)",
      "mutated_line": "child[x][i] += t * (i + 1)",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] += t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "f = [0] * n",
      "mutated_line": "f = [1] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [1] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "f = [0] * n",
      "mutated_line": "f = [-1] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [-1] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "f = [0] * n",
      "mutated_line": "f = [1] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [1] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [2] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [2] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [0] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [0] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [0] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [0] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [-1] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [-1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "path = [0] * n",
      "mutated_line": "path = [1] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [1] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "path = [0] * n",
      "mutated_line": "path = [-1] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [-1] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "path = [0] * n",
      "mutated_line": "path = [1] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [1] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "e = par[e][0]",
      "mutated_line": "e = par[e][1]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][1]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "e = par[e][0]",
      "mutated_line": "e = par[e][-1]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][-1]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "e = par[e][0]",
      "mutated_line": "e = par[e][1]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][1]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [2] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [2] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [0] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [0] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [0] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [0] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "bfs = [1] * n",
      "mutated_line": "bfs = [-1] * n",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [-1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if par[x][1] <= 0:",
      "mutated_line": "if par[x][1] < 0:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] < 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if par[x][1] <= 0:",
      "mutated_line": "if par[x][1] > 0:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] > 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 51,
      "original_line": "if par[x][1] <= 0:",
      "mutated_line": "if par[x][1] == 0:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] == 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "child[x][i] -= t * (i + 1)",
      "mutated_line": "child[x][i] -= t / (i + 1)",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t / (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "child[x][i] -= t * (i + 1)",
      "mutated_line": "child[x][i] -= t + (i + 1)",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t + (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "child[x][i] -= t * (i + 1)",
      "mutated_line": "child[x][i] -= t ** (i + 1)",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t ** (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "if child[x][i] <= 0:",
      "mutated_line": "if child[x][i] < 0:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] < 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "if child[x][i] <= 0:",
      "mutated_line": "if child[x][i] > 0:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] > 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "ROR",
      "lineno": 56,
      "original_line": "if child[x][i] <= 0:",
      "mutated_line": "if child[x][i] == 0:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] == 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "bfs[y] = 0",
      "mutated_line": "bfs[y] = 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 1\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "bfs[y] = 0",
      "mutated_line": "bfs[y] = -1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = -1\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "bfs[y] = 0",
      "mutated_line": "bfs[y] = 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 1\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "bfs[y] = 0",
      "mutated_line": "bfs[y] = 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 1\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "bfs[y] = 0",
      "mutated_line": "bfs[y] = -1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = -1\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "bfs[y] = 0",
      "mutated_line": "bfs[y] = 1",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 1\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if par[x][1] <= 0:",
      "mutated_line": "if par[x][1] <= 1:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 1:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if par[x][1] <= 0:",
      "mutated_line": "if par[x][1] <= -1:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= -1:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if par[x][1] <= 0:",
      "mutated_line": "if par[x][1] <= 1:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 1:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "return 'No'",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return ''\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "child[x][i] -= t * (i + 1)",
      "mutated_line": "child[x][i] -= t * (i - 1)",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i - 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "child[x][i] -= t * (i + 1)",
      "mutated_line": "child[x][i] -= t * (i * 1)",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i * 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "if child[x][i] <= 0:",
      "mutated_line": "if child[x][i] <= 1:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 1:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "if child[x][i] <= 0:",
      "mutated_line": "if child[x][i] <= -1:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= -1:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 56,
      "original_line": "if child[x][i] <= 0:",
      "mutated_line": "if child[x][i] <= 1:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 1:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 57,
      "original_line": "return 'No'",
      "mutated_line": "return ''",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return ''\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "par[y] = [x, w - t * (f[x] - 1)]",
      "mutated_line": "par[y] = [x, w + t * (f[x] - 1)]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w + t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "par[y] = [x, w - t * (f[x] - 1)]",
      "mutated_line": "par[y] = [x, w * (t * (f[x] - 1))]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w * (t * (f[x] - 1))]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if par[x][1] <= 0:",
      "mutated_line": "if par[x][2] <= 0:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][2] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if par[x][1] <= 0:",
      "mutated_line": "if par[x][0] <= 0:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][0] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if par[x][1] <= 0:",
      "mutated_line": "if par[x][0] <= 0:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][0] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "if par[x][1] <= 0:",
      "mutated_line": "if par[x][-1] <= 0:",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][-1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "child[x][i] -= t * (i + 1)",
      "mutated_line": "child[x][i] -= t * (i + 2)",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 2)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "child[x][i] -= t * (i + 1)",
      "mutated_line": "child[x][i] -= t * (i + 0)",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 0)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "child[x][i] -= t * (i + 1)",
      "mutated_line": "child[x][i] -= t * (i + 0)",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 0)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 55,
      "original_line": "child[x][i] -= t * (i + 1)",
      "mutated_line": "child[x][i] -= t * (i + -1)",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + -1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "par[y] = [x, w - t * (f[x] - 1)]",
      "mutated_line": "par[y] = [x, w - t / (f[x] - 1)]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t / (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "par[y] = [x, w - t * (f[x] - 1)]",
      "mutated_line": "par[y] = [x, w - (t + (f[x] - 1))]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - (t + (f[x] - 1))]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "par[y] = [x, w - t * (f[x] - 1)]",
      "mutated_line": "par[y] = [x, w - t ** (f[x] - 1)]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t ** (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "child[x].append(w - t * (f[y] - 1))",
      "mutated_line": "child[x].append(w + t * (f[y] - 1))",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w + t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "child[x].append(w - t * (f[y] - 1))",
      "mutated_line": "child[x].append(w * (t * (f[y] - 1)))",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w * (t * (f[y] - 1)))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "par[y] = [x, w - t * (f[x] - 1)]",
      "mutated_line": "par[y] = [x, w - t * (f[x] + 1)]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] + 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "par[y] = [x, w - t * (f[x] - 1)]",
      "mutated_line": "par[y] = [x, w - t * (f[x] * 1)]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] * 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "child[x].append(w - t * (f[y] - 1))",
      "mutated_line": "child[x].append(w - t / (f[y] - 1))",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t / (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "child[x].append(w - t * (f[y] - 1))",
      "mutated_line": "child[x].append(w - (t + (f[y] - 1)))",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - (t + (f[y] - 1)))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "child[x].append(w - t * (f[y] - 1))",
      "mutated_line": "child[x].append(w - t ** (f[y] - 1))",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t ** (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "par[y] = [x, w - t * (f[x] - 1)]",
      "mutated_line": "par[y] = [x, w - t * (f[x] - 2)]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 2)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "par[y] = [x, w - t * (f[x] - 1)]",
      "mutated_line": "par[y] = [x, w - t * (f[x] - 0)]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 0)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "par[y] = [x, w - t * (f[x] - 1)]",
      "mutated_line": "par[y] = [x, w - t * (f[x] - 0)]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 0)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "par[y] = [x, w - t * (f[x] - 1)]",
      "mutated_line": "par[y] = [x, w - t * (f[x] - -1)]",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - -1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "child[x].append(w - t * (f[y] - 1))",
      "mutated_line": "child[x].append(w - t * (f[y] + 1))",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] + 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "child[x].append(w - t * (f[y] - 1))",
      "mutated_line": "child[x].append(w - t * (f[y] * 1))",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] * 1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "child[x].append(w - t * (f[y] - 1))",
      "mutated_line": "child[x].append(w - t * (f[y] - 2))",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 2))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "child[x].append(w - t * (f[y] - 1))",
      "mutated_line": "child[x].append(w - t * (f[y] - 0))",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 0))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "child[x].append(w - t * (f[y] - 1))",
      "mutated_line": "child[x].append(w - t * (f[y] - 0))",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - 0))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "child[x].append(w - t * (f[y] - 1))",
      "mutated_line": "child[x].append(w - t * (f[y] - -1))",
      "code": "from collections import defaultdict, deque\n\ndef can_deliver_treasures(n, t, s, e, bridges):\n    s -= 1\n    e -= 1\n    v = [[] for _ in range(n)]\n    f = [0] * n\n    for (a, b, w) in bridges:\n        a -= 1\n        b -= 1\n        v[a].append((b, w))\n        v[b].append((a, w))\n        f[a] += 1\n        f[b] += 1\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    par = [None] * n\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                par[y] = [x, w - t * (f[x] - 1)]\n                bfs[y] = 0\n                q.append(y)\n    path = [0] * n\n    while e != s:\n        path[e] = 1\n        e = par[e][0]\n    bfs = [1] * n\n    bfs[s] = 0\n    q = deque([s])\n    child = [[] for _ in range(n)]\n    while q:\n        x = q.popleft()\n        for (y, w) in v[x]:\n            if bfs[y]:\n                if not path[y]:\n                    child[x].append(w - t * (f[y] - -1))\n                bfs[y] = 0\n                q.append(y)\n    for x in range(n):\n        if path[x]:\n            if par[x][1] <= 0:\n                return 'No'\n        child[x].sort()\n        for i in range(len(child[x])):\n            child[x][i] -= t * (i + 1)\n            if child[x][i] <= 0:\n                return 'No'\n    return 'Yes'"
    }
  ]
}