{
  "task_id": "taco_6695",
  "entry_point": "count_valid_pairings",
  "mutant_count": 167,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 - 7",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 - 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 * 7",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 * 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 * 9 + 7",
      "code": "import sys\nimport numpy as np\nMOD = 10 * 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 + 9 + 7",
      "code": "import sys\nimport numpy as np\nMOD = 10 + 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 8",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 8\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 6",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 6\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 0",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 0\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + 1",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 1\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 9 + -7",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + -7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = (data * fact_2[:N + 1] % MOD).sum() * MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() * MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = (data * fact_2[:N + 1] % MOD).sum() + MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() + MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 11 ** 9 + 7",
      "code": "import sys\nimport numpy as np\nMOD = 11 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 9 ** 9 + 7",
      "code": "import sys\nimport numpy as np\nMOD = 9 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 0 ** 9 + 7",
      "code": "import sys\nimport numpy as np\nMOD = 0 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 1 ** 9 + 7",
      "code": "import sys\nimport numpy as np\nMOD = 1 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = -10 ** 9 + 7",
      "code": "import sys\nimport numpy as np\nMOD = -10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 10 + 7",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 10 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 8 + 7",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 8 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 0 + 7",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 0 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** 1 + 7",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 1 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "MOD = 10 ** 9 + 7",
      "mutated_line": "MOD = 10 ** -9 + 7",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** -9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "N1 = len(data1) - 1",
      "mutated_line": "N1 = len(data1) + 1",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) + 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "N1 = len(data1) - 1",
      "mutated_line": "N1 = len(data1) * 1",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) * 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "N2 = len(data2) - 1",
      "mutated_line": "N2 = len(data2) + 1",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) + 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "N2 = len(data2) - 1",
      "mutated_line": "N2 = len(data2) * 1",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) * 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if N1 > N2:",
      "mutated_line": "if N1 >= N2:",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 >= N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if N1 > N2:",
      "mutated_line": "if N1 <= N2:",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 <= N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if N1 > N2:",
      "mutated_line": "if N1 != N2:",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 != N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "ASR",
      "lineno": 20,
      "original_line": "data[n:n + N2] += data1[n] * data2[1:] % MOD",
      "mutated_line": "data[n:n + N2] -= data1[n] * data2[1:] % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] -= data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fact_2 = [1, 0, 1]",
      "mutated_line": "fact_2 = [2, 0, 1]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [2, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fact_2 = [1, 0, 1]",
      "mutated_line": "fact_2 = [0, 0, 1]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [0, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fact_2 = [1, 0, 1]",
      "mutated_line": "fact_2 = [0, 0, 1]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [0, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fact_2 = [1, 0, 1]",
      "mutated_line": "fact_2 = [-1, 0, 1]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [-1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fact_2 = [1, 0, 1]",
      "mutated_line": "fact_2 = [1, 1, 1]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 1, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fact_2 = [1, 0, 1]",
      "mutated_line": "fact_2 = [1, -1, 1]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, -1, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fact_2 = [1, 0, 1]",
      "mutated_line": "fact_2 = [1, 1, 1]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 1, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fact_2 = [1, 0, 1]",
      "mutated_line": "fact_2 = [1, 0, 2]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 2]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fact_2 = [1, 0, 1]",
      "mutated_line": "fact_2 = [1, 0, 0]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 0]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fact_2 = [1, 0, 1]",
      "mutated_line": "fact_2 = [1, 0, 0]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 0]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "fact_2 = [1, 0, 1]",
      "mutated_line": "fact_2 = [1, 0, -1]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, -1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in range(3, N + 10):",
      "mutated_line": "for n in range(4, N + 10):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(4, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in range(3, N + 10):",
      "mutated_line": "for n in range(2, N + 10):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(2, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in range(3, N + 10):",
      "mutated_line": "for n in range(0, N + 10):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(0, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in range(3, N + 10):",
      "mutated_line": "for n in range(1, N + 10):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(1, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in range(3, N + 10):",
      "mutated_line": "for n in range(-3, N + 10):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(-3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for n in range(3, N + 10):",
      "mutated_line": "for n in range(3, N - 10):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N - 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "for n in range(3, N + 10):",
      "mutated_line": "for n in range(3, N * 10):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N * 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "N = len(data) - 1",
      "mutated_line": "N = len(data) + 1",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) + 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 30,
      "original_line": "N = len(data) - 1",
      "mutated_line": "N = len(data) * 1",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) * 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() * MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() * MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() + MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() + MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 47,
      "original_line": "if data is None:",
      "mutated_line": "if data is not None:",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is not None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "data = dfs(1)",
      "mutated_line": "data = dfs(2)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(2)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "data = dfs(1)",
      "mutated_line": "data = dfs(0)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(0)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "data = dfs(1)",
      "mutated_line": "data = dfs(0)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(0)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 51,
      "original_line": "data = dfs(1)",
      "mutated_line": "data = dfs(-1)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(-1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "N1 = len(data1) - 1",
      "mutated_line": "N1 = len(data1) - 2",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 2\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "N1 = len(data1) - 1",
      "mutated_line": "N1 = len(data1) - 0",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 0\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "N1 = len(data1) - 1",
      "mutated_line": "N1 = len(data1) - 0",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 0\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "N1 = len(data1) - 1",
      "mutated_line": "N1 = len(data1) - -1",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - -1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "N2 = len(data2) - 1",
      "mutated_line": "N2 = len(data2) - 2",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 2\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "N2 = len(data2) - 1",
      "mutated_line": "N2 = len(data2) - 0",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 0\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "N2 = len(data2) - 1",
      "mutated_line": "N2 = len(data2) - 0",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 0\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "N2 = len(data2) - 1",
      "mutated_line": "N2 = len(data2) - -1",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - -1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "data = np.zeros(N1 + N2, dtype=np.int64)",
      "mutated_line": "data = np.zeros(N1 - N2, dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 - N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "data = np.zeros(N1 + N2, dtype=np.int64)",
      "mutated_line": "data = np.zeros(N1 * N2, dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 * N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(1, N1 + 1):",
      "mutated_line": "for n in range(2, N1 + 1):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(2, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(1, N1 + 1):",
      "mutated_line": "for n in range(0, N1 + 1):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(0, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(1, N1 + 1):",
      "mutated_line": "for n in range(0, N1 + 1):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(0, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(1, N1 + 1):",
      "mutated_line": "for n in range(-1, N1 + 1):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(-1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for n in range(1, N1 + 1):",
      "mutated_line": "for n in range(1, N1 - 1):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 - 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "for n in range(1, N1 + 1):",
      "mutated_line": "for n in range(1, N1 * 1):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 * 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "data[n:n + N2] += data1[n] * data2[1:] % MOD",
      "mutated_line": "data[n:n + N2] += data1[n] * data2[1:] * MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] * MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "data[n:n + N2] += data1[n] * data2[1:] % MOD",
      "mutated_line": "data[n:n + N2] += data1[n] * data2[1:] + MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] + MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in range(3, N + 10):",
      "mutated_line": "for n in range(3, N + 11):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 11):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in range(3, N + 10):",
      "mutated_line": "for n in range(3, N + 9):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 9):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in range(3, N + 10):",
      "mutated_line": "for n in range(3, N + 0):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 0):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in range(3, N + 10):",
      "mutated_line": "for n in range(3, N + 1):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 1):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "for n in range(3, N + 10):",
      "mutated_line": "for n in range(3, N + -10):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + -10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 2] * (n - 1) * MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) * MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 2] * (n - 1) + MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) + MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "N = len(data) - 1",
      "mutated_line": "N = len(data) - 2",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 2\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "N = len(data) - 1",
      "mutated_line": "N = len(data) - 0",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 0\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "N = len(data) - 1",
      "mutated_line": "N = len(data) - 0",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 0\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "N = len(data) - 1",
      "mutated_line": "N = len(data) - -1",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - -1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "data1 = np.zeros(N + 2, dtype=np.int64)",
      "mutated_line": "data1 = np.zeros(N - 2, dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N - 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 31,
      "original_line": "data1 = np.zeros(N + 2, dtype=np.int64)",
      "mutated_line": "data1 = np.zeros(N * 2, dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N * 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[2] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[2] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[0] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[0] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[0] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[0] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[-1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[-1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "UOI",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = +(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = +(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 39,
      "original_line": "if y == parent:",
      "mutated_line": "if y != parent:",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y != parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "ROR",
      "lineno": 43,
      "original_line": "if data is None:",
      "mutated_line": "if data is not None:",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is not None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N - 1)]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N - 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N * 1)]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N * 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(1, N1 + 1):",
      "mutated_line": "for n in range(1, N1 + 2):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 2):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(1, N1 + 1):",
      "mutated_line": "for n in range(1, N1 + 0):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 0):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(1, N1 + 1):",
      "mutated_line": "for n in range(1, N1 + 0):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 0):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "for n in range(1, N1 + 1):",
      "mutated_line": "for n in range(1, N1 + -1):",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + -1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "data[n:n + N2] += data1[n] * data2[1:] % MOD",
      "mutated_line": "data[n:n + N2] += data1[n] / data2[1:] % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] / data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "data[n:n + N2] += data1[n] * data2[1:] % MOD",
      "mutated_line": "data[n:n + N2] += (data1[n] + data2[1:]) % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += (data1[n] + data2[1:]) % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "data[n:n + N2] += data1[n] * data2[1:] % MOD",
      "mutated_line": "data[n:n + N2] += data1[n] ** data2[1:] % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] ** data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 2] / (n - 1) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] / (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append((fact_2[n - 2] + (n - 1)) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append((fact_2[n - 2] + (n - 1)) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 2] ** (n - 1) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] ** (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "data1 = np.zeros(N + 2, dtype=np.int64)",
      "mutated_line": "data1 = np.zeros(N + 3, dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 3, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "data1 = np.zeros(N + 2, dtype=np.int64)",
      "mutated_line": "data1 = np.zeros(N + 1, dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 1, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "data1 = np.zeros(N + 2, dtype=np.int64)",
      "mutated_line": "data1 = np.zeros(N + 0, dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 0, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "data1 = np.zeros(N + 2, dtype=np.int64)",
      "mutated_line": "data1 = np.zeros(N + 1, dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 1, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "data1 = np.zeros(N + 2, dtype=np.int64)",
      "mutated_line": "data1 = np.zeros(N + -2, dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + -2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "data1[1:] = data",
      "mutated_line": "data1[2:] = data",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[2:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "data1[1:] = data",
      "mutated_line": "data1[0:] = data",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[0:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "data1[1:] = data",
      "mutated_line": "data1[0:] = data",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[0:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "data1[1:] = data",
      "mutated_line": "data1[-1:] = data",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[-1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = (data * fact_2[:N + 1] * MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] * MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = (data * fact_2[:N + 1] + MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] + MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N + 2)]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 2)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N + 0)]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 0)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N + 0)]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 0)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "graph = [[] for _ in range(N + 1)]",
      "mutated_line": "graph = [[] for _ in range(N + -1)]",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + -1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "data[n:n + N2] += data1[n] * data2[1:] % MOD",
      "mutated_line": "data[n:n - N2] += data1[n] * data2[1:] % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n - N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "data[n:n + N2] += data1[n] * data2[1:] % MOD",
      "mutated_line": "data[n:n * N2] += data1[n] * data2[1:] % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n * N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 2] * (n + 1) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n + 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 2] * (n * 1) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n * 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return np.array([0, 1], dtype=np.int64)",
      "mutated_line": "return np.array([1, 1], dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([1, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return np.array([0, 1], dtype=np.int64)",
      "mutated_line": "return np.array([-1, 1], dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([-1, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return np.array([0, 1], dtype=np.int64)",
      "mutated_line": "return np.array([1, 1], dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([1, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return np.array([0, 1], dtype=np.int64)",
      "mutated_line": "return np.array([0, 2], dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 2], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return np.array([0, 1], dtype=np.int64)",
      "mutated_line": "return np.array([0, 0], dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 0], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return np.array([0, 1], dtype=np.int64)",
      "mutated_line": "return np.array([0, 0], dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 0], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 48,
      "original_line": "return np.array([0, 1], dtype=np.int64)",
      "mutated_line": "return np.array([0, -1], dtype=np.int64)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, -1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = (data / fact_2[:N + 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data / fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = ((data + fact_2[:N + 1]) % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = ((data + fact_2[:N + 1]) % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = (data ** fact_2[:N + 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data ** fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n + 2] * (n - 1) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n + 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n * 2] * (n - 1) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n * 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 2] * (n - 2) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 2) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 2] * (n - 0) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 0) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 2] * (n - 0) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 0) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 2] * (n - -1) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - -1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -(data * fact_2[:N + 1] * MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] * MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -(data * fact_2[:N + 1] + MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] + MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "data[n:n + N2] += data1[n] * data2[1:] % MOD",
      "mutated_line": "data[n:n + N2] += data1[n] * data2[2:] % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[2:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "data[n:n + N2] += data1[n] * data2[1:] % MOD",
      "mutated_line": "data[n:n + N2] += data1[n] * data2[0:] % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[0:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "data[n:n + N2] += data1[n] * data2[1:] % MOD",
      "mutated_line": "data[n:n + N2] += data1[n] * data2[0:] % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[0:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "data[n:n + N2] += data1[n] * data2[1:] % MOD",
      "mutated_line": "data[n:n + N2] += data1[n] * data2[-1:] % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[-1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 3] * (n - 1) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 3] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 1] * (n - 1) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 1] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 0] * (n - 1) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 0] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - 1] * (n - 1) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 1] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "fact_2.append(fact_2[n - 2] * (n - 1) % MOD)",
      "mutated_line": "fact_2.append(fact_2[n - -2] * (n - 1) % MOD)",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - -2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -(data / fact_2[:N + 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data / fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -((data + fact_2[:N + 1]) % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -((data + fact_2[:N + 1]) % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -(data ** fact_2[:N + 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data ** fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = (data * fact_2[:N - 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N - 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = (data * fact_2[:N * 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N * 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = (data * fact_2[:N + 2] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 2] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = (data * fact_2[:N + 0] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 0] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = (data * fact_2[:N + 0] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 0] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 52,
      "original_line": "answer = (data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "answer = (data * fact_2[:N + -1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + -1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -(data * fact_2[:N - 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N - 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -(data * fact_2[:N * 1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N * 1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -(data * fact_2[:N + 2] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 2] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -(data * fact_2[:N + 0] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 0] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -(data * fact_2[:N + 0] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + 0] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "data1[1] = -(data * fact_2[:N + 1] % MOD).sum() % MOD",
      "mutated_line": "data1[1] = -(data * fact_2[:N + -1] % MOD).sum() % MOD",
      "code": "import sys\nimport numpy as np\nMOD = 10 ** 9 + 7\n\ndef count_valid_pairings(N, edges):\n    graph = [[] for _ in range(N + 1)]\n    for (x, y) in edges:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dp_merge(data1, data2):\n        N1 = len(data1) - 1\n        N2 = len(data2) - 1\n        if N1 > N2:\n            (N1, N2) = (N2, N1)\n            (data1, data2) = (data2, data1)\n        data = np.zeros(N1 + N2, dtype=np.int64)\n        for n in range(1, N1 + 1):\n            data[n:n + N2] += data1[n] * data2[1:] % MOD\n        data %= MOD\n        return data\n    fact_2 = [1, 0, 1]\n    for n in range(3, N + 10):\n        fact_2.append(fact_2[n - 2] * (n - 1) % MOD)\n    fact_2 = np.array(fact_2, dtype=np.int64)\n\n    def dp_add_edge(data):\n        N = len(data) - 1\n        data1 = np.zeros(N + 2, dtype=np.int64)\n        data1[1:] = data\n        data1[1] = -(data * fact_2[:N + -1] % MOD).sum() % MOD\n        return data1\n\n    def dfs(v, parent=None):\n        data = None\n        for y in graph[v]:\n            if y == parent:\n                continue\n            data1 = dfs(y, v)\n            data1 = dp_add_edge(data1)\n            if data is None:\n                data = data1\n            else:\n                data = dp_merge(data, data1)\n        if data is None:\n            return np.array([0, 1], dtype=np.int64)\n        return data\n    data = dfs(1)\n    answer = (data * fact_2[:N + 1] % MOD).sum() % MOD\n    return answer"
    }
  ]
}