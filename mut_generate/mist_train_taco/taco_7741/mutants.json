{
  "task_id": "taco_7741",
  "entry_point": "calculate_min_operations_to_sort",
  "mutant_count": 46,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "max_cost_can_keep_n = curr_can_keep_n = 1",
      "mutated_line": "for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 2\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "max_cost_can_keep_n = curr_can_keep_n = 1",
      "mutated_line": "for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 0\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "max_cost_can_keep_n = curr_can_keep_n = 1",
      "mutated_line": "for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 0\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "max_cost_can_keep_n = curr_can_keep_n = 1",
      "mutated_line": "for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = -1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if curr_can_keep_n > max_cost_can_keep_n:",
      "mutated_line": "if curr_can_keep_n >= max_cost_can_keep_n:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n >= max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if curr_can_keep_n > max_cost_can_keep_n:",
      "mutated_line": "if curr_can_keep_n <= max_cost_can_keep_n:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n <= max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if curr_can_keep_n > max_cost_can_keep_n:",
      "mutated_line": "if curr_can_keep_n != max_cost_can_keep_n:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n != max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return len(set(sequence)) - max_cost_can_keep_n",
      "mutated_line": "return len(set(sequence)) + max_cost_can_keep_n",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) + max_cost_can_keep_n"
    },
    {
      "operator": "AOR",
      "lineno": 25,
      "original_line": "return len(set(sequence)) - max_cost_can_keep_n",
      "mutated_line": "return len(set(sequence)) * max_cost_can_keep_n",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) * max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 1\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return -1",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return -1\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "return 0",
      "mutated_line": "return 1",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 1\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if curr_border[0] > prev_border[1]:",
      "mutated_line": "if curr_border[0] >= prev_border[1]:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] >= prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if curr_border[0] > prev_border[1]:",
      "mutated_line": "if curr_border[0] <= prev_border[1]:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] <= prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if curr_border[0] > prev_border[1]:",
      "mutated_line": "if curr_border[0] != prev_border[1]:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] != prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "curr_can_keep_n += 1",
      "mutated_line": "curr_can_keep_n -= 1",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n -= 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "curr_can_keep_n += 1",
      "mutated_line": "curr_can_keep_n += 2",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 2\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "curr_can_keep_n += 1",
      "mutated_line": "curr_can_keep_n += 0",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 0\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "curr_can_keep_n += 1",
      "mutated_line": "curr_can_keep_n += 0",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 0\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "curr_can_keep_n += 1",
      "mutated_line": "curr_can_keep_n += -1",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += -1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if curr_can_keep_n > max_cost_can_keep_n:",
      "mutated_line": "if curr_can_keep_n >= max_cost_can_keep_n:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n >= max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if curr_can_keep_n > max_cost_can_keep_n:",
      "mutated_line": "if curr_can_keep_n <= max_cost_can_keep_n:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n <= max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if curr_can_keep_n > max_cost_can_keep_n:",
      "mutated_line": "if curr_can_keep_n != max_cost_can_keep_n:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n != max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr_can_keep_n = 1",
      "mutated_line": "curr_can_keep_n = 2",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 2\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr_can_keep_n = 1",
      "mutated_line": "curr_can_keep_n = 0",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 0\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr_can_keep_n = 1",
      "mutated_line": "curr_can_keep_n = 0",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 0\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "curr_can_keep_n = 1",
      "mutated_line": "curr_can_keep_n = -1",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = -1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "borders_by_values = {x: (indices[0], indices[-1]) for x, indices in indices_by_values.items()}",
      "mutated_line": "borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[1], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "borders_by_values = {x: (indices[0], indices[-1]) for x, indices in indices_by_values.items()}",
      "mutated_line": "borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[-1], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "borders_by_values = {x: (indices[0], indices[-1]) for x, indices in indices_by_values.items()}",
      "mutated_line": "borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[1], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "UOI",
      "lineno": 10,
      "original_line": "borders_by_values = {x: (indices[0], indices[-1]) for x, indices in indices_by_values.items()}",
      "mutated_line": "borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[+1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for prev_border, curr_border in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):",
      "mutated_line": "for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[2:]):",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[2:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for prev_border, curr_border in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):",
      "mutated_line": "for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[0:]):",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[0:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for prev_border, curr_border in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):",
      "mutated_line": "for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[0:]):",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[0:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "for prev_border, curr_border in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):",
      "mutated_line": "for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[-1:]):",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[-1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if curr_border[0] > prev_border[1]:",
      "mutated_line": "if curr_border[1] > prev_border[1]:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[1] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if curr_border[0] > prev_border[1]:",
      "mutated_line": "if curr_border[-1] > prev_border[1]:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[-1] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if curr_border[0] > prev_border[1]:",
      "mutated_line": "if curr_border[1] > prev_border[1]:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[1] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if curr_border[0] > prev_border[1]:",
      "mutated_line": "if curr_border[0] > prev_border[2]:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[2]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if curr_border[0] > prev_border[1]:",
      "mutated_line": "if curr_border[0] > prev_border[0]:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[0]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if curr_border[0] > prev_border[1]:",
      "mutated_line": "if curr_border[0] > prev_border[0]:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[0]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if curr_border[0] > prev_border[1]:",
      "mutated_line": "if curr_border[0] > prev_border[-1]:",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[-1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "borders_by_values = {x: (indices[0], indices[-1]) for x, indices in indices_by_values.items()}",
      "mutated_line": "borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-2]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "borders_by_values = {x: (indices[0], indices[-1]) for x, indices in indices_by_values.items()}",
      "mutated_line": "borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-0]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "borders_by_values = {x: (indices[0], indices[-1]) for x, indices in indices_by_values.items()}",
      "mutated_line": "borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[-0]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "borders_by_values = {x: (indices[0], indices[-1]) for x, indices in indices_by_values.items()}",
      "mutated_line": "borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]",
      "code": "def calculate_min_operations_to_sort(sequence):\n    sequence = tuple(sequence)\n    if not sequence:\n        return 0\n    indices_by_values = {x: [] for x in sequence}\n    for (i, x) in enumerate(sequence):\n        indices_by_values[x].append(i)\n    borders_by_values = {x: (indices[0], indices[--1]) for (x, indices) in indices_by_values.items()}\n    borders_sorted_by_values = [borders for (x, borders) in sorted(borders_by_values.items())]\n    max_cost_can_keep_n = curr_can_keep_n = 1\n    for (prev_border, curr_border) in zip(borders_sorted_by_values, borders_sorted_by_values[1:]):\n        if curr_border[0] > prev_border[1]:\n            curr_can_keep_n += 1\n        else:\n            if curr_can_keep_n > max_cost_can_keep_n:\n                max_cost_can_keep_n = curr_can_keep_n\n            curr_can_keep_n = 1\n    if curr_can_keep_n > max_cost_can_keep_n:\n        max_cost_can_keep_n = curr_can_keep_n\n    return len(set(sequence)) - max_cost_can_keep_n"
    }
  ]
}