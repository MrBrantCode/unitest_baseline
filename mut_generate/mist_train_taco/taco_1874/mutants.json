{
  "task_id": "taco_1874",
  "entry_point": "determine_inversion_parity",
  "mutant_count": 97,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "WHOLE_INVERSION = 0",
      "mutated_line": "WHOLE_INVERSION = 1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 1\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "WHOLE_INVERSION = 0",
      "mutated_line": "WHOLE_INVERSION = -1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = -1\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "WHOLE_INVERSION = 0",
      "mutated_line": "WHOLE_INVERSION = 1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 1\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 30,
      "original_line": "WHOLE_INVERSION += fenwick_tree.get(1, index)",
      "mutated_line": "WHOLE_INVERSION -= fenwick_tree.get(1, index)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION -= fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION -= d * (d - 1) // 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION -= d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "d = r - l + 1",
      "mutated_line": "d = r - l - 1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l - 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "d = r - l + 1",
      "mutated_line": "d = (r - l) * 1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = (r - l) * 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d - 1) / 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) / 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d - 1) * 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) * 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 38,
      "original_line": "if WHOLE_INVERSION % 2 != 0:",
      "mutated_line": "if WHOLE_INVERSION % 2 == 0:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 == 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.data = [0] * (n + 1)",
      "mutated_line": "self.data = [0] / (n + 1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] / (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.data = [0] * (n + 1)",
      "mutated_line": "self.data = [0] + (n + 1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] + (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.data = [0] * (n + 1)",
      "mutated_line": "self.data = [0] ** (n + 1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] ** (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 1\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = -1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = -1\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "s = 0",
      "mutated_line": "s = 1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 1\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i >= 0:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i >= 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i <= 0:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i <= 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i != 0:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i != 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 10,
      "original_line": "s += self.data[i]",
      "mutated_line": "s -= self.data[i]",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s -= self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 11,
      "original_line": "i -= i & -i",
      "mutated_line": "i += i & -i",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i += i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i <= self.n:",
      "mutated_line": "while i < self.n:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i < self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i <= self.n:",
      "mutated_line": "while i > self.n:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i > self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "while i <= self.n:",
      "mutated_line": "while i == self.n:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i == self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "self.data[i] += x",
      "mutated_line": "self.data[i] -= x",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] -= x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "i += i & -i",
      "mutated_line": "i -= i & -i",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i -= i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return self.to_sum(j) - self.to_sum(i - 1)",
      "mutated_line": "return self.to_sum(j) + self.to_sum(i - 1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) + self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return self.to_sum(j) - self.to_sum(i - 1)",
      "mutated_line": "return self.to_sum(j) * self.to_sum(i - 1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) * self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "seq = [(permutation[i], i + 1) for i in range(n)]",
      "mutated_line": "seq = [(permutation[i], i - 1) for i in range(n)]",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i - 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "seq = [(permutation[i], i + 1) for i in range(n)]",
      "mutated_line": "seq = [(permutation[i], i * 1) for i in range(n)]",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i * 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "seq.sort(reverse=True)",
      "mutated_line": "seq.sort(reverse=False)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=False)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "WHOLE_INVERSION += fenwick_tree.get(1, index)",
      "mutated_line": "WHOLE_INVERSION += fenwick_tree.get(2, index)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(2, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "WHOLE_INVERSION += fenwick_tree.get(1, index)",
      "mutated_line": "WHOLE_INVERSION += fenwick_tree.get(0, index)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(0, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "WHOLE_INVERSION += fenwick_tree.get(1, index)",
      "mutated_line": "WHOLE_INVERSION += fenwick_tree.get(0, index)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(0, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 30,
      "original_line": "WHOLE_INVERSION += fenwick_tree.get(1, index)",
      "mutated_line": "WHOLE_INVERSION += fenwick_tree.get(-1, index)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(-1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "fenwick_tree.add(index, 1)",
      "mutated_line": "fenwick_tree.add(index, 2)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 2)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "fenwick_tree.add(index, 1)",
      "mutated_line": "fenwick_tree.add(index, 0)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 0)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "fenwick_tree.add(index, 1)",
      "mutated_line": "fenwick_tree.add(index, 0)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 0)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "fenwick_tree.add(index, 1)",
      "mutated_line": "fenwick_tree.add(index, -1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, -1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "d = r - l + 1",
      "mutated_line": "d = r + l + 1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r + l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 36,
      "original_line": "d = r - l + 1",
      "mutated_line": "d = r * l + 1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r * l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "d = r - l + 1",
      "mutated_line": "d = r - l + 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 2\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "d = r - l + 1",
      "mutated_line": "d = r - l + 0",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 0\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "d = r - l + 1",
      "mutated_line": "d = r - l + 0",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 0\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "d = r - l + 1",
      "mutated_line": "d = r - l + -1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + -1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d / (d - 1) // 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d / (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += (d + (d - 1)) // 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += (d + (d - 1)) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d ** (d - 1) // 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d ** (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d - 1) // 3",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 3\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d - 1) // 1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 1\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d - 1) // 0",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 0\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d - 1) // 1",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 1\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d - 1) // -2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // -2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if WHOLE_INVERSION % 2 != 0:",
      "mutated_line": "if WHOLE_INVERSION * 2 != 0:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION * 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 38,
      "original_line": "if WHOLE_INVERSION % 2 != 0:",
      "mutated_line": "if WHOLE_INVERSION + 2 != 0:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION + 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if WHOLE_INVERSION % 2 != 0:",
      "mutated_line": "if WHOLE_INVERSION % 2 != 1:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 1:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if WHOLE_INVERSION % 2 != 0:",
      "mutated_line": "if WHOLE_INVERSION % 2 != -1:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != -1:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if WHOLE_INVERSION % 2 != 0:",
      "mutated_line": "if WHOLE_INVERSION % 2 != 1:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 1:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.data = [0] * (n + 1)",
      "mutated_line": "self.data = [0] * (n - 1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n - 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "self.data = [0] * (n + 1)",
      "mutated_line": "self.data = [0] * (n * 1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n * 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 1:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i > -1:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > -1:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "while i > 0:",
      "mutated_line": "while i > 1:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 1:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i | -i",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i | -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 17,
      "original_line": "i += i & -i",
      "mutated_line": "i += i | -i",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i | -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "seq = [(permutation[i], i + 1) for i in range(n)]",
      "mutated_line": "seq = [(permutation[i], i + 2) for i in range(n)]",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 2) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "seq = [(permutation[i], i + 1) for i in range(n)]",
      "mutated_line": "seq = [(permutation[i], i + 0) for i in range(n)]",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 0) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "seq = [(permutation[i], i + 1) for i in range(n)]",
      "mutated_line": "seq = [(permutation[i], i + 0) for i in range(n)]",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 0) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "seq = [(permutation[i], i + 1) for i in range(n)]",
      "mutated_line": "seq = [(permutation[i], i + -1) for i in range(n)]",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + -1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d + 1) // 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d + 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d * 1) // 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d * 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if WHOLE_INVERSION % 2 != 0:",
      "mutated_line": "if WHOLE_INVERSION % 3 != 0:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 3 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if WHOLE_INVERSION % 2 != 0:",
      "mutated_line": "if WHOLE_INVERSION % 1 != 0:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 1 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if WHOLE_INVERSION % 2 != 0:",
      "mutated_line": "if WHOLE_INVERSION % 0 != 0:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 0 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if WHOLE_INVERSION % 2 != 0:",
      "mutated_line": "if WHOLE_INVERSION % 1 != 0:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 1 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 38,
      "original_line": "if WHOLE_INVERSION % 2 != 0:",
      "mutated_line": "if WHOLE_INVERSION % -2 != 0:",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % -2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "results.append(\"odd\")",
      "mutated_line": "results.append('')",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 41,
      "original_line": "results.append(\"even\")",
      "mutated_line": "results.append('')",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.data = [0] * (n + 1)",
      "mutated_line": "self.data = [1] * (n + 1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [1] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.data = [0] * (n + 1)",
      "mutated_line": "self.data = [-1] * (n + 1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [-1] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.data = [0] * (n + 1)",
      "mutated_line": "self.data = [1] * (n + 1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [1] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.data = [0] * (n + 1)",
      "mutated_line": "self.data = [0] * (n + 2)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 2)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.data = [0] * (n + 1)",
      "mutated_line": "self.data = [0] * (n + 0)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 0)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.data = [0] * (n + 1)",
      "mutated_line": "self.data = [0] * (n + 0)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 0)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "self.data = [0] * (n + 1)",
      "mutated_line": "self.data = [0] * (n + -1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + -1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "i -= i & -i",
      "mutated_line": "i -= i & +i",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & +i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "UOI",
      "lineno": 17,
      "original_line": "i += i & -i",
      "mutated_line": "i += i & +i",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & +i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return self.to_sum(j) - self.to_sum(i - 1)",
      "mutated_line": "return self.to_sum(j) - self.to_sum(i + 1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i + 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "return self.to_sum(j) - self.to_sum(i - 1)",
      "mutated_line": "return self.to_sum(j) - self.to_sum(i * 1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i * 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d - 2) // 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 2) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d - 0) // 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 0) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d - 0) // 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 0) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "WHOLE_INVERSION += d * (d - 1) // 2",
      "mutated_line": "WHOLE_INVERSION += d * (d - -1) // 2",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - -1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return self.to_sum(j) - self.to_sum(i - 1)",
      "mutated_line": "return self.to_sum(j) - self.to_sum(i - 2)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 2)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return self.to_sum(j) - self.to_sum(i - 1)",
      "mutated_line": "return self.to_sum(j) - self.to_sum(i - 0)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 0)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return self.to_sum(j) - self.to_sum(i - 1)",
      "mutated_line": "return self.to_sum(j) - self.to_sum(i - 0)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - 0)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "return self.to_sum(j) - self.to_sum(i - 1)",
      "mutated_line": "return self.to_sum(j) - self.to_sum(i - -1)",
      "code": "def determine_inversion_parity(n, permutation, queries):\n\n    class FenwickTree:\n\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n\n        def to_sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j):\n            return self.to_sum(j) - self.to_sum(i - -1)\n    seq = [(permutation[i], i + 1) for i in range(n)]\n    seq.sort(reverse=True)\n    WHOLE_INVERSION = 0\n    fenwick_tree = FenwickTree(n)\n    for (value, index) in seq:\n        WHOLE_INVERSION += fenwick_tree.get(1, index)\n        fenwick_tree.add(index, 1)\n    results = []\n    for (l, r) in queries:\n        d = r - l + 1\n        WHOLE_INVERSION += d * (d - 1) // 2\n        if WHOLE_INVERSION % 2 != 0:\n            results.append('odd')\n        else:\n            results.append('even')\n    return results"
    }
  ]
}