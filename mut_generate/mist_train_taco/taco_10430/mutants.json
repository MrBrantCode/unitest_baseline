{
  "task_id": "taco_10430",
  "entry_point": "shortest_path_with_obstacle_elimination",
  "mutant_count": 150,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "min_steps = rows + cols - 2",
      "mutated_line": "min_steps = rows + cols + 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols + 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "min_steps = rows + cols - 2",
      "mutated_line": "min_steps = (rows + cols) * 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = (rows + cols) * 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if k >= min_steps - 1:",
      "mutated_line": "if k > min_steps - 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k > min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if k >= min_steps - 1:",
      "mutated_line": "if k < min_steps - 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k < min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if k >= min_steps - 1:",
      "mutated_line": "if k == min_steps - 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k == min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "steps = 0",
      "mutated_line": "steps = 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 1\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "steps = 0",
      "mutated_line": "steps = -1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = -1\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "steps = 0",
      "mutated_line": "steps = 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 1\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ASR",
      "lineno": 17,
      "original_line": "steps += 1",
      "mutated_line": "steps -= 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps -= 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return +1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return +1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "min_steps = rows + cols - 2",
      "mutated_line": "min_steps = rows - cols - 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows - cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "min_steps = rows + cols - 2",
      "mutated_line": "min_steps = rows * cols - 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows * cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_steps = rows + cols - 2",
      "mutated_line": "min_steps = rows + cols - 3",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 3\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_steps = rows + cols - 2",
      "mutated_line": "min_steps = rows + cols - 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 1\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_steps = rows + cols - 2",
      "mutated_line": "min_steps = rows + cols - 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 0\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_steps = rows + cols - 2",
      "mutated_line": "min_steps = rows + cols - 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 1\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "min_steps = rows + cols - 2",
      "mutated_line": "min_steps = rows + cols - -2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - -2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if k >= min_steps - 1:",
      "mutated_line": "if k >= min_steps + 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps + 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if k >= min_steps - 1:",
      "mutated_line": "if k >= min_steps * 1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps * 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited = [[-1] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[-1] / cols for _ in range(rows)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] / cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited = [[-1] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[-1] + cols for _ in range(rows)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] + cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "visited = [[-1] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[-1] ** cols for _ in range(rows)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] ** cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited[0][0] = k",
      "mutated_line": "visited[0][1] = k",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][1] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited[0][0] = k",
      "mutated_line": "visited[0][-1] = k",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][-1] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited[0][0] = k",
      "mutated_line": "visited[0][1] = k",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][1] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "steps += 1",
      "mutated_line": "steps += 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 2\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "steps += 1",
      "mutated_line": "steps += 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 0\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "steps += 1",
      "mutated_line": "steps += 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 0\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "steps += 1",
      "mutated_line": "steps += -1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += -1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -2"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return -0",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -0"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "return -1",
      "mutated_line": "return --1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return --1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if k >= min_steps - 1:",
      "mutated_line": "if k >= min_steps - 2:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 2:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if k >= min_steps - 1:",
      "mutated_line": "if k >= min_steps - 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 0:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if k >= min_steps - 1:",
      "mutated_line": "if k >= min_steps - 0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 0:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if k >= min_steps - 1:",
      "mutated_line": "if k >= min_steps - -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - -1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited[0][0] = k",
      "mutated_line": "visited[1][0] = k",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[1][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited[0][0] = k",
      "mutated_line": "visited[-1][0] = k",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[-1][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "visited[0][0] = k",
      "mutated_line": "visited[1][0] = k",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[1][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[1]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[-1]))",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[-1]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "rows, cols = len(grid), len(grid[0])",
      "mutated_line": "(rows, cols) = (len(grid), len(grid[1]))",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[1]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "visited = [[-1] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[+1] * cols for _ in range(rows)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[+1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = deque([(0, 0, k)])",
      "mutated_line": "q = deque([(1, 0, k)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(1, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = deque([(0, 0, k)])",
      "mutated_line": "q = deque([(-1, 0, k)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(-1, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = deque([(0, 0, k)])",
      "mutated_line": "q = deque([(1, 0, k)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(1, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = deque([(0, 0, k)])",
      "mutated_line": "q = deque([(0, 1, k)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 1, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = deque([(0, 0, k)])",
      "mutated_line": "q = deque([(0, -1, k)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, -1, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "q = deque([(0, 0, k)])",
      "mutated_line": "q = deque([(0, 1, k)])",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 1, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 and x >= cols and (y < 0) and (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 and x >= cols and (y < 0) and (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "kk = p - grid[y][x]",
      "mutated_line": "kk = p + grid[y][x]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p + grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "kk = p - grid[y][x]",
      "mutated_line": "kk = p * grid[y][x]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p * grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 25,
      "original_line": "if kk < 0 or kk <= visited[y][x]:",
      "mutated_line": "if kk < 0 and kk <= visited[y][x]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 and kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = rows - y + cols - x + 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x + 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = (rows - y + cols - x) * 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = (rows - y + cols - x) * 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "LCR",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target - 1 or visited[y][x] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 or visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [[-1] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[-2] * cols for _ in range(rows)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-2] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [[-1] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[-0] * cols for _ in range(rows)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-0] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [[-1] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[-0] * cols for _ in range(rows)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-0] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "visited = [[-1] * cols for _ in range(rows)]",
      "mutated_line": "visited = [[--1] * cols for _ in range(rows)]",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[--1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(2, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(2, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(0, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(-1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(-1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, -1), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, -1), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 1), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (+1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (+1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, -1), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, -1), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 1), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (-1, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (-1, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (1, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 2), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 2), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 0), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, -1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, -1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (-1, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (-1, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (1, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, +1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, +1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "x, y = c + dx, r + dy",
      "mutated_line": "(x, y) = (c - dx, r + dy)",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c - dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "x, y = c + dx, r + dy",
      "mutated_line": "(x, y) = (c * dx, r + dy)",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c * dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "x, y = c + dx, r + dy",
      "mutated_line": "(x, y) = (c + dx, r - dy)",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r - dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "x, y = c + dx, r + dy",
      "mutated_line": "(x, y) = (c + dx, r * dy)",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r * dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x <= 0 or x >= cols or y < 0 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x <= 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x >= 0 or x >= cols or y < 0 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x >= 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x != 0 or x >= cols or y < 0 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x != 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 or x > cols or y < 0 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x > cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 or x < cols or y < 0 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x < cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 or x == cols or y < 0 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x == cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 or x >= cols or y <= 0 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y <= 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 or x >= cols or y >= 0 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y >= 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 or x >= cols or y != 0 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y != 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 or x >= cols or y < 0 or (y > rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y > rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 or x >= cols or y < 0 or (y < rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y < rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 or x >= cols or y < 0 or (y == rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y == rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if kk < 0 or kk <= visited[y][x]:",
      "mutated_line": "if kk <= 0 or kk <= visited[y][x]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk <= 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if kk < 0 or kk <= visited[y][x]:",
      "mutated_line": "if kk >= 0 or kk <= visited[y][x]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk >= 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if kk < 0 or kk <= visited[y][x]:",
      "mutated_line": "if kk != 0 or kk <= visited[y][x]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk != 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if kk < 0 or kk <= visited[y][x]:",
      "mutated_line": "if kk < 0 or kk < visited[y][x]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk < visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if kk < 0 or kk <= visited[y][x]:",
      "mutated_line": "if kk < 0 or kk > visited[y][x]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk > visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 25,
      "original_line": "if kk < 0 or kk <= visited[y][x]:",
      "mutated_line": "if kk < 0 or kk == visited[y][x]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk == visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = rows - y + cols + x - 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols + x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = (rows - y + cols) * x - 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = (rows - y + cols) * x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = rows - y + cols - x - 3",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 3\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = rows - y + cols - x - 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 1\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = rows - y + cols - x - 0",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 0\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = rows - y + cols - x - 1",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 1\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = rows - y + cols - x - -2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - -2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk > to_target - 1 and visited[y][x] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk > to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk < to_target - 1 and visited[y][x] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk < to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk == to_target - 1 and visited[y][x] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk == to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "ROR",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target - 1 and visited[y][x] != -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] != -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return steps + to_target",
      "mutated_line": "return steps - to_target",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps - to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 29,
      "original_line": "return steps + to_target",
      "mutated_line": "return steps * to_target",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps * to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-2, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-2, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-0, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (--1, 0), (0, 1), (0, -1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (--1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -2)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -2)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -0)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:",
      "mutated_line": "for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, --1)]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, --1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 1 or x >= cols or y < 0 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 1 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < -1 or x >= cols or y < 0 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < -1 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 1 or x >= cols or y < 0 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 1 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 or x >= cols or y < 1 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 1 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 or x >= cols or y < -1 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < -1 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "if x < 0 or x >= cols or y < 0 or y >= rows:",
      "mutated_line": "if x < 0 or x >= cols or y < 1 or (y >= rows):",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 1 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if kk < 0 or kk <= visited[y][x]:",
      "mutated_line": "if kk < 1 or kk <= visited[y][x]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 1 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if kk < 0 or kk <= visited[y][x]:",
      "mutated_line": "if kk < -1 or kk <= visited[y][x]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < -1 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "if kk < 0 or kk <= visited[y][x]:",
      "mutated_line": "if kk < 1 or kk <= visited[y][x]:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 1 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = rows - y - cols - x - 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y - cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = (rows - y) * cols - x - 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = (rows - y) * cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target + 1 and visited[y][x] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target + 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target * 1 and visited[y][x] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target * 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "UOI",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target - 1 and visited[y][x] == +1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == +1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = rows + y + cols - x - 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows + y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "to_target = rows - y + cols - x - 2",
      "mutated_line": "to_target = rows * y + cols - x - 2",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows * y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target - 2 and visited[y][x] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 2 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target - 0 and visited[y][x] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 0 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target - 0 and visited[y][x] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 0 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target - -1 and visited[y][x] == -1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - -1 and visited[y][x] == -1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target - 1 and visited[y][x] == -2:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -2:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target - 1 and visited[y][x] == -0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -0:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target - 1 and visited[y][x] == -0:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == -0:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "if kk >= to_target - 1 and visited[y][x] == -1:",
      "mutated_line": "if kk >= to_target - 1 and visited[y][x] == --1:",
      "code": "from collections import deque\nfrom typing import List\n\ndef shortest_path_with_obstacle_elimination(grid: List[List[int]], k: int) -> int:\n    (rows, cols) = (len(grid), len(grid[0]))\n    min_steps = rows + cols - 2\n    if k >= min_steps - 1:\n        return min_steps\n    visited = [[-1] * cols for _ in range(rows)]\n    visited[0][0] = k\n    q = deque([(0, 0, k)])\n    steps = 0\n    while q:\n        steps += 1\n        for _ in range(len(q)):\n            (r, c, p) = q.popleft()\n            for (dx, dy) in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                (x, y) = (c + dx, r + dy)\n                if x < 0 or x >= cols or y < 0 or (y >= rows):\n                    continue\n                kk = p - grid[y][x]\n                if kk < 0 or kk <= visited[y][x]:\n                    continue\n                to_target = rows - y + cols - x - 2\n                if kk >= to_target - 1 and visited[y][x] == --1:\n                    return steps + to_target\n                q.append((y, x, kk))\n                visited[y][x] = kk\n                min_steps = min(min_steps, to_target)\n    return -1"
    }
  ]
}