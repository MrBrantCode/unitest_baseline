{
  "task_id": "taco_17712",
  "entry_point": "count_ways_to_fill_permutation",
  "mutant_count": 86,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244354",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244354\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 998244352",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244352\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 0",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 0\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = 1",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 1\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "MOD = 998244353",
      "mutated_line": "MOD = -998244353",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = -998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] / (n + 1)",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] / (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] + (n + 1)",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] + (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] ** (n + 1)",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] ** (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m = 1",
      "mutated_line": "m = 2",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 2\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m = 1",
      "mutated_line": "m = 0",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 0\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m = 1",
      "mutated_line": "m = 0",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 0\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "m = 1",
      "mutated_line": "m = -1",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = -1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n - 1)",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n - 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 3,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n * 1)",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n * 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "LCR",
      "lineno": 8,
      "original_line": "if b_i != -1 and a_i - b_i > s:",
      "mutated_line": "if b_i != -1 or a_i - b_i > s:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 or a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "e_hi = 0",
      "mutated_line": "e_hi = 1",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 1\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "e_hi = 0",
      "mutated_line": "e_hi = -1",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = -1\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "e_hi = 0",
      "mutated_line": "e_hi = 1",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 1\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [1] * (n + 1)",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [1] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [-1] * (n + 1)",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [-1] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [1] * (n + 1)",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [1] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n + 2)",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 2)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n + 0)",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 0)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n + 0)",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 0)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "visited = [0] * (n + 1)",
      "mutated_line": "visited = [0] * (n + -1)",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + -1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if b_i != -1 and a_i - b_i > s:",
      "mutated_line": "if b_i == -1 and a_i - b_i > s:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i == -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if b_i != -1 and a_i - b_i > s:",
      "mutated_line": "if b_i != -1 and a_i - b_i >= s:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i >= s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if b_i != -1 and a_i - b_i > s:",
      "mutated_line": "if b_i != -1 and a_i - b_i <= s:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i <= s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "ROR",
      "lineno": 8,
      "original_line": "if b_i != -1 and a_i - b_i > s:",
      "mutated_line": "if b_i != -1 and a_i - b_i != s:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i != s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "m = 0",
      "mutated_line": "m = 1",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 1\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "m = 0",
      "mutated_line": "m = -1",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = -1\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "m = 0",
      "mutated_line": "m = 1",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 1\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "ROR",
      "lineno": 11,
      "original_line": "elif b_i == -1:",
      "mutated_line": "elif b_i != -1:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i != -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "ASR",
      "lineno": 14,
      "original_line": "visited[b_i] += 1",
      "mutated_line": "visited[b_i] -= 1",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] -= 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "while e_hi != l_max and m_i + s >= empty[e_hi]:",
      "mutated_line": "while e_hi != l_max or m_i + s >= empty[e_hi]:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max or m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "ASR",
      "lineno": 22,
      "original_line": "e_hi += 1",
      "mutated_line": "e_hi -= 1",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi -= 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = m * max(0, e_hi - e_lo) % MOD",
      "mutated_line": "m = m * max(0, e_hi - e_lo) * MOD",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) * MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = m * max(0, e_hi - e_lo) % MOD",
      "mutated_line": "m = m * max(0, e_hi - e_lo) + MOD",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) + MOD\n    return m"
    },
    {
      "operator": "UOI",
      "lineno": 8,
      "original_line": "if b_i != -1 and a_i - b_i > s:",
      "mutated_line": "if b_i != +1 and a_i - b_i > s:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != +1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if b_i != -1 and a_i - b_i > s:",
      "mutated_line": "if b_i != -1 and a_i + b_i > s:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i + b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "if b_i != -1 and a_i - b_i > s:",
      "mutated_line": "if b_i != -1 and a_i * b_i > s:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i * b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "UOI",
      "lineno": 11,
      "original_line": "elif b_i == -1:",
      "mutated_line": "elif b_i == +1:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == +1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited[b_i] += 1",
      "mutated_line": "visited[b_i] += 2",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 2\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited[b_i] += 1",
      "mutated_line": "visited[b_i] += 0",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 0\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited[b_i] += 1",
      "mutated_line": "visited[b_i] += 0",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 0\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "visited[b_i] += 1",
      "mutated_line": "visited[b_i] += -1",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += -1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "ROR",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(1, n + 1) if visited[i] != 0]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] != 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while e_hi != l_max and m_i + s >= empty[e_hi]:",
      "mutated_line": "while e_hi == l_max and m_i + s >= empty[e_hi]:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi == l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while e_hi != l_max and m_i + s >= empty[e_hi]:",
      "mutated_line": "while e_hi != l_max and m_i + s > empty[e_hi]:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s > empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while e_hi != l_max and m_i + s >= empty[e_hi]:",
      "mutated_line": "while e_hi != l_max and m_i + s < empty[e_hi]:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s < empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "while e_hi != l_max and m_i + s >= empty[e_hi]:",
      "mutated_line": "while e_hi != l_max and m_i + s == empty[e_hi]:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s == empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "e_hi += 1",
      "mutated_line": "e_hi += 2",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 2\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "e_hi += 1",
      "mutated_line": "e_hi += 0",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 0\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "e_hi += 1",
      "mutated_line": "e_hi += 0",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 0\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "e_hi += 1",
      "mutated_line": "e_hi += -1",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += -1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = m * max(0, e_hi - e_lo) % MOD",
      "mutated_line": "m = m / max(0, e_hi - e_lo) % MOD",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m / max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = m * max(0, e_hi - e_lo) % MOD",
      "mutated_line": "m = (m + max(0, e_hi - e_lo)) % MOD",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = (m + max(0, e_hi - e_lo)) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = m * max(0, e_hi - e_lo) % MOD",
      "mutated_line": "m = m ** max(0, e_hi - e_lo) % MOD",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m ** max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if b_i != -1 and a_i - b_i > s:",
      "mutated_line": "if b_i != -2 and a_i - b_i > s:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -2 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if b_i != -1 and a_i - b_i > s:",
      "mutated_line": "if b_i != -0 and a_i - b_i > s:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -0 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if b_i != -1 and a_i - b_i > s:",
      "mutated_line": "if b_i != -0 and a_i - b_i > s:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -0 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "if b_i != -1 and a_i - b_i > s:",
      "mutated_line": "if b_i != --1 and a_i - b_i > s:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != --1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif b_i == -1:",
      "mutated_line": "elif b_i == -2:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -2:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif b_i == -1:",
      "mutated_line": "elif b_i == -0:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -0:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif b_i == -1:",
      "mutated_line": "elif b_i == -0:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -0:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "elif b_i == -1:",
      "mutated_line": "elif b_i == --1:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == --1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(2, n + 1) if visited[i] == 0]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(2, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(0, n + 1) if visited[i] == 0]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(0, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(0, n + 1) if visited[i] == 0]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(0, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(-1, n + 1) if visited[i] == 0]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(-1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(1, n - 1) if visited[i] == 0]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n - 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(1, n * 1) if visited[i] == 0]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n * 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(1, n + 1) if visited[i] == 1]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 1]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(1, n + 1) if visited[i] == -1]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == -1]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(1, n + 1) if visited[i] == 1]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 1]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while e_hi != l_max and m_i + s >= empty[e_hi]:",
      "mutated_line": "while e_hi != l_max and m_i - s >= empty[e_hi]:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i - s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "while e_hi != l_max and m_i + s >= empty[e_hi]:",
      "mutated_line": "while e_hi != l_max and m_i * s >= empty[e_hi]:",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i * s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(1, n + 2) if visited[i] == 0]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 2) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(1, n + 0) if visited[i] == 0]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 0) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(1, n + 0) if visited[i] == 0]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 0) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "missing = [i for i in range(1, n + 1) if visited[i] == 0]",
      "mutated_line": "missing = [i for i in range(1, n + -1) if visited[i] == 0]",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + -1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = m * max(0, e_hi - e_lo) % MOD",
      "mutated_line": "m = m * max(1, e_hi - e_lo) % MOD",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(1, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = m * max(0, e_hi - e_lo) % MOD",
      "mutated_line": "m = m * max(-1, e_hi - e_lo) % MOD",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(-1, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "m = m * max(0, e_hi - e_lo) % MOD",
      "mutated_line": "m = m * max(1, e_hi - e_lo) % MOD",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(1, e_hi - e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = m * max(0, e_hi - e_lo) % MOD",
      "mutated_line": "m = m * max(0, e_hi + e_lo) % MOD",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi + e_lo) % MOD\n    return m"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "m = m * max(0, e_hi - e_lo) % MOD",
      "mutated_line": "m = m * max(0, e_hi * e_lo) % MOD",
      "code": "def count_ways_to_fill_permutation(n, s, a, b):\n    MOD = 998244353\n    visited = [0] * (n + 1)\n    m = 1\n    empty = []\n    for (a_i, b_i) in zip(a, b):\n        if b_i != -1 and a_i - b_i > s:\n            m = 0\n            break\n        elif b_i == -1:\n            empty.append(a_i)\n        else:\n            visited[b_i] += 1\n    else:\n        missing = [i for i in range(1, n + 1) if visited[i] == 0]\n        empty.sort()\n        l_max = len(missing)\n        e_hi = 0\n        for (e_lo, m_i) in enumerate(missing):\n            while e_hi != l_max and m_i + s >= empty[e_hi]:\n                e_hi += 1\n            m = m * max(0, e_hi * e_lo) % MOD\n    return m"
    }
  ]
}