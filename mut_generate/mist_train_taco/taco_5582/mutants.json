{
  "task_id": "taco_5582",
  "entry_point": "calculate_cleared_area",
  "mutant_count": 326,
  "mutants": [
    {
      "operator": "UOI",
      "lineno": 24,
      "original_line": "r_max = -sys.maxsize",
      "mutated_line": "r_max = +sys.maxsize",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = +sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "UOI",
      "lineno": 26,
      "original_line": "last_d = -1",
      "mutated_line": "last_d = +1",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = +1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "LCR",
      "lineno": 40,
      "original_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):",
      "mutated_line": "if d_min < r_min or is_in_range(i_point, last_v, vertices[0]):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min or is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi / (r_max ** 2 - r_min ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi / (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi + (r_max ** 2 - r_min ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi + (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi ** (r_max ** 2 - r_min ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi ** (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = p2[1] - p1[1]",
      "mutated_line": "a = p2[1] + p1[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] + p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "a = p2[1] - p1[1]",
      "mutated_line": "a = p2[1] * p1[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] * p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "b = p1[0] - p2[0]",
      "mutated_line": "b = p1[0] + p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] + p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "b = p1[0] - p2[0]",
      "mutated_line": "b = p1[0] * p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] * p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[1] + p2[1] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] + p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[1] * (p2[1] * p1[0])",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] * (p2[1] * p1[0])\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) * math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) * math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) // math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) // math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) * (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) * (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) // (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) // (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) * (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) * (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) // (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) // (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "LCR",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min <= i_point[0] <= x_max or y_min <= i_point[1] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max or y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "last_d = -1",
      "mutated_line": "last_d = -2",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -2\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "last_d = -1",
      "mutated_line": "last_d = -0",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -0\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "last_d = -1",
      "mutated_line": "last_d = -0",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -0\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "last_d = -1",
      "mutated_line": "last_d = --1",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = --1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d > r_max:",
      "mutated_line": "if d >= r_max:",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d >= r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d > r_max:",
      "mutated_line": "if d <= r_max:",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d <= r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if d > r_max:",
      "mutated_line": "if d != r_max:",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d != r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if d < r_min:",
      "mutated_line": "if d <= r_min:",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d <= r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if d < r_min:",
      "mutated_line": "if d >= r_min:",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d >= r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if d < r_min:",
      "mutated_line": "if d != r_min:",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d != r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "last_v = vertices[0]",
      "mutated_line": "last_v = vertices[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[1]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "last_v = vertices[0]",
      "mutated_line": "last_v = vertices[-1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[-1]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "last_v = vertices[0]",
      "mutated_line": "last_v = vertices[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[1]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(2, n):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(2, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(0, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(0, n):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(0, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "for i in range(1, n):",
      "mutated_line": "for i in range(-1, n):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(-1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "LCR",
      "lineno": 36,
      "original_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):",
      "mutated_line": "if d_min < r_min or is_in_range(i_point, last_v, vertices[i]):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min or is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):",
      "mutated_line": "if d_min <= r_min and is_in_range(i_point, last_v, vertices[0]):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min <= r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):",
      "mutated_line": "if d_min >= r_min and is_in_range(i_point, last_v, vertices[0]):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min >= r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):",
      "mutated_line": "if d_min != r_min and is_in_range(i_point, last_v, vertices[0]):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min != r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 2 + r_min ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 + r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 2 * r_min ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 * r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 - (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 - (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 * (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 * (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] / p1[1] - p2[1] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] / p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] + p1[1] - p2[1] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] + p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] ** p1[1] - p2[1] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] ** p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[1] - p2[1] / p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] / p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[1] - (p2[1] + p1[0])",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - (p2[1] + p1[0])\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[1] - p2[1] ** p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] ** p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) + a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) + a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = b * (b * p0[0] - a * p0[1]) * (a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = b * (b * p0[0] - a * p0[1]) * (a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 - b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 - b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 * b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 * b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) + b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) + b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = a * (-b * p0[0] + a * p0[1]) * (b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = a * (-b * p0[0] + a * p0[1]) * (b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 - b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 - b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 * b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 * b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[0] if p1[0] < p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] < p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[0] if p1[0] > p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] > p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[0] if p1[0] == p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] == p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[0] if p1[0] >= p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] >= p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[0] if p1[0] <= p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] <= p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[0] if p1[0] != p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] != p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[1] < p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] < p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[1] > p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] > p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[1] == p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] == p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[1] >= p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] >= p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[1] <= p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] <= p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[1] != p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] != p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min < i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min < i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min > i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min > i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min == i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min == i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min <= i_point[0] <= x_max and y_min < i_point[1] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min < i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min <= i_point[0] <= x_max and y_min > i_point[1] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min > i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min <= i_point[0] <= x_max and y_min == i_point[1] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min == i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):",
      "mutated_line": "if d_min <= r_min and is_in_range(i_point, last_v, vertices[i]):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min <= r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):",
      "mutated_line": "if d_min >= r_min and is_in_range(i_point, last_v, vertices[i]):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min >= r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):",
      "mutated_line": "if d_min != r_min and is_in_range(i_point, last_v, vertices[i]):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min != r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))",
      "mutated_line": "(d_min, i_point) = distance_point_to_line(last_v, vertices[1], (x, y))",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[1], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))",
      "mutated_line": "(d_min, i_point) = distance_point_to_line(last_v, vertices[-1], (x, y))",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[-1], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 39,
      "original_line": "(d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))",
      "mutated_line": "(d_min, i_point) = distance_point_to_line(last_v, vertices[1], (x, y))",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[1], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max * 2 - r_min ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max * 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max + 2 - r_min ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max + 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 2 - r_min * 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min * 2)"
    },
    {
      "operator": "AOR",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 2 - (r_min + 2))",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - (r_min + 2))"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) * 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) * 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt(p1[0] - p2[0] + 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt(p1[0] - p2[0] + 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) * 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) * 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1] + 2))",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1] + 2))\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "a = p2[1] - p1[1]",
      "mutated_line": "a = p2[2] - p1[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[2] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "a = p2[1] - p1[1]",
      "mutated_line": "a = p2[0] - p1[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[0] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "a = p2[1] - p1[1]",
      "mutated_line": "a = p2[0] - p1[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[0] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "a = p2[1] - p1[1]",
      "mutated_line": "a = p2[-1] - p1[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[-1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "a = p2[1] - p1[1]",
      "mutated_line": "a = p2[1] - p1[2]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[2]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "a = p2[1] - p1[1]",
      "mutated_line": "a = p2[1] - p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[0]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "a = p2[1] - p1[1]",
      "mutated_line": "a = p2[1] - p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[0]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "a = p2[1] - p1[1]",
      "mutated_line": "a = p2[1] - p1[-1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[-1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b = p1[0] - p2[0]",
      "mutated_line": "b = p1[1] - p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[1] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b = p1[0] - p2[0]",
      "mutated_line": "b = p1[-1] - p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[-1] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b = p1[0] - p2[0]",
      "mutated_line": "b = p1[1] - p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[1] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b = p1[0] - p2[0]",
      "mutated_line": "b = p1[0] - p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[1]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b = p1[0] - p2[0]",
      "mutated_line": "b = p1[0] - p2[-1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[-1]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "b = p1[0] - p2[0]",
      "mutated_line": "b = p1[0] - p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[1]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] - c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] - c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs((a * p0[0] + b * p0[1]) * c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs((a * p0[0] + b * p0[1]) * c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 - b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 - b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 * b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 * b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b / (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b / (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b + (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b + (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b ** (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b ** (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a / c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a / c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - (a + c)) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - (a + c)) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a ** c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a ** c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a * 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a * 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a + 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a + 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b * 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b * 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + (b + 2))",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + (b + 2))\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a / (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a / (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a + (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a + (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a ** (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a ** (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b / c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b / c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - (b + c)) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - (b + c)) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b ** c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b ** c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a * 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a * 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a + 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a + 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b * 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b * 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + (b + 2))",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + (b + 2))\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[1] if p1[0] <= p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[1] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[-1] if p1[0] <= p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[-1] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[1] if p1[0] <= p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[1] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[1]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[-1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[-1]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[1]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[1] if p1[0] > p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[1] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[-1] if p1[0] > p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[-1] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[1] if p1[0] > p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[1] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[0] if p1[0] > p2[0] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[1]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[0] if p1[0] > p2[0] else p2[-1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[-1]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[0] if p1[0] > p2[0] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[1]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[2] if p1[1] <= p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[2] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[0] if p1[1] <= p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[0] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[0] if p1[1] <= p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[0] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[-1] if p1[1] <= p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[-1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[2]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[2]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[0]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[0]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[-1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[-1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[2] if p1[1] > p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[2] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[0] if p1[1] > p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[0] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[0] if p1[1] > p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[0] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[-1] if p1[1] > p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[-1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[1] > p2[1] else p2[2]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[2]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[1] > p2[1] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[0]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[1] > p2[1] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[0]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[1] > p2[1] else p2[-1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[-1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):",
      "mutated_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[1]):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[1]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):",
      "mutated_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[-1]):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[-1]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):",
      "mutated_line": "if d_min < r_min and is_in_range(i_point, last_v, vertices[1]):",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[1]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 3 - r_min ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 3 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 1 - r_min ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 1 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 0 - r_min ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 0 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 1 - r_min ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 1 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** -2 - r_min ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** -2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 2 - r_min ** 3)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 3)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 2 - r_min ** 1)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 1)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 2 - r_min ** 0)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 0)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 2 - r_min ** 1)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 1)"
    },
    {
      "operator": "CRP",
      "lineno": 42,
      "original_line": "return math.pi * (r_max ** 2 - r_min ** 2)",
      "mutated_line": "return math.pi * (r_max ** 2 - r_min ** -2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** -2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] + p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] + p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] * p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] * p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 3 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 3 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 1 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 1 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 0 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 0 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 1 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 1 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** -2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** -2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] + p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] + p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] * p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] * p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 3)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 3)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 1)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 1)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 0)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 0)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 1)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 1)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** -2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** -2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[1] * p1[1] - p2[1] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[1] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[-1] * p1[1] - p2[1] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[-1] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[1] * p1[1] - p2[1] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[1] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[2] - p2[1] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[2] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[0] - p2[1] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[0] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[0] - p2[1] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[0] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[-1] - p2[1] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[-1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[1] - p2[2] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[2] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[1] - p2[0] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[0] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[1] - p2[0] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[0] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[1] - p2[-1] * p1[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[-1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[1] - p2[1] * p1[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[1]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[1] - p2[1] * p1[-1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[-1]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "c = p2[0] * p1[1] - p2[1] * p1[0]",
      "mutated_line": "c = p2[0] * p1[1] - p2[1] * p1[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[1]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] - b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] - b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] * (b * p0[1]) + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] * (b * p0[1]) + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a * 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a * 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a + 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a + 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b * 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b * 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + (b + 2))",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + (b + 2))\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] + a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] + a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] * (a * p0[1])) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] * (a * p0[1])) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 3 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 3 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 1 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 1 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 0 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 0 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 1 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 1 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** -2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** -2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 3)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 3)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 1)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 1)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 0)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 0)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 1)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 1)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** -2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** -2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] - a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] - a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] * (a * p0[1])) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] * (a * p0[1])) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 3 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 3 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 1 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 1 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 0 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 0 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 1 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 1 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** -2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** -2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 3)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 3)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 1)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 1)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 0)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 0)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 1)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 1)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** -2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** -2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[0] if p1[1] <= p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[1] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[0] if p1[-1] <= p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[-1] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[0] if p1[1] <= p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[1] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[0] if p1[0] <= p2[1] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[1] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[0] if p1[0] <= p2[-1] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[-1] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "x_min = p1[0] if p1[0] <= p2[0] else p2[0]",
      "mutated_line": "x_min = p1[0] if p1[0] <= p2[1] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[1] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[0] if p1[1] > p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[1] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[0] if p1[-1] > p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[-1] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[0] if p1[1] > p2[0] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[1] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[0] if p1[0] > p2[1] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[1] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[0] if p1[0] > p2[-1] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[-1] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "x_max = p1[0] if p1[0] > p2[0] else p2[0]",
      "mutated_line": "x_max = p1[0] if p1[0] > p2[1] else p2[0]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[1] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[2] <= p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[2] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[0] <= p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[0] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[0] <= p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[0] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[-1] <= p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[-1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[1] <= p2[2] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[2] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[1] <= p2[0] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[0] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[1] <= p2[0] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[0] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "y_min = p1[1] if p1[1] <= p2[1] else p2[1]",
      "mutated_line": "y_min = p1[1] if p1[1] <= p2[-1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[-1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[2] > p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[2] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[0] > p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[0] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[0] > p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[0] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[-1] > p2[1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[-1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[1] > p2[2] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[2] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[1] > p2[0] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[0] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[1] > p2[0] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[0] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "y_max = p1[1] if p1[1] > p2[1] else p2[1]",
      "mutated_line": "y_max = p1[1] if p1[1] > p2[-1] else p2[1]",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[-1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min <= i_point[1] <= x_max and y_min <= i_point[1] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[1] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min <= i_point[-1] <= x_max and y_min <= i_point[1] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[-1] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min <= i_point[1] <= x_max and y_min <= i_point[1] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[1] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[2] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[2] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[0] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[0] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[0] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[0] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max",
      "mutated_line": "return x_min <= i_point[0] <= x_max and y_min <= i_point[-1] <= y_max",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[-1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a / p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a / p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a + p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a + p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a ** p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a ** p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b / p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b / p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + (b + p0[1]) + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + (b + p0[1]) + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b ** p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b ** p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 3 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 3 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 1 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 1 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 0 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 0 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 1 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 1 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** -2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** -2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 3)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 3)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 1)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 1)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 0)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 0)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 1)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 1)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** -2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** -2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b / p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b / p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b + p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b + p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b ** p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b ** p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a / p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a / p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - (a + p0[1])) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - (a + p0[1])) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a ** p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a ** p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b / p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b / p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b + p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b + p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * ((-b) ** p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * ((-b) ** p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a / p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a / p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + (a + p0[1])) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + (a + p0[1])) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a ** p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a ** p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[-1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[-1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[1] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[1]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[1]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[-1]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[-1]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[1]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[1]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[2] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[2] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[0] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[0] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[0] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[0] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[-1] - p2[1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[-1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[2]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[2]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[0]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[0]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[0]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[0]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)",
      "mutated_line": "return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[-1]) ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[-1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "UOI",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (+b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (+b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[1] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[1] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[-1] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[-1] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[1] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[1] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[2] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[2] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[0] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[0] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[0] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[0] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "mutated_line": "dist = math.fabs(a * p0[0] + b * p0[-1] + c) / math.sqrt(a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[-1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[1] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[1] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[-1] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[-1] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[1] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[1] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[2]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[2]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[0]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[0]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[0]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[0]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)",
      "mutated_line": "x_int = (b * (b * p0[0] - a * p0[-1]) - a * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[-1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[1] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[1] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[-1] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[-1] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[1] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[1] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[2]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[2]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[0]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[0]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[0]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[0]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    },
    {
      "operator": "CRP",
      "lineno": 14,
      "original_line": "y_int = (a * (-b * p0[0] + a * p0[1]) - b * c) / (a ** 2 + b ** 2)",
      "mutated_line": "y_int = (a * (-b * p0[0] + a * p0[-1]) - b * c) / (a ** 2 + b ** 2)",
      "code": "import math\nimport sys\n\ndef calculate_cleared_area(n, x, y, vertices):\n\n    def distance_two_points(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def distance_point_to_line(p1, p2, p0):\n        a = p2[1] - p1[1]\n        b = p1[0] - p2[0]\n        c = p2[0] * p1[1] - p2[1] * p1[0]\n        dist = math.fabs(a * p0[0] + b * p0[1] + c) / math.sqrt(a ** 2 + b ** 2)\n        x_int = (b * (b * p0[0] - a * p0[1]) - a * c) / (a ** 2 + b ** 2)\n        y_int = (a * (-b * p0[0] + a * p0[-1]) - b * c) / (a ** 2 + b ** 2)\n        return (dist, (x_int, y_int))\n\n    def is_in_range(i_point, p1, p2):\n        x_min = p1[0] if p1[0] <= p2[0] else p2[0]\n        x_max = p1[0] if p1[0] > p2[0] else p2[0]\n        y_min = p1[1] if p1[1] <= p2[1] else p2[1]\n        y_max = p1[1] if p1[1] > p2[1] else p2[1]\n        return x_min <= i_point[0] <= x_max and y_min <= i_point[1] <= y_max\n    r_max = -sys.maxsize\n    r_min = sys.maxsize\n    last_d = -1\n    for v in vertices:\n        d = distance_two_points(v, (x, y))\n        if d > r_max:\n            r_max = d\n        if d < r_min:\n            r_min = d\n    last_v = vertices[0]\n    for i in range(1, n):\n        (d_min, i_point) = distance_point_to_line(last_v, vertices[i], (x, y))\n        if d_min < r_min and is_in_range(i_point, last_v, vertices[i]):\n            r_min = d_min\n        last_v = vertices[i]\n    (d_min, i_point) = distance_point_to_line(last_v, vertices[0], (x, y))\n    if d_min < r_min and is_in_range(i_point, last_v, vertices[0]):\n        r_min = d_min\n    return math.pi * (r_max ** 2 - r_min ** 2)"
    }
  ]
}