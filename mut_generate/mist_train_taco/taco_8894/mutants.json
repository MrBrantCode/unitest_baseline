{
  "task_id": "taco_8894",
  "entry_point": "min_operations_to_reach_goal",
  "mutant_count": 37,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 100003  # A constant to ensure adjacency list size is sufficient",
      "mutated_line": "N = 100004",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100004\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 100003  # A constant to ensure adjacency list size is sufficient",
      "mutated_line": "N = 100002",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100002\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 100003  # A constant to ensure adjacency list size is sufficient",
      "mutated_line": "N = 0",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 0\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 100003  # A constant to ensure adjacency list size is sufficient",
      "mutated_line": "N = 1",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 1\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "N = 100003  # A constant to ensure adjacency list size is sufficient",
      "mutated_line": "N = -100003",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = -100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a = [0] + initial_values",
      "mutated_line": "a = [0] - initial_values",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] - initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 11,
      "original_line": "a = [0] + initial_values",
      "mutated_line": "a = [0] * initial_values",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] * initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = [0] + goal_values",
      "mutated_line": "b = [0] - goal_values",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] - goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 12,
      "original_line": "b = [0] + goal_values",
      "mutated_line": "b = [0] * goal_values",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] * goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 15,
      "original_line": "d = [i ^ j for i, j in zip(a, b)]",
      "mutated_line": "d = [i | j for (i, j) in zip(a, b)]",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i | j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(2, 0, 0, 0)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(2, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(0, 0, 0, 0)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(0, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(0, 0, 0, 0)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(0, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(-1, 0, 0, 0)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(-1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(1, 1, 0, 0)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 1, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(1, -1, 0, 0)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, -1, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(1, 1, 0, 0)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 1, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(1, 0, 1, 0)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 1, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(1, 0, -1, 0)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, -1, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(1, 0, 1, 0)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 1, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(1, 0, 0, 1)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 1)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(1, 0, 0, -1)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, -1)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 31,
      "original_line": "dfs(1, 0, 0, 0)",
      "mutated_line": "dfs(1, 0, 0, 1)",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 1)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a = [0] + initial_values",
      "mutated_line": "a = [1] + initial_values",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [1] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a = [0] + initial_values",
      "mutated_line": "a = [-1] + initial_values",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [-1] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "a = [0] + initial_values",
      "mutated_line": "a = [1] + initial_values",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [1] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = [0] + goal_values",
      "mutated_line": "b = [1] + goal_values",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [1] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = [0] + goal_values",
      "mutated_line": "b = [-1] + goal_values",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [-1] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "b = [0] + goal_values",
      "mutated_line": "b = [1] + goal_values",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [1] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 23,
      "original_line": "if c_lvl != d[u]:",
      "mutated_line": "if c_lvl == d[u]:",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl == d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "c_lvl = 1 - c_lvl",
      "mutated_line": "c_lvl = 1 + c_lvl",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 + c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "AOR",
      "lineno": 24,
      "original_line": "c_lvl = 1 - c_lvl",
      "mutated_line": "c_lvl = 1 * c_lvl",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 * c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "ROR",
      "lineno": 27,
      "original_line": "if v != p:",
      "mutated_line": "if v == p:",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v == p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "c_lvl = 1 - c_lvl",
      "mutated_line": "c_lvl = 2 - c_lvl",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 2 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "c_lvl = 1 - c_lvl",
      "mutated_line": "c_lvl = 0 - c_lvl",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 0 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "c_lvl = 1 - c_lvl",
      "mutated_line": "c_lvl = 0 - c_lvl",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = 0 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    },
    {
      "operator": "CRP",
      "lineno": 24,
      "original_line": "c_lvl = 1 - c_lvl",
      "mutated_line": "c_lvl = -1 - c_lvl",
      "code": "def min_operations_to_reach_goal(n, edges, initial_values, goal_values):\n    N = 100003\n    adj = [[] for _ in range(N)]\n    for (u, v) in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n    a = [0] + initial_values\n    b = [0] + goal_values\n    d = [i ^ j for (i, j) in zip(a, b)]\n    res = []\n\n    def dfs(u, p, c_lvl, p_lvl):\n        stk = [(u, p, c_lvl, p_lvl)]\n        while stk:\n            (u, p, c_lvl, p_lvl) = stk.pop()\n            if c_lvl != d[u]:\n                c_lvl = -1 - c_lvl\n                res.append(u)\n            for v in adj[u]:\n                if v != p:\n                    stk.append((v, u, p_lvl, c_lvl))\n    dfs(1, 0, 0, 0)\n    cnt = len(res)\n    operations = res\n    return (cnt, operations)"
    }
  ]
}