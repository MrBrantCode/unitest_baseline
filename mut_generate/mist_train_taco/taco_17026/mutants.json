{
  "task_id": "taco_17026",
  "entry_point": "find_min_k_for_sum_multiple",
  "mutant_count": 158,
  "mutants": [
    {
      "operator": "ROR",
      "lineno": 2,
      "original_line": "if N == 1:",
      "mutated_line": "if N != 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N != 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 6,
      "original_line": "if N % 2 == 0:",
      "mutated_line": "if N % 2 != 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 != 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 8,
      "original_line": "N *= 2",
      "mutated_line": "N /= 2",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N /= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 1:",
      "mutated_line": "if N == 2:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 2:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 1:",
      "mutated_line": "if N == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 0:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 1:",
      "mutated_line": "if N == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 0:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 2,
      "original_line": "if N == 1:",
      "mutated_line": "if N == -1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == -1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 1",
      "mutated_line": "return 2",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 2\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 0\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 1",
      "mutated_line": "return 0",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 0\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 3,
      "original_line": "return 1",
      "mutated_line": "return -1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return -1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if N % 2 == 0:",
      "mutated_line": "if N * 2 == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N * 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "if N % 2 == 0:",
      "mutated_line": "if N + 2 == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N + 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if N % 2 == 0:",
      "mutated_line": "if N % 2 == 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 1:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if N % 2 == 0:",
      "mutated_line": "if N % 2 == -1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == -1:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if N % 2 == 0:",
      "mutated_line": "if N % 2 == 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 1:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 2 * N + 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N + 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 2 * N * 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N * 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "N *= 2",
      "mutated_line": "N *= 3",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 3\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "N *= 2",
      "mutated_line": "N *= 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 1\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "N *= 2",
      "mutated_line": "N *= 0",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 0\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "N *= 2",
      "mutated_line": "N *= 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 1\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "N *= 2",
      "mutated_line": "N *= -2",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= -2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans = N - 1",
      "mutated_line": "ans = N + 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N + 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 10,
      "original_line": "ans = N - 1",
      "mutated_line": "ans = N * 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N * 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for p in range(2, N):",
      "mutated_line": "for p in range(3, N):",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(3, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for p in range(2, N):",
      "mutated_line": "for p in range(1, N):",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(1, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for p in range(2, N):",
      "mutated_line": "for p in range(0, N):",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(0, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for p in range(2, N):",
      "mutated_line": "for p in range(1, N):",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(1, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "for p in range(2, N):",
      "mutated_line": "for p in range(-2, N):",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(-2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if p * p > N:",
      "mutated_line": "if p * p >= N:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p >= N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if p * p > N:",
      "mutated_line": "if p * p <= N:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p <= N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 14,
      "original_line": "if p * p > N:",
      "mutated_line": "if p * p != N:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p != N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if N % p == 0:",
      "mutated_line": "if N % p != 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p != 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 34,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 1 and b == 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 and b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if a < b:",
      "mutated_line": "if a <= b:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a <= b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if a < b:",
      "mutated_line": "if a >= b:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a >= b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 36,
      "original_line": "if a < b:",
      "mutated_line": "if a != b:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a != b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while a % b > 1:",
      "mutated_line": "while a % b >= 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b >= 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while a % b > 1:",
      "mutated_line": "while a % b <= 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b <= 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 40,
      "original_line": "while a % b > 1:",
      "mutated_line": "while a % b != 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b != 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 46,
      "original_line": "flag = True",
      "mutated_line": "flag = False",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = False\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if ans > b * y:",
      "mutated_line": "if ans >= b * y:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans >= b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if ans > b * y:",
      "mutated_line": "if ans <= b * y:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans <= b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 55,
      "original_line": "if ans > b * y:",
      "mutated_line": "if ans != b * y:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans != b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if N % 2 == 0:",
      "mutated_line": "if N % 3 == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 3 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if N % 2 == 0:",
      "mutated_line": "if N % 1 == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 1 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if N % 2 == 0:",
      "mutated_line": "if N % 0 == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 0 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if N % 2 == 0:",
      "mutated_line": "if N % 1 == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 1 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "if N % 2 == 0:",
      "mutated_line": "if N % -2 == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % -2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 2 / N - 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 / N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 2 + N - 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 + N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 2 ** N - 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 ** N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 2 * N - 2",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 2\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 2 * N - 0",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 0\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 2 * N - 0",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 0\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 2 * N - -1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - -1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = N - 1",
      "mutated_line": "ans = N - 2",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 2\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = N - 1",
      "mutated_line": "ans = N - 0",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 0\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = N - 1",
      "mutated_line": "ans = N - 0",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 0\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "ans = N - 1",
      "mutated_line": "ans = N - -1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - -1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if p * p > N:",
      "mutated_line": "if p / p > N:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p / p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if p * p > N:",
      "mutated_line": "if p + p > N:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p + p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 14,
      "original_line": "if p * p > N:",
      "mutated_line": "if p ** p > N:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p ** p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if N > 1:",
      "mutated_line": "if N >= 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N >= 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if N > 1:",
      "mutated_line": "if N <= 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N <= 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 15,
      "original_line": "if N > 1:",
      "mutated_line": "if N != 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N != 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if N % p == 0:",
      "mutated_line": "if N * p == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N * p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if N % p == 0:",
      "mutated_line": "if N + p == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N + p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if N % p == 0:",
      "mutated_line": "if N % p == 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 1:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if N % p == 0:",
      "mutated_line": "if N % p == -1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == -1:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if N % p == 0:",
      "mutated_line": "if N % p == 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 1:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 1\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = -1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = -1\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "cnt = 0",
      "mutated_line": "cnt = 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 1\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 20,
      "original_line": "while N % p == 0:",
      "mutated_line": "while N % p != 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p != 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 21,
      "original_line": "cnt += 1",
      "mutated_line": "cnt -= 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt -= 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for tf in product([True, False], repeat=len(factors)):",
      "mutated_line": "for tf in product([False, False], repeat=len(factors)):",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([False, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for tf in product([True, False], repeat=len(factors)):",
      "mutated_line": "for tf in product([True, True], repeat=len(factors)):",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, True], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (2, 1)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (2, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (0, 1)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (0, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (0, 1)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (0, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (-1, 1)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (-1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (1, 2)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 2)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (1, 0)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 0)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (1, 0)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 0)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "(a, b) = (1, 1)",
      "mutated_line": "(a, b) = (1, -1)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, -1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 31,
      "original_line": "a *= factors[i]",
      "mutated_line": "a /= factors[i]",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a /= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 33,
      "original_line": "b *= factors[i]",
      "mutated_line": "b /= factors[i]",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b /= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a != 1 or b == 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a != 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 34,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 1 or b != 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b != 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "while a % b > 1:",
      "mutated_line": "while a * b > 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a * b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 40,
      "original_line": "while a % b > 1:",
      "mutated_line": "while a + b > 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a + b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while a % b > 1:",
      "mutated_line": "while a % b > 2:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 2:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while a % b > 1:",
      "mutated_line": "while a % b > 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 0:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while a % b > 1:",
      "mutated_line": "while a % b > 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 0:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 40,
      "original_line": "while a % b > 1:",
      "mutated_line": "while a % b > -1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > -1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "(x, y) = (1, a // b)",
      "mutated_line": "(x, y) = (2, a // b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (2, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "(x, y) = (1, a // b)",
      "mutated_line": "(x, y) = (0, a // b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (0, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "(x, y) = (1, a // b)",
      "mutated_line": "(x, y) = (0, a // b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (0, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 45,
      "original_line": "(x, y) = (1, a // b)",
      "mutated_line": "(x, y) = (-1, a // b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (-1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(x, y) = (1, a // b)",
      "mutated_line": "(x, y) = (1, a / b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a / b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 45,
      "original_line": "(x, y) = (1, a // b)",
      "mutated_line": "(x, y) = (1, a * b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a * b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 49,
      "original_line": "x += y * quo.pop()",
      "mutated_line": "x -= y * quo.pop()",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x -= y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 52,
      "original_line": "y += x * quo.pop()",
      "mutated_line": "y -= x * quo.pop()",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y -= x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if ans > b * y:",
      "mutated_line": "if ans > b / y:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b / y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if ans > b * y:",
      "mutated_line": "if ans > b + y:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b + y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 55,
      "original_line": "if ans > b * y:",
      "mutated_line": "if ans > b ** y:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b ** y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "ans = b * y",
      "mutated_line": "ans = b / y",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b / y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "ans = b * y",
      "mutated_line": "ans = b + y",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b + y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 56,
      "original_line": "ans = b * y",
      "mutated_line": "ans = b ** y",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b ** y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 3 * N - 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 3 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 1 * N - 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 1 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 0 * N - 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 0 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = 1 * N - 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 1 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "ans = 2 * N - 1",
      "mutated_line": "ans = -2 * N - 1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = -2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if N > 1:",
      "mutated_line": "if N > 2:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 2:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if N > 1:",
      "mutated_line": "if N > 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 0:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if N > 1:",
      "mutated_line": "if N > 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 0:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "if N > 1:",
      "mutated_line": "if N > -1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > -1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while N % p == 0:",
      "mutated_line": "while N * p == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N * p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 20,
      "original_line": "while N % p == 0:",
      "mutated_line": "while N + p == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N + p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while N % p == 0:",
      "mutated_line": "while N % p == 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 1:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while N % p == 0:",
      "mutated_line": "while N % p == -1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == -1:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 20,
      "original_line": "while N % p == 0:",
      "mutated_line": "while N % p == 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 1:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 2",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 2\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 0\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += 0",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 0\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "cnt += 1",
      "mutated_line": "cnt += -1",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += -1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "factors.append(p ** cnt)",
      "mutated_line": "factors.append(p * cnt)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p * cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "factors.append(p ** cnt)",
      "mutated_line": "factors.append(p + cnt)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p + cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 2 or b == 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 2 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 0 or b == 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 0 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 0 or b == 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 0 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == -1 or b == 1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == -1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 1 or b == 2:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 2:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 1 or b == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 0:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 1 or b == 0:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 0:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "if a == 1 or b == 1:",
      "mutated_line": "if a == 1 or b == -1:",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == -1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "quo.append(0)",
      "mutated_line": "quo.append(1)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(1)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "quo.append(0)",
      "mutated_line": "quo.append(-1)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(-1)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 43,
      "original_line": "quo.append(0)",
      "mutated_line": "quo.append(1)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(1)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "x += y * quo.pop()",
      "mutated_line": "x += y / quo.pop()",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y / quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "x += y * quo.pop()",
      "mutated_line": "x += y + quo.pop()",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y + quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 49,
      "original_line": "x += y * quo.pop()",
      "mutated_line": "x += y ** quo.pop()",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y ** quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "y += x * quo.pop()",
      "mutated_line": "y += x / quo.pop()",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x / quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "y += x * quo.pop()",
      "mutated_line": "y += x + quo.pop()",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x + quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 52,
      "original_line": "y += x * quo.pop()",
      "mutated_line": "y += x ** quo.pop()",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x ** quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "(quo[-1], b) = divmod(l[-1], b)",
      "mutated_line": "(quo[+1], b) = divmod(l[-1], b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[+1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 44,
      "original_line": "(quo[-1], b) = divmod(l[-1], b)",
      "mutated_line": "(quo[-1], b) = divmod(l[+1], b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[+1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "(quo[-1], b) = divmod(l[-1], b)",
      "mutated_line": "(quo[-2], b) = divmod(l[-1], b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-2], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "(quo[-1], b) = divmod(l[-1], b)",
      "mutated_line": "(quo[-0], b) = divmod(l[-1], b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-0], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "(quo[-1], b) = divmod(l[-1], b)",
      "mutated_line": "(quo[-0], b) = divmod(l[-1], b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-0], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "(quo[-1], b) = divmod(l[-1], b)",
      "mutated_line": "(quo[--1], b) = divmod(l[-1], b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[--1], b) = divmod(l[-1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "(quo[-1], b) = divmod(l[-1], b)",
      "mutated_line": "(quo[-1], b) = divmod(l[-2], b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-2], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "(quo[-1], b) = divmod(l[-1], b)",
      "mutated_line": "(quo[-1], b) = divmod(l[-0], b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-0], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "(quo[-1], b) = divmod(l[-1], b)",
      "mutated_line": "(quo[-1], b) = divmod(l[-0], b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[-0], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 44,
      "original_line": "(quo[-1], b) = divmod(l[-1], b)",
      "mutated_line": "(quo[-1], b) = divmod(l[--1], b)",
      "code": "def find_min_k_for_sum_multiple(N):\n    if N == 1:\n        return 1\n    n_copy = N\n    if N % 2 == 0:\n        ans = 2 * N - 1\n        N *= 2\n    else:\n        ans = N - 1\n    factors = []\n    for p in range(2, N):\n        if p * p > N:\n            if N > 1:\n                factors.append(N)\n            break\n        if N % p == 0:\n            cnt = 0\n            while N % p == 0:\n                cnt += 1\n                N //= p\n            factors.append(p ** cnt)\n    from itertools import product\n    for tf in product([True, False], repeat=len(factors)):\n        (a, b) = (1, 1)\n        for i in range(len(factors)):\n            if tf[i]:\n                a *= factors[i]\n            else:\n                b *= factors[i]\n        if a == 1 or b == 1:\n            continue\n        if a < b:\n            (a, b) = (b, a)\n        l = []\n        quo = []\n        while a % b > 1:\n            l.append(a)\n            a = b\n            quo.append(0)\n            (quo[-1], b) = divmod(l[--1], b)\n        (x, y) = (1, a // b)\n        flag = True\n        while l:\n            if flag:\n                x += y * quo.pop()\n                b = l.pop()\n            else:\n                y += x * quo.pop()\n                a = l.pop()\n            flag = not flag\n        if ans > b * y:\n            ans = b * y\n    return ans"
    }
  ]
}