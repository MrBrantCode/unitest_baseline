{
  "task_id": "taco_12335",
  "entry_point": "check_circle_overlap",
  "mutant_count": 43,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sum_of_radii = radius1 + radius2",
      "mutated_line": "sum_of_radii = radius1 - radius2",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 - radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "AOR",
      "lineno": 8,
      "original_line": "sum_of_radii = radius1 + radius2",
      "mutated_line": "sum_of_radii = radius1 * radius2",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 * radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "ROR",
      "lineno": 10,
      "original_line": "if dist == sum_of_radii:",
      "mutated_line": "if dist != sum_of_radii:",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist != sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 11,
      "original_line": "return 'T'",
      "mutated_line": "return ''",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return ''\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif dist > sum_of_radii:",
      "mutated_line": "elif dist >= sum_of_radii:",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist >= sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif dist > sum_of_radii:",
      "mutated_line": "elif dist <= sum_of_radii:",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist <= sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "ROR",
      "lineno": 12,
      "original_line": "elif dist > sum_of_radii:",
      "mutated_line": "elif dist != sum_of_radii:",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist != sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 - (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 - (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 * (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 * (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "return 'N'",
      "mutated_line": "return ''",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return ''\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 15,
      "original_line": "return 'Y'",
      "mutated_line": "return ''",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return ''"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) * 2 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) * 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt(p0[0] - p1[0] + 2 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt(p0[0] - p1[0] + 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) * 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) * 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1] + 2))",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1] + 2))\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] + p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] + p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] * p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] * p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 3 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 3 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 1 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 1 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 0 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 0 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 1 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 1 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** -2 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** -2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] + p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] + p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] * p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] * p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 3)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 3)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 1)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 1)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 0)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 0)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 1)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 1)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** -2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** -2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[1] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[1] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[-1] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[-1] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[1] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[1] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[1]) ** 2 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[1]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[-1]) ** 2 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[-1]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[1]) ** 2 + (p0[1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[1]) ** 2 + (p0[1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[2] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[2] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[0] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[0] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[0] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[0] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[-1] - p1[1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[-1] - p1[1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[2]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[2]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[0]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[0]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[0]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[0]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "return math.sqrt((p0[0] - p1[0])**2 + (p0[1] - p1[1])**2)",
      "mutated_line": "return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[-1]) ** 2)",
      "code": "import math\n\ndef check_circle_overlap(center1, radius1, center2, radius2):\n\n    def distance(p0, p1):\n        return math.sqrt((p0[0] - p1[0]) ** 2 + (p0[1] - p1[-1]) ** 2)\n    dist = distance(center1, center2)\n    sum_of_radii = radius1 + radius2\n    if dist == sum_of_radii:\n        return 'T'\n    elif dist > sum_of_radii:\n        return 'N'\n    else:\n        return 'Y'"
    }
  ]
}