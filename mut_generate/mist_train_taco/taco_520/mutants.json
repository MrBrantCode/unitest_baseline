{
  "task_id": "taco_520",
  "entry_point": "count_connected_segments",
  "mutant_count": 118,
  "mutants": [
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 1\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = -1\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 25,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 1\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "prev = 0",
      "mutated_line": "prev = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 1\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "prev = 0",
      "mutated_line": "prev = -1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = -1\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 26,
      "original_line": "prev = 0",
      "mutated_line": "prev = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 1\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 39,
      "original_line": "ans += prev",
      "mutated_line": "ans -= prev",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans -= prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 1\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans = 0",
      "mutated_line": "ans = -1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = -1\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 8,
      "original_line": "ans = 0",
      "mutated_line": "ans = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 1\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cur_max = 0",
      "mutated_line": "cur_max = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 1\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cur_max = 0",
      "mutated_line": "cur_max = -1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = -1\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "cur_max = 0",
      "mutated_line": "cur_max = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 1\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "cur_len = 0",
      "mutated_line": "cur_len = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 1\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "cur_len = 0",
      "mutated_line": "cur_len = -1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = -1\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 10,
      "original_line": "cur_len = 0",
      "mutated_line": "cur_len = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 1\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 16,
      "original_line": "cur_len += 1",
      "mutated_line": "cur_len -= 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len -= 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n + 1, -1, -1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n + 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n * 1, -1, -1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n * 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 1, +1, -1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, +1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 1, -1, +1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, +1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "neigh = 0",
      "mutated_line": "neigh = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 1\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "neigh = 0",
      "mutated_line": "neigh = -1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = -1\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 28,
      "original_line": "neigh = 0",
      "mutated_line": "neigh = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 1\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "plus = 0",
      "mutated_line": "plus = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 1\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "plus = 0",
      "mutated_line": "plus = -1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = -1\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "plus = 0",
      "mutated_line": "plus = 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 1\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 35,
      "original_line": "if plus == neigh and plus == 1:",
      "mutated_line": "if plus == neigh or plus == 1:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh or plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 36,
      "original_line": "prev += 1",
      "mutated_line": "prev -= 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev -= 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "neighbors[a - 1].append(b - 1)",
      "mutated_line": "neighbors[a - 1].append(b + 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b + 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "neighbors[a - 1].append(b - 1)",
      "mutated_line": "neighbors[a - 1].append(b * 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b * 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "neighbors[b - 1].append(a - 1)",
      "mutated_line": "neighbors[b - 1].append(a + 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a + 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "neighbors[b - 1].append(a - 1)",
      "mutated_line": "neighbors[b - 1].append(a * 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a * 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 12,
      "original_line": "vis = [False for _ in range(n)]",
      "mutated_line": "vis = [True for _ in range(n)]",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [True for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cur_len += 1",
      "mutated_line": "cur_len += 2",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 2\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cur_len += 1",
      "mutated_line": "cur_len += 0",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 0\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cur_len += 1",
      "mutated_line": "cur_len += 0",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 0\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "cur_len += 1",
      "mutated_line": "cur_len += -1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += -1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 17,
      "original_line": "vis[x] = True",
      "mutated_line": "vis[x] = False",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = False\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if cur_max - source + 1 == cur_len:",
      "mutated_line": "if cur_max - source + 1 != cur_len:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 != cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 19,
      "original_line": "ans += 1",
      "mutated_line": "ans -= 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans -= 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 2, -1, -1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 2, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 0, -1, -1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 0, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 0, -1, -1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 0, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - -1, -1, -1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - -1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 1, -2, -1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -2, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 1, -0, -1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -0, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 1, -0, -1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -0, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 1, --1, -1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, --1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 1, -1, -2):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -2):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 1, -1, -0):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -0):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 1, -1, -0):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -0):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 27,
      "original_line": "for x in range(n - 1, -1, -1):",
      "mutated_line": "for x in range(n - 1, -1, --1):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, --1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if y > x:",
      "mutated_line": "if y >= x:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y >= x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if y > x:",
      "mutated_line": "if y <= x:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y <= x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 31,
      "original_line": "if y > x:",
      "mutated_line": "if y != x:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y != x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ASR",
      "lineno": 32,
      "original_line": "neigh += 1",
      "mutated_line": "neigh -= 1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh -= 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 33,
      "original_line": "if y == x + 1:",
      "mutated_line": "if y != x + 1:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y != x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if plus == neigh and plus == 1:",
      "mutated_line": "if plus != neigh and plus == 1:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus != neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 35,
      "original_line": "if plus == neigh and plus == 1:",
      "mutated_line": "if plus == neigh and plus != 1:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus != 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "prev += 1",
      "mutated_line": "prev += 2",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 2\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "prev += 1",
      "mutated_line": "prev += 0",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 0\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "prev += 1",
      "mutated_line": "prev += 0",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 0\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 36,
      "original_line": "prev += 1",
      "mutated_line": "prev += -1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += -1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "neighbors[a - 1].append(b - 1)",
      "mutated_line": "neighbors[a - 1].append(b - 2)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 2)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "neighbors[a - 1].append(b - 1)",
      "mutated_line": "neighbors[a - 1].append(b - 0)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 0)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "neighbors[a - 1].append(b - 1)",
      "mutated_line": "neighbors[a - 1].append(b - 0)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 0)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "neighbors[a - 1].append(b - 1)",
      "mutated_line": "neighbors[a - 1].append(b - -1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - -1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "neighbors[b - 1].append(a - 1)",
      "mutated_line": "neighbors[b - 1].append(a - 2)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 2)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "neighbors[b - 1].append(a - 1)",
      "mutated_line": "neighbors[b - 1].append(a - 0)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 0)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "neighbors[b - 1].append(a - 1)",
      "mutated_line": "neighbors[b - 1].append(a - 0)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 0)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "neighbors[b - 1].append(a - 1)",
      "mutated_line": "neighbors[b - 1].append(a - -1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - -1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cur_max - source + 1 == cur_len:",
      "mutated_line": "if cur_max - source - 1 == cur_len:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source - 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cur_max - source + 1 == cur_len:",
      "mutated_line": "if (cur_max - source) * 1 == cur_len:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if (cur_max - source) * 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += 1",
      "mutated_line": "ans += 2",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 2\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 0\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += 1",
      "mutated_line": "ans += 0",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 0\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "ans += 1",
      "mutated_line": "ans += -1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += -1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "LCR",
      "lineno": 21,
      "original_line": "if y >= source and not vis[y]:",
      "mutated_line": "if y >= source or not vis[y]:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source or not vis[y]:\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "neigh += 1",
      "mutated_line": "neigh += 2",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 2\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "neigh += 1",
      "mutated_line": "neigh += 0",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 0\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "neigh += 1",
      "mutated_line": "neigh += 0",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 0\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 32,
      "original_line": "neigh += 1",
      "mutated_line": "neigh += -1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += -1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if y == x + 1:",
      "mutated_line": "if y == x - 1:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x - 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 33,
      "original_line": "if y == x + 1:",
      "mutated_line": "if y == x * 1:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x * 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "plus = 1",
      "mutated_line": "plus = 2",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 2\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "plus = 1",
      "mutated_line": "plus = 0",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 0\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "plus = 1",
      "mutated_line": "plus = 0",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 0\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 34,
      "original_line": "plus = 1",
      "mutated_line": "plus = -1",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = -1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if plus == neigh and plus == 1:",
      "mutated_line": "if plus == neigh and plus == 2:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 2:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if plus == neigh and plus == 1:",
      "mutated_line": "if plus == neigh and plus == 0:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 0:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if plus == neigh and plus == 1:",
      "mutated_line": "if plus == neigh and plus == 0:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 0:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 35,
      "original_line": "if plus == neigh and plus == 1:",
      "mutated_line": "if plus == neigh and plus == -1:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == -1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "neighbors[a - 1].append(b - 1)",
      "mutated_line": "neighbors[a + 1].append(b - 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a + 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "neighbors[a - 1].append(b - 1)",
      "mutated_line": "neighbors[a * 1].append(b - 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a * 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "neighbors[b - 1].append(a - 1)",
      "mutated_line": "neighbors[b + 1].append(a - 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b + 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "neighbors[b - 1].append(a - 1)",
      "mutated_line": "neighbors[b * 1].append(a - 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b * 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cur_max - source + 1 == cur_len:",
      "mutated_line": "if cur_max + source + 1 == cur_len:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max + source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if cur_max - source + 1 == cur_len:",
      "mutated_line": "if cur_max * source + 1 == cur_len:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max * source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if cur_max - source + 1 == cur_len:",
      "mutated_line": "if cur_max - source + 2 == cur_len:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 2 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if cur_max - source + 1 == cur_len:",
      "mutated_line": "if cur_max - source + 0 == cur_len:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 0 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if cur_max - source + 1 == cur_len:",
      "mutated_line": "if cur_max - source + 0 == cur_len:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 0 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if cur_max - source + 1 == cur_len:",
      "mutated_line": "if cur_max - source + -1 == cur_len:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + -1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if y >= source and not vis[y]:",
      "mutated_line": "if y > source and (not vis[y]):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y > source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if y >= source and not vis[y]:",
      "mutated_line": "if y < source and (not vis[y]):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y < source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 21,
      "original_line": "if y >= source and not vis[y]:",
      "mutated_line": "if y == source and (not vis[y]):",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y == source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if y == x + 1:",
      "mutated_line": "if y == x + 2:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 2:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if y == x + 1:",
      "mutated_line": "if y == x + 0:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 0:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if y == x + 1:",
      "mutated_line": "if y == x + 0:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 0:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 33,
      "original_line": "if y == x + 1:",
      "mutated_line": "if y == x + -1:",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + -1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "neighbors[a - 1].append(b - 1)",
      "mutated_line": "neighbors[a - 2].append(b - 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 2].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "neighbors[a - 1].append(b - 1)",
      "mutated_line": "neighbors[a - 0].append(b - 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 0].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "neighbors[a - 1].append(b - 1)",
      "mutated_line": "neighbors[a - 0].append(b - 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 0].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "neighbors[a - 1].append(b - 1)",
      "mutated_line": "neighbors[a - -1].append(b - 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - -1].append(b - 1)\n        neighbors[b - 1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "neighbors[b - 1].append(a - 1)",
      "mutated_line": "neighbors[b - 2].append(a - 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 2].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "neighbors[b - 1].append(a - 1)",
      "mutated_line": "neighbors[b - 0].append(a - 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 0].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "neighbors[b - 1].append(a - 1)",
      "mutated_line": "neighbors[b - 0].append(a - 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - 0].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "neighbors[b - 1].append(a - 1)",
      "mutated_line": "neighbors[b - -1].append(a - 1)",
      "code": "def count_connected_segments(n, edges):\n    neighbors = {i: [] for i in range(n)}\n    for (a, b) in edges:\n        neighbors[a - 1].append(b - 1)\n        neighbors[b - -1].append(a - 1)\n\n    def search(source):\n        ans = 0\n        cur_max = 0\n        cur_len = 0\n        heap = [source]\n        vis = [False for _ in range(n)]\n        while heap:\n            x = heappop(heap)\n            cur_max = max(cur_max, x)\n            cur_len += 1\n            vis[x] = True\n            if cur_max - source + 1 == cur_len:\n                ans += 1\n            for y in neighbors[x]:\n                if y >= source and (not vis[y]):\n                    heappush(heap, y)\n        return ans\n    ans = 0\n    prev = 0\n    for x in range(n - 1, -1, -1):\n        neigh = 0\n        plus = 0\n        for y in neighbors[x]:\n            if y > x:\n                neigh += 1\n            if y == x + 1:\n                plus = 1\n        if plus == neigh and plus == 1:\n            prev += 1\n        else:\n            prev = search(x)\n        ans += prev\n    return ans"
    }
  ]
}