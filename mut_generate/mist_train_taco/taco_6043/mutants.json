{
  "task_id": "taco_6043",
  "entry_point": "has_cyclic_shift_subsequence",
  "mutant_count": 145,
  "mutants": [
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) // log(2)) - 1",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) - 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) // log(2)) * 1",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) * 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [-1] / (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] / (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [-1] + (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] + (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [-1] ** (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] ** (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-2] / (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] / (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-2] + (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] + (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-2] ** (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] ** (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 22,
      "original_line": "max_pre = -1",
      "mutated_line": "max_pre = +1",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = +1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-1] / (m + 2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] / (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-1] + (m + 2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] + (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-1] ** (m + 2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] ** (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = [None] * q",
      "mutated_line": "ans = [None] / q",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] / q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = [None] * q",
      "mutated_line": "ans = [None] + q",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] + q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 34,
      "original_line": "ans = [None] * q",
      "mutated_line": "ans = [None] ** q",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] ** q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) // log(2)) + 2",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 2\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) // log(2)) + 0",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 0\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) // log(2)) + 0",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 0\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) // log(2)) + -1",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + -1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [-1] * (n - 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n - 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [-1] * (n * 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n * 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "prevs = [[-1] * m for i in range(logit)]",
      "mutated_line": "prevs = [[-1] / m for i in range(logit)]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] / m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "prevs = [[-1] * m for i in range(logit)]",
      "mutated_line": "prevs = [[-1] + m for i in range(logit)]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] + m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 6,
      "original_line": "prevs = [[-1] * m for i in range(logit)]",
      "mutated_line": "prevs = [[-1] ** m for i in range(logit)]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] ** m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-2] * (n - 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n - 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-2] * (n * 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n * 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for (i, j) in zip(p[1:] + [p[0]], p):",
      "mutated_line": "for (i, j) in zip(p[1:] - [p[0]], p):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] - [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 9,
      "original_line": "for (i, j) in zip(p[1:] + [p[0]], p):",
      "mutated_line": "for (i, j) in zip(p[1:] * [p[0]], p):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] * [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, logit):",
      "mutated_line": "for i in range(2, logit):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(2, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, logit):",
      "mutated_line": "for i in range(0, logit):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(0, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, logit):",
      "mutated_line": "for i in range(0, logit):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(0, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 16,
      "original_line": "for i in range(1, logit):",
      "mutated_line": "for i in range(-1, logit):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(-1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "max_pre = -1",
      "mutated_line": "max_pre = -2",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -2\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "max_pre = -1",
      "mutated_line": "max_pre = -0",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -0\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "max_pre = -1",
      "mutated_line": "max_pre = -0",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -0\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 22,
      "original_line": "max_pre = -1",
      "mutated_line": "max_pre = --1",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = --1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-1] * (m - 2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m - 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-1] * (m * 2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m * 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) / log(2)) + 1",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) / log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) * log(2)) + 1",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) * log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [+1] * (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [+1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [-1] * (n + 2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 2)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [-1] * (n + 0)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 0)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [-1] * (n + 0)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 0)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [-1] * (n + -1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + -1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [+2] * (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [+2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-2] * (n + 2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 2)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-2] * (n + 0)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 0)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-2] * (n + 0)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 0)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-2] * (n + -1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + -1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 18,
      "original_line": "if prevs[i - 1][idx] != -1:",
      "mutated_line": "if prevs[i - 1][idx] == -1:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] == -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "use = [i for i in range(n.bit_length()) if 1 & (n - 1) >> i]",
      "mutated_line": "use = [i for i in range(n.bit_length()) if 1 | n - 1 >> i]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 | n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [+1] * (m + 2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [+1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-1] * (m + 3)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 3)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-1] * (m + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 1)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-1] * (m + 0)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 0)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-1] * (m + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 1)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-1] * (m + -2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + -2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 29,
      "original_line": "if t == -1:",
      "mutated_line": "if t != -1:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t != -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [-2] * (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-2] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [-0] * (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-0] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [-0] * (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-0] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 5,
      "original_line": "current_max_index = [-1] * (n + 1)",
      "mutated_line": "current_max_index = [--1] * (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [--1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 6,
      "original_line": "prevs = [[-1] * m for i in range(logit)]",
      "mutated_line": "prevs = [[+1] * m for i in range(logit)]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[+1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-3] * (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-3] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-1] * (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-1] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-0] * (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-0] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [-1] * (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-1] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 7,
      "original_line": "prev_map = [-2] * (n + 1)",
      "mutated_line": "prev_map = [--2] * (n + 1)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [--2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "prevs[0][idx] = current_max_index[prev_map[ele]]",
      "mutated_line": "prevs[1][idx] = current_max_index[prev_map[ele]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[1][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "prevs[0][idx] = current_max_index[prev_map[ele]]",
      "mutated_line": "prevs[-1][idx] = current_max_index[prev_map[ele]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[-1][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 13,
      "original_line": "prevs[0][idx] = current_max_index[prev_map[ele]]",
      "mutated_line": "prevs[1][idx] = current_max_index[prev_map[ele]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[1][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 18,
      "original_line": "if prevs[i - 1][idx] != -1:",
      "mutated_line": "if prevs[i - 1][idx] != +1:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != +1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "use = [i for i in range(n.bit_length()) if 1 & (n - 1) >> i]",
      "mutated_line": "use = [i for i in range(n.bit_length()) if 2 & n - 1 >> i]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 2 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "use = [i for i in range(n.bit_length()) if 1 & (n - 1) >> i]",
      "mutated_line": "use = [i for i in range(n.bit_length()) if 0 & n - 1 >> i]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 0 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "use = [i for i in range(n.bit_length()) if 1 & (n - 1) >> i]",
      "mutated_line": "use = [i for i in range(n.bit_length()) if 0 & n - 1 >> i]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 0 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "use = [i for i in range(n.bit_length()) if 1 & (n - 1) >> i]",
      "mutated_line": "use = [i for i in range(n.bit_length()) if -1 & n - 1 >> i]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if -1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-2] * (m + 2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-2] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-0] * (m + 2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-0] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [-0] * (m + 2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-0] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 23,
      "original_line": "ran = [-1] * (m + 2)",
      "mutated_line": "ran = [--1] * (m + 2)",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [--1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "UOI",
      "lineno": 29,
      "original_line": "if t == -1:",
      "mutated_line": "if t == +1:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == +1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - 1 < ran[r - 1]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 < ran[r - 1]))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - 1 > ran[r - 1]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 > ran[r - 1]))\n    return ans"
    },
    {
      "operator": "ROR",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - 1 == ran[r - 1]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 == ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) // log(3)) + 1",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(3)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) // log(1)) + 1",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(1)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) // log(0)) + 1",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(0)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) // log(1)) + 1",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(1)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 4,
      "original_line": "logit = floor(log(n) // log(2)) + 1",
      "mutated_line": "logit = floor(log(n) // log(-2)) + 1",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(-2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prevs = [[-1] * m for i in range(logit)]",
      "mutated_line": "prevs = [[-2] * m for i in range(logit)]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-2] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prevs = [[-1] * m for i in range(logit)]",
      "mutated_line": "prevs = [[-0] * m for i in range(logit)]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-0] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prevs = [[-1] * m for i in range(logit)]",
      "mutated_line": "prevs = [[-0] * m for i in range(logit)]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-0] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 6,
      "original_line": "prevs = [[-1] * m for i in range(logit)]",
      "mutated_line": "prevs = [[--1] * m for i in range(logit)]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[--1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (i, j) in zip(p[1:] + [p[0]], p):",
      "mutated_line": "for (i, j) in zip(p[2:] + [p[0]], p):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[2:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (i, j) in zip(p[1:] + [p[0]], p):",
      "mutated_line": "for (i, j) in zip(p[0:] + [p[0]], p):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[0:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (i, j) in zip(p[1:] + [p[0]], p):",
      "mutated_line": "for (i, j) in zip(p[0:] + [p[0]], p):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[0:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (i, j) in zip(p[1:] + [p[0]], p):",
      "mutated_line": "for (i, j) in zip(p[-1:] + [p[0]], p):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[-1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (i, j) in zip(p[1:] + [p[0]], p):",
      "mutated_line": "for (i, j) in zip(p[1:] + [p[1]], p):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[1]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (i, j) in zip(p[1:] + [p[0]], p):",
      "mutated_line": "for (i, j) in zip(p[1:] + [p[-1]], p):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[-1]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 9,
      "original_line": "for (i, j) in zip(p[1:] + [p[0]], p):",
      "mutated_line": "for (i, j) in zip(p[1:] + [p[1]], p):",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[1]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if prevs[i - 1][idx] != -1:",
      "mutated_line": "if prevs[i - 1][idx] != -2:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -2:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if prevs[i - 1][idx] != -1:",
      "mutated_line": "if prevs[i - 1][idx] != -0:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -0:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if prevs[i - 1][idx] != -1:",
      "mutated_line": "if prevs[i - 1][idx] != -0:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -0:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if prevs[i - 1][idx] != -1:",
      "mutated_line": "if prevs[i - 1][idx] != --1:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != --1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "use = [i for i in range(n.bit_length()) if 1 & (n - 1) >> i]",
      "mutated_line": "use = [i for i in range(n.bit_length()) if 1 & n + 1 >> i]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n + 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 21,
      "original_line": "use = [i for i in range(n.bit_length()) if 1 & (n - 1) >> i]",
      "mutated_line": "use = [i for i in range(n.bit_length()) if 1 & n * 1 >> i]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n * 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if t == -1:",
      "mutated_line": "if t == -2:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -2:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if t == -1:",
      "mutated_line": "if t == -0:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -0:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if t == -1:",
      "mutated_line": "if t == -0:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -0:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 29,
      "original_line": "if t == -1:",
      "mutated_line": "if t == --1:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == --1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l + 1 <= ran[r - 1]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l + 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l * 1 <= ran[r - 1]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l * 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if prevs[i - 1][idx] != -1:",
      "mutated_line": "if prevs[i + 1][idx] != -1:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i + 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 18,
      "original_line": "if prevs[i - 1][idx] != -1:",
      "mutated_line": "if prevs[i * 1][idx] != -1:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i * 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]",
      "mutated_line": "prevs[i][idx] = prevs[i + 1][prevs[i - 1][idx]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i + 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]",
      "mutated_line": "prevs[i][idx] = prevs[i * 1][prevs[i - 1][idx]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i * 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "use = [i for i in range(n.bit_length()) if 1 & (n - 1) >> i]",
      "mutated_line": "use = [i for i in range(n.bit_length()) if 1 & n - 2 >> i]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 2 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "use = [i for i in range(n.bit_length()) if 1 & (n - 1) >> i]",
      "mutated_line": "use = [i for i in range(n.bit_length()) if 1 & n - 0 >> i]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 0 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "use = [i for i in range(n.bit_length()) if 1 & (n - 1) >> i]",
      "mutated_line": "use = [i for i in range(n.bit_length()) if 1 & n - 0 >> i]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 0 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 21,
      "original_line": "use = [i for i in range(n.bit_length()) if 1 & (n - 1) >> i]",
      "mutated_line": "use = [i for i in range(n.bit_length()) if 1 & n - -1 >> i]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - -1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - 2 <= ran[r - 1]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 2 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - 0 <= ran[r - 1]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 0 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - 0 <= ran[r - 1]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 0 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - -1 <= ran[r - 1]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - -1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - 1 <= ran[r + 1]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r + 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - 1 <= ran[r * 1]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r * 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if prevs[i - 1][idx] != -1:",
      "mutated_line": "if prevs[i - 2][idx] != -1:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 2][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if prevs[i - 1][idx] != -1:",
      "mutated_line": "if prevs[i - 0][idx] != -1:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 0][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if prevs[i - 1][idx] != -1:",
      "mutated_line": "if prevs[i - 0][idx] != -1:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 0][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 18,
      "original_line": "if prevs[i - 1][idx] != -1:",
      "mutated_line": "if prevs[i - -1][idx] != -1:",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - -1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]",
      "mutated_line": "prevs[i][idx] = prevs[i - 2][prevs[i - 1][idx]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 2][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]",
      "mutated_line": "prevs[i][idx] = prevs[i - 0][prevs[i - 1][idx]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 0][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]",
      "mutated_line": "prevs[i][idx] = prevs[i - 0][prevs[i - 1][idx]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 0][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]",
      "mutated_line": "prevs[i][idx] = prevs[i - -1][prevs[i - 1][idx]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - -1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]",
      "mutated_line": "prevs[i][idx] = prevs[i - 1][prevs[i + 1][idx]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i + 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "AOR",
      "lineno": 19,
      "original_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]",
      "mutated_line": "prevs[i][idx] = prevs[i - 1][prevs[i * 1][idx]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i * 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - 1 <= ran[r - 2]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 2]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - 1 <= ran[r - 0]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 0]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - 1 <= ran[r - 0]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 0]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 37,
      "original_line": "ans[i] = str(int(l - 1 <= ran[r - 1]))",
      "mutated_line": "ans[i] = str(int(l - 1 <= ran[r - -1]))",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - -1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]",
      "mutated_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 2][idx]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 2][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]",
      "mutated_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 0][idx]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 0][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]",
      "mutated_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 0][idx]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - 0][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    },
    {
      "operator": "CRP",
      "lineno": 19,
      "original_line": "prevs[i][idx] = prevs[i - 1][prevs[i - 1][idx]]",
      "mutated_line": "prevs[i][idx] = prevs[i - 1][prevs[i - -1][idx]]",
      "code": "def has_cyclic_shift_subsequence(n, m, q, p, a, queries):\n    from math import log, floor\n    logit = floor(log(n) // log(2)) + 1\n    current_max_index = [-1] * (n + 1)\n    prevs = [[-1] * m for i in range(logit)]\n    prev_map = [-2] * (n + 1)\n    for (i, j) in zip(p[1:] + [p[0]], p):\n        prev_map[i] = j\n    for (idx, ele) in enumerate(a):\n        prevs[0][idx] = current_max_index[prev_map[ele]]\n        current_max_index[ele] = idx\n    for i in range(1, logit):\n        for (idx, ele) in enumerate(a):\n            if prevs[i - 1][idx] != -1:\n                prevs[i][idx] = prevs[i - 1][prevs[i - -1][idx]]\n    use = [i for i in range(n.bit_length()) if 1 & n - 1 >> i]\n    max_pre = -1\n    ran = [-1] * (m + 2)\n    for i in range(m):\n        t = i\n        for dim in use:\n            t = prevs[dim][t]\n            if t == -1:\n                break\n        max_pre = max(t, max_pre)\n        ran[i] = max_pre\n    ans = [None] * q\n    for i in range(q):\n        (l, r) = queries[i]\n        ans[i] = str(int(l - 1 <= ran[r - 1]))\n    return ans"
    }
  ]
}